create database atbdb WITH ENCODING 'UTF-8' dbcompatibility 'B';
\c atbdb
CREATE SCHEMA atbdb_schema;
SET CURRENT_SCHEMA TO atbdb_schema;
ALTER TABLE pg_catalog.pg_class MODIFY COLUMN relname int; -- ERROR
ERROR:  permission denied: "pg_class" is a system catalog
-- cstore not supported
CREATE TABLE test_at_modify_cstore(
    a int,
    b int NOT NULL
) WITH (ORIENTATION=column, COMPRESSION=high, COMPRESSLEVEL=2);
ALTER TABLE test_at_modify_cstore MODIFY COLUMN b int PRIMARY KEY;
ERROR:  Un-support feature
DETAIL:  column-store relation doesn't support this ALTER yet
DROP TABLE test_at_modify_cstore;
-- test modify column syntax
CREATE TABLE test_at_modify_syntax(
    a int,
    b int NOT NULL
);
ALTER TABLE test_at_modify_syntax MODIFY b int INVISIBLE; -- ERROR
ERROR:  syntax error at or near "INVISIBLE"
LINE 1: ALTER TABLE test_at_modify_syntax MODIFY b int INVISIBLE;
                                                       ^
ALTER TABLE test_at_modify_syntax MODIFY b int CHECK (b < 100) NOT ENFORCED; -- ERROR
ERROR:  syntax error at or near "ENFORCED"
LINE 1: ..._at_modify_syntax MODIFY b int CHECK (b < 100) NOT ENFORCED;
                                                              ^
ALTER TABLE test_at_modify_syntax MODIFY b int GENERATED ALWAYS AS (a+1) VIRTUAL; -- ERROR
ERROR:  syntax error at or near "VIRTUAL"
LINE 1: ...odify_syntax MODIFY b int GENERATED ALWAYS AS (a+1) VIRTUAL;
                                                               ^
ALTER TABLE test_at_modify_syntax MODIFY b int KEY; -- ERROR
ERROR:  syntax error at or near "KEY"
LINE 1: ALTER TABLE test_at_modify_syntax MODIFY b int KEY;
                                                       ^
ALTER TABLE test_at_modify_syntax MODIFY COLUMN xmax int; -- ERROR
ERROR:  cannot alter system column "xmax"
ALTER TABLE test_at_modify_syntax MODIFY b int encrypted with (column_encryption_key = ImgCEK, encryption_type = DETERMINISTIC); -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change column to encrypted column is not supported
ALTER TABLE test_at_modify_syntax MODIFY b varchar(8); -- alter column type only
\d+ test_at_modify_syntax;
                    Table "atbdb_schema.test_at_modify_syntax"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) | not null  | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

set b_format_behavior_compat_options = 'enable_modify_column';
show b_format_behavior_compat_options;
 b_format_behavior_compat_options 
----------------------------------
 enable_modify_column
(1 row)

ALTER TABLE test_at_modify_syntax MODIFY b varchar(8); -- modify column
\d+ test_at_modify_syntax;
                    Table "atbdb_schema.test_at_modify_syntax"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

set b_format_behavior_compat_options = '';
show b_format_behavior_compat_options;
 b_format_behavior_compat_options 
----------------------------------
 
(1 row)

ALTER TABLE test_at_modify_syntax MODIFY b int UNIQUE KEY;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_modify_syntax_b_key" for table "test_at_modify_syntax"
\d+ test_at_modify_syntax;
             Table "atbdb_schema.test_at_modify_syntax"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "test_at_modify_syntax_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify_syntax MODIFY COLUMN b int PRIMARY KEY;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_syntax_pkey" for table "test_at_modify_syntax"
\d+ test_at_modify_syntax;
             Table "atbdb_schema.test_at_modify_syntax"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer | not null  | plain   |              | 
Indexes:
    "test_at_modify_syntax_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default
    "test_at_modify_syntax_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE test_at_modify_syntax;
-- test modify syntax with on update and comment
CREATE TABLE at_change_comment(col1 timestamp not null comment 'last changed time' default current_timestamp); -- ERROR, comment clause must be after column constraints
ERROR:  syntax error at or near "default"
LINE 1: ...l1 timestamp not null comment 'last changed time' default cu...
                                                             ^
create table at_modify_comment(col1 timestamp not null default current_timestamp comment 'last changed time');
\d+ at_modify_comment
                                         Table "atbdb_schema.at_modify_comment"
 Column |            Type             |             Modifiers              | Storage | Stats target |    Description    
--------+-----------------------------+------------------------------------+---------+--------------+-------------------
 col1   | timestamp without time zone | not null default pg_systimestamp() | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY col1 comment 'last changed time'; -- ERROR
ERROR:  syntax error at or near "'last changed time'"
LINE 1: ALTER TABLE at_modify_comment MODIFY col1 comment 'last chan...
                                                          ^
ALTER TABLE at_modify_comment MODIFY COLUMN col1 comment 'last changed time'; -- ERROR
ERROR:  syntax error at or near "'last changed time'"
LINE 1: ...ABLE at_modify_comment MODIFY COLUMN col1 comment 'last chan...
                                                             ^
ALTER TABLE at_modify_comment MODIFY COLUMN col1 timestamp not null comment 'last changed time' default current_timestamp; -- ERROR, comment clause must be after column constraints
ERROR:  syntax error at or near "default"
LINE 1: ...l1 timestamp not null comment 'last changed time' default cu...
                                                             ^
ALTER TABLE at_modify_comment MODIFY column col1 timestamp not null default current_timestamp on update current_timestamp comment 'last changed time';
\d+ at_modify_comment
                                                       Table "atbdb_schema.at_modify_comment"
 Column |            Type             |                           Modifiers                            | Storage | Stats target |    Description    
--------+-----------------------------+----------------------------------------------------------------+---------+--------------+-------------------
 col1   | timestamp without time zone | not null default pg_systimestamp() on update pg_systimestamp() | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY col1 timestamp on update current_timestamp;
\d+ at_modify_comment
                                  Table "atbdb_schema.at_modify_comment"
 Column |            Type             |          Modifiers          | Storage | Stats target | Description 
--------+-----------------------------+-----------------------------+---------+--------------+-------------
 col1   | timestamp without time zone | on update pg_systimestamp() | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY col1 timestamp comment 'last changed time';
\d+ at_modify_comment
                            Table "atbdb_schema.at_modify_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description    
--------+-----------------------------+-----------+---------+--------------+-------------------
 col1   | timestamp without time zone |           | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY COLUMN col1 timestamp on update current_timestamp;
\d+ at_modify_comment
                                  Table "atbdb_schema.at_modify_comment"
 Column |            Type             |          Modifiers          | Storage | Stats target | Description 
--------+-----------------------------+-----------------------------+---------+--------------+-------------
 col1   | timestamp without time zone | on update pg_systimestamp() | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY COLUMN col1 timestamp comment 'last changed time';
\d+ at_modify_comment
                            Table "atbdb_schema.at_modify_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description    
--------+-----------------------------+-----------+---------+--------------+-------------------
 col1   | timestamp without time zone |           | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment ADD COLUMN id1 int FIRST, MODIFY COLUMN col1 timestamp on update current_timestamp;
\d+ at_modify_comment
                                  Table "atbdb_schema.at_modify_comment"
 Column |            Type             |          Modifiers          | Storage | Stats target | Description 
--------+-----------------------------+-----------------------------+---------+--------------+-------------
 id1    | integer                     |                             | plain   |              | 
 col1   | timestamp without time zone | on update pg_systimestamp() | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY COLUMN col1 timestamp AFTER id1 comment 'last changed time'; -- ERROR
ERROR:  syntax error at or near "comment"
LINE 1: ...fy_comment MODIFY COLUMN col1 timestamp AFTER id1 comment 'l...
                                                             ^
ALTER TABLE at_modify_comment ADD COLUMN id2 int AFTER id1, MODIFY COLUMN col1 timestamp comment 'last changed time' AFTER id1;
\d+ at_modify_comment
                            Table "atbdb_schema.at_modify_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description    
--------+-----------------------------+-----------+---------+--------------+-------------------
 id1    | integer                     |           | plain   |              | 
 id2    | integer                     |           | plain   |              | 
 col1   | timestamp without time zone |           | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_modify_comment MODIFY COLUMN col1 timestamp comment 'last changed time1' comment 'last changed time2' comment 'last changed time3';
\d+ at_modify_comment
                             Table "atbdb_schema.at_modify_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description     
--------+-----------------------------+-----------+---------+--------------+--------------------
 id1    | integer                     |           | plain   |              | 
 id2    | integer                     |           | plain   |              | 
 col1   | timestamp without time zone |           | plain   |              | last changed time3
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE IF EXISTS at_modify_comment;
-- test modify column without data
CREATE TABLE test_at_modify(
    a int,
    b int NOT NULL
);
ALTER TABLE test_at_modify MODIFY b varchar(8) NULL;
\d+ test_at_modify;
                        Table "atbdb_schema.test_at_modify"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b varchar(8) DEFAULT '0';
\d+ test_at_modify;
                                  Table "atbdb_schema.test_at_modify"
 Column |         Type         |           Modifiers            | Storage  | Stats target | Description 
--------+----------------------+--------------------------------+----------+--------------+-------------
 a      | integer              |                                | plain    |              | 
 b      | character varying(8) | default '0'::character varying | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b int AUTO_INCREMENT PRIMARY KEY INITIALLY DEFERRED;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_b_seq" for serial column "test_at_modify.b"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_pkey" for table "test_at_modify"
\d+ test_at_modify;
                        Table "atbdb_schema.test_at_modify"
 Column |  Type   |        Modifiers        | Storage | Stats target | Description 
--------+---------+-------------------------+---------+--------------+-------------
 a      | integer |                         | plain   |              | 
 b      | integer | not null AUTO_INCREMENT | plain   |              | 
Indexes:
    "test_at_modify_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default DEFERRABLE INITIALLY DEFERRED
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b varchar(8) UNIQUE DEFERRABLE;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_modify_b_key" for table "test_at_modify"
\d+ test_at_modify;
                        Table "atbdb_schema.test_at_modify"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) | not null  | extended |              | 
Indexes:
    "test_at_modify_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default DEFERRABLE INITIALLY DEFERRED
    "test_at_modify_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default DEFERRABLE
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b varchar(8) CHECK (b < 'a');
\d+ test_at_modify;
                        Table "atbdb_schema.test_at_modify"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) | not null  | extended |              | 
Indexes:
    "test_at_modify_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default DEFERRABLE INITIALLY DEFERRED
    "test_at_modify_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default DEFERRABLE
Check constraints:
    "test_at_modify_b_check" CHECK (b::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b varchar(8) COLLATE "POSIX";
\d+ test_at_modify;
                              Table "atbdb_schema.test_at_modify"
 Column |         Type         |       Modifiers        | Storage  | Stats target | Description 
--------+----------------------+------------------------+----------+--------------+-------------
 a      | integer              |                        | plain    |              | 
 b      | character varying(8) | collate POSIX not null | extended |              | 
Indexes:
    "test_at_modify_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default DEFERRABLE INITIALLY DEFERRED
    "test_at_modify_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default DEFERRABLE
Check constraints:
    "test_at_modify_b_check" CHECK (b::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b varchar(8) GENERATED ALWAYS AS (a+1) STORED;
\d+ test_at_modify;
                                          Table "atbdb_schema.test_at_modify"
 Column |         Type         |                   Modifiers                   | Storage  | Stats target | Description 
--------+----------------------+-----------------------------------------------+----------+--------------+-------------
 a      | integer              |                                               | plain    |              | 
 b      | character varying(8) | not null generated always as ((a + 1)) stored | extended |              | 
Indexes:
    "test_at_modify_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default DEFERRABLE INITIALLY DEFERRED
    "test_at_modify_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default DEFERRABLE
Check constraints:
    "test_at_modify_b_check" CHECK (b::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify MODIFY b int NOT NULL;
\d+ test_at_modify;
                 Table "atbdb_schema.test_at_modify"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer | not null  | plain   |              | 
Indexes:
    "test_at_modify_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default DEFERRABLE INITIALLY DEFERRED
    "test_at_modify_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default DEFERRABLE
Check constraints:
    "test_at_modify_b_check" CHECK (b::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_tabledef('test_at_modify'::regclass);
                                                                     pg_get_tabledef                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = atbdb_schema;                                                                                                                        +
 CREATE TABLE test_at_modify (                                                                                                                          +
     a integer,                                                                                                                                         +
     b integer NOT NULL,                                                                                                                                +
     CONSTRAINT test_at_modify_b_check CHECK (((b)::text < 'a'::text))                                                                                  +
 )                                                                                                                                                      +
 WITH (orientation=row, compression=no);                                                                                                                +
 ALTER TABLE test_at_modify ADD CONSTRAINT test_at_modify_b_key UNIQUE USING btree (b) DEFERRABLE DEFERRABLE;                                           +
 ALTER TABLE test_at_modify ADD CONSTRAINT test_at_modify_pkey PRIMARY KEY USING btree  (b) DEFERRABLE INITIALLY DEFERRED DEFERRABLE INITIALLY DEFERRED;
(1 row)

INSERT INTO test_at_modify VALUES(1,1);
DROP TABLE test_at_modify;
-- test modify column datatype
CREATE TABLE test_at_modify_type(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_modify_type VALUES(1,1);
INSERT INTO test_at_modify_type VALUES(2,2);
INSERT INTO test_at_modify_type VALUES(3,3);
ALTER TABLE test_at_modify_type MODIFY COLUMN b varchar(8);
SELECT * FROM test_at_modify_type where b = '3';
 a | b 
---+---
 3 | 3
(1 row)

ALTER TABLE test_at_modify_type MODIFY COLUMN b DATE; -- ERROR
ERROR:  invalid input syntax for type date: "1"
ALTER TABLE test_at_modify_type MODIFY COLUMN b RAW;
SELECT * FROM test_at_modify_type ORDER BY 1,2;
 a | b  
---+----
 1 | 01
 2 | 02
 3 | 03
(3 rows)

DROP TABLE test_at_modify_type;
CREATE TABLE test_at_modify_type(
    a int,
    b serial NOT NULL
);
NOTICE:  CREATE TABLE will create implicit sequence "test_at_modify_type_b_seq" for serial column "test_at_modify_type.b"
INSERT INTO test_at_modify_type VALUES(1,1);
INSERT INTO test_at_modify_type VALUES(2,2);
INSERT INTO test_at_modify_type VALUES(3,3);
ALTER TABLE test_at_modify_type MODIFY COLUMN b int;
ALTER TABLE test_at_modify_type MODIFY COLUMN b int[]; -- ERROR
ERROR:  column "b" cannot be cast automatically to type integer[]
HINT:  Specify a USING expression to perform the conversion.
ALTER TABLE test_at_modify_type MODIFY COLUMN b int16;
ALTER TABLE test_at_modify_type MODIFY COLUMN b serial; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change column to type 'serial'
ALTER TABLE test_at_modify_type MODIFY COLUMN b DECIMAL(4,2);
SELECT * FROM test_at_modify_type where b = 3;
 a |  b   
---+------
 3 | 3.00
(1 row)

ALTER TABLE test_at_modify_type MODIFY COLUMN b BOOLEAN;
SELECT * FROM test_at_modify_type ORDER BY 1,2;
 a | b 
---+---
 1 | t
 2 | t
 3 | t
(3 rows)

DROP TABLE test_at_modify_type;
CREATE TABLE test_at_modify_type(
    a int,
    b text
);
INSERT INTO test_at_modify_type VALUES(1,'beijing');
INSERT INTO test_at_modify_type VALUES(2,'shanghai');
INSERT INTO test_at_modify_type VALUES(3,'guangzhou');
ALTER TABLE test_at_modify_type MODIFY COLUMN b SET('beijing','shanghai','nanjing','wuhan'); -- ERROR
NOTICE:  ALTER TABLE will create implicit set "test_at_modify_type_b_set" for column "test_at_modify_type.b"
ERROR:  invalid input value for set test_at_modify_type_b_set: 'guangzhou'
ALTER TABLE test_at_modify_type MODIFY COLUMN b SET('beijing','shanghai','nanjing','guangzhou');
NOTICE:  ALTER TABLE will create implicit set "test_at_modify_type_b_set" for column "test_at_modify_type.b"
ALTER TABLE test_at_modify_type MODIFY COLUMN b SET('beijing','shanghai','guangzhou','wuhan'); -- ERROR
ERROR:  can not alter column type to another set
select pg_get_tabledef('test_at_modify_type'::regclass);
                     pg_get_tabledef                      
----------------------------------------------------------
 SET search_path = atbdb_schema;                         +
 CREATE TABLE test_at_modify_type (                      +
     a integer,                                          +
     b SET('beijing', 'shanghai', 'nanjing', 'guangzhou')+
 )                                                       +
 WITH (orientation=row, compression=no);
(1 row)

DROP TABLE test_at_modify_type;
CREATE TABLE test_at_modify_type(
    a int,
    b varchar(32)
);
INSERT INTO test_at_modify_type VALUES(1,'2022-11-22 12:00:00');
INSERT INTO test_at_modify_type VALUES(2,'2022-11-23 12:00:00');
INSERT INTO test_at_modify_type VALUES(3,'2022-11-24 12:00:00');
ALTER TABLE test_at_modify_type MODIFY COLUMN b varchar(10); -- ERROR
ERROR:  value too long for type character varying(10)
ALTER TABLE test_at_modify_type MODIFY COLUMN b DATE;
SELECT * FROM test_at_modify_type ORDER BY 1,2;
 a |     b      
---+------------
 1 | 11-22-2022
 2 | 11-23-2022
 3 | 11-24-2022
(3 rows)

DROP TABLE test_at_modify_type;
CREATE TABLE test_at_modify_type(
    a int,
    b int[] NOT NULL
);
INSERT INTO test_at_modify_type VALUES(1,ARRAY[1,1]);
INSERT INTO test_at_modify_type VALUES(2,ARRAY[2,2]);
INSERT INTO test_at_modify_type VALUES(3,ARRAY[3,3]);
ALTER TABLE test_at_modify_type MODIFY COLUMN b float4[];
SELECT * FROM test_at_modify_type ORDER BY 1,2;
 a |   b   
---+-------
 1 | {1,1}
 2 | {2,2}
 3 | {3,3}
(3 rows)

DROP TABLE test_at_modify_type;
-- test modify column constraint
CREATE TABLE test_at_modify_constr(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_modify_constr VALUES(1,1);
INSERT INTO test_at_modify_constr VALUES(2,2);
INSERT INTO test_at_modify_constr VALUES(3,3);
ALTER TABLE test_at_modify_constr MODIFY b varchar(8) NOT NULL NULL; -- ERROR
ERROR:  conflicting NULL/NOT NULL declarations for column "b" of table "test_at_modify_constr"
LINE 1: ...BLE test_at_modify_constr MODIFY b varchar(8) NOT NULL NULL;
                                                                  ^
ALTER TABLE test_at_modify_constr MODIFY b varchar(8) UNIQUE KEY NULL;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_modify_constr_b_key" for table "test_at_modify_constr"
INSERT INTO test_at_modify_constr VALUES(3,3); -- ERROR
ERROR:  duplicate key value violates unique constraint "test_at_modify_constr_b_key"
DETAIL:  Key (b)=(3) already exists.
INSERT INTO test_at_modify_constr VALUES(4,NULL);
ALTER TABLE test_at_modify_constr MODIFY b int NULL PRIMARY KEY; -- ERROR
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_constr_pkey" for table "test_at_modify_constr"
ERROR:  column "b" contains null values
DELETE FROM test_at_modify_constr WHERE b IS NULL;
ALTER TABLE test_at_modify_constr MODIFY b int NULL PRIMARY KEY;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_constr_pkey" for table "test_at_modify_constr"
INSERT INTO test_at_modify_constr VALUES(4,NULL); -- ERROR
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (4, null).
ALTER TABLE test_at_modify_constr MODIFY b varchar(8) CONSTRAINT t_at_m_check CHECK (b < 3); -- ERROR
ERROR:  check constraint "t_at_m_check" is violated by some row
ALTER TABLE test_at_modify_constr MODIFY b varchar(8) CONSTRAINT t_at_m_check CHECK (b < 5);
ALTER TABLE test_at_modify_constr MODIFY b varchar(8) CONSTRAINT t_at_m_check CHECK (b = a); -- ERROR
ERROR:  constraint "t_at_m_check" for relation "test_at_modify_constr" already exists
ALTER TABLE test_at_modify_constr MODIFY b varchar(8) CONSTRAINT t_at_m_check_1 CHECK (b = a);
INSERT INTO test_at_modify_constr VALUES(4,4);
INSERT INTO test_at_modify_constr VALUES(5,5); -- ERROR
ERROR:  new row for relation "test_at_modify_constr" violates check constraint "t_at_m_check"
DETAIL:  N/A
INSERT INTO test_at_modify_constr VALUES(6,'a'); -- ERROR
ERROR:  new row for relation "test_at_modify_constr" violates check constraint "t_at_m_check_1"
DETAIL:  N/A
INSERT INTO test_at_modify_constr VALUES(0,'a');
ALTER TABLE test_at_modify_constr MODIFY b int NOT NULL PRIMARY KEY; -- ERROR
ERROR:  multiple primary keys for table "test_at_modify_constr" are not allowed
ALTER TABLE test_at_modify_constr MODIFY b int NOT NULL;
INSERT INTO test_at_modify_constr VALUES(5,5); -- ERROR
ERROR:  new row for relation "test_at_modify_constr" violates check constraint "t_at_m_check"
DETAIL:  N/A
SELECT b FROM test_at_modify_constr ORDER BY 1;
 b 
---
 0
 1
 2
 3
 4
(5 rows)

select pg_get_tabledef('test_at_modify_constr'::regclass);
                                              pg_get_tabledef                                              
-----------------------------------------------------------------------------------------------------------
 SET search_path = atbdb_schema;                                                                          +
 CREATE TABLE test_at_modify_constr (                                                                     +
     a integer,                                                                                           +
     b integer NOT NULL,                                                                                  +
     CONSTRAINT t_at_m_check_1 CHECK (((b)::bigint = a)),                                                 +
     CONSTRAINT t_at_m_check CHECK (((b)::bigint < 5))                                                    +
 )                                                                                                        +
 WITH (orientation=row, compression=no);                                                                  +
 ALTER TABLE test_at_modify_constr ADD CONSTRAINT test_at_modify_constr_b_key UNIQUE USING btree (b);     +
 ALTER TABLE test_at_modify_constr ADD CONSTRAINT test_at_modify_constr_pkey PRIMARY KEY USING btree  (b);
(1 row)

ALTER TABLE test_at_modify_constr MODIFY b int NOT NULL REFERENCES test_at_ref (a); -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change column REFERENCES constraint is not supported
DROP TABLE test_at_modify_constr;
-- test modify column default
CREATE TABLE test_at_modify_default(
    a int,
    b int DEFAULT NULL
);
INSERT INTO test_at_modify_default VALUES(1,1);
INSERT INTO test_at_modify_default VALUES(2,2);
INSERT INTO test_at_modify_default VALUES(3,3);
ALTER TABLE test_at_modify_default MODIFY b bigint DEFAULT (a+1); -- ERROR
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
ALTER TABLE test_at_modify_default MODIFY b bigint DEFAULT NULL;
\d+ test_at_modify_default;
             Table "atbdb_schema.test_at_modify_default"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | bigint  |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify_default MODIFY b varchar(8) DEFAULT 'a' GENERATED ALWAYS AS (a+1) STORED; -- ERROR
ERROR:  both default and generation expression specified for column "b" of table "test_at_modify_default"
LINE 1: ...at_modify_default MODIFY b varchar(8) DEFAULT 'a' GENERATED ...
                                                             ^
ALTER TABLE test_at_modify_default MODIFY b varchar(8) DEFAULT 'a';
\d+ test_at_modify_default;
                              Table "atbdb_schema.test_at_modify_default"
 Column |         Type         |           Modifiers            | Storage  | Stats target | Description 
--------+----------------------+--------------------------------+----------+--------------+-------------
 a      | integer              |                                | plain    |              | 
 b      | character varying(8) | default 'a'::character varying | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

INSERT INTO test_at_modify_default VALUES(0,DEFAULT);
SELECT b FROM test_at_modify_default ORDER BY 1;
 b 
---
 1
 2
 3
 a
(4 rows)

ALTER TABLE test_at_modify_default MODIFY b int DEFAULT 4 AUTO_INCREMENT; -- ERROR
ERROR:  multiple default values specified for column "b" of table "test_at_modify_default"
LINE 1: ...BLE test_at_modify_default MODIFY b int DEFAULT 4 AUTO_INCRE...
                                                             ^
ALTER TABLE test_at_modify_default MODIFY b int DEFAULT 4;
INSERT INTO test_at_modify_default VALUES(4,DEFAULT);
SELECT b FROM test_at_modify_default ORDER BY 1;
 b 
---
 0
 1
 2
 3
 4
(5 rows)

ALTER TABLE test_at_modify_default MODIFY b varchar(8) GENERATED ALWAYS AS (a+1) STORED;
SELECT a,b FROM test_at_modify_default ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 1 | 2
 2 | 3
 3 | 4
 4 | 5
(5 rows)

ALTER TABLE test_at_modify_default MODIFY a varchar(8) DEFAULT 'a';
INSERT INTO test_at_modify_default VALUES(DEFAULT,DEFAULT);
SELECT a,b FROM test_at_modify_default ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 1 | 2
 2 | 3
 3 | 4
 4 | 5
 a | 1
(6 rows)

\d+ test_at_modify_default;
                                      Table "atbdb_schema.test_at_modify_default"
 Column |         Type         |                   Modifiers                    | Storage  | Stats target | Description 
--------+----------------------+------------------------------------------------+----------+--------------+-------------
 a      | character varying(8) | default 'a'::character varying                 | extended |              | 
 b      | character varying(8) | generated always as (((a)::bigint + 1)) stored | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE test_at_modify_default;
-- test modify column depended by generated column
CREATE TABLE test_at_modify_generated(
    a int,
    b varchar(32),
    c varchar(32) GENERATED ALWAYS AS (b) STORED
);
INSERT INTO test_at_modify_generated(a,b) VALUES(1,'2022-11-22 12:00:00');
INSERT INTO test_at_modify_generated(a,b) VALUES(2,'2022-11-23 12:00:00');
INSERT INTO test_at_modify_generated(a,b) VALUES(3,'2022-11-24 12:00:00');
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 a |          b          |          c          
---+---------------------+---------------------
 1 | 2022-11-22 12:00:00 | 2022-11-22 12:00:00
 2 | 2022-11-23 12:00:00 | 2022-11-23 12:00:00
 3 | 2022-11-24 12:00:00 | 2022-11-24 12:00:00
(3 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN b DATE;
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 a |     b      |     c      
---+------------+------------
 1 | 11-22-2022 | 11-22-2022
 2 | 11-23-2022 | 11-23-2022
 3 | 11-24-2022 | 11-24-2022
(3 rows)

\d+ test_at_modify_generated
                              Table "atbdb_schema.test_at_modify_generated"
 Column |         Type          |           Modifiers            | Storage  | Stats target | Description 
--------+-----------------------+--------------------------------+----------+--------------+-------------
 a      | integer               |                                | plain    |              | 
 b      | date                  |                                | plain    |              | 
 c      | character varying(32) | generated always as (b) stored | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_modify_generated MODIFY COLUMN b varchar(32) AFTER c;
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 a |     c      |     b      
---+------------+------------
 1 | 11-22-2022 | 11-22-2022
 2 | 11-23-2022 | 11-23-2022
 3 | 11-24-2022 | 11-24-2022
(3 rows)

DROP TABLE test_at_modify_generated;
CREATE TABLE test_at_modify_generated(
    a int,
    b int GENERATED ALWAYS AS (a+1) STORED
);
INSERT INTO test_at_modify_generated(a,b) VALUES(-1,DEFAULT);
INSERT INTO test_at_modify_generated(a,b) VALUES(0,DEFAULT);
INSERT INTO test_at_modify_generated(a,b) VALUES(1,DEFAULT);
INSERT INTO test_at_modify_generated(a,b) VALUES(2,DEFAULT);
ALTER TABLE test_at_modify_generated MODIFY COLUMN b varchar(8) GENERATED ALWAYS AS (a) STORED FIRST, MODIFY COLUMN a varchar(8) AFTER b;
INSERT INTO test_at_modify_generated(a,b) VALUES(3,DEFAULT);
SELECT * FROM test_at_modify_generated ORDER BY b::int,a::int;
 b  | a  
----+----
 -1 | -1
 0  | 0
 1  | 1
 2  | 2
 3  | 3
(5 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN a int AFTER b, MODIFY COLUMN b int GENERATED ALWAYS AS (a+1) STORED FIRST;
INSERT INTO test_at_modify_generated(a,b) VALUES(4,DEFAULT);
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 b | a  
---+----
 0 | -1
 1 |  0
 2 |  1
 3 |  2
 4 |  3
 5 |  4
(6 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN b varchar(8) AFTER a, MODIFY COLUMN a varchar(8) AFTER b;
INSERT INTO test_at_modify_generated(a,b) VALUES(5,DEFAULT);
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 b | a  
---+----
 0 | -1
 1 | 0
 2 | 1
 3 | 2
 4 | 3
 5 | 4
   | 5
(7 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN b int GENERATED ALWAYS AS (a) STORED;
ALTER TABLE test_at_modify_generated MODIFY COLUMN a int FIRST, MODIFY COLUMN b int FIRST;
INSERT INTO test_at_modify_generated(a,b) VALUES(6,DEFAULT);
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 b  | a  
----+----
 -1 | -1
  0 |  0
  1 |  1
  2 |  2
  3 |  3
  4 |  4
  5 |  5
    |  6
(8 rows)

DROP TABLE test_at_modify_generated;
CREATE TABLE test_at_modify_generated(
    a int,
    b int GENERATED ALWAYS AS (a+1) STORED
);
INSERT INTO test_at_modify_generated(a,b) VALUES(-1,DEFAULT);
INSERT INTO test_at_modify_generated(a,b) VALUES(0,DEFAULT);
INSERT INTO test_at_modify_generated(a,b) VALUES(1,DEFAULT);
ALTER TABLE test_at_modify_generated MODIFY COLUMN a bool;
ALTER TABLE test_at_modify_generated MODIFY COLUMN a int;
INSERT INTO test_at_modify_generated(a,b) VALUES(100,DEFAULT);
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
  a  |  b  
-----+-----
   0 |   1
   1 |   2
   1 |   2
 100 | 101
(4 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN a bool, MODIFY COLUMN b varchar(32);
\d test_at_modify_generated
Table "atbdb_schema.test_at_modify_generated"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 a      | boolean               | 
 b      | character varying(32) | 

SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 a |  b  
---+-----
 f | 1
 t | 101
 t | 2
 t | 2
(4 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN b int GENERATED ALWAYS AS (a+1) STORED, MODIFY COLUMN a int;
\d test_at_modify_generated
           Table "atbdb_schema.test_at_modify_generated"
 Column |  Type   |                   Modifiers                    
--------+---------+------------------------------------------------
 a      | integer | 
 b      | integer | generated always as (((a)::bigint + 1)) stored

SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 1 | 2
 1 | 2
 1 | 2
(4 rows)

INSERT INTO test_at_modify_generated(a,b) VALUES(100,DEFAULT);
SELECT * FROM test_at_modify_generated ORDER BY 1,2;
  a  |  b  
-----+-----
   0 |   1
   1 |   2
   1 |   2
   1 |   2
 100 | 101
(5 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN b bool GENERATED ALWAYS AS (a) STORED;
\d test_at_modify_generated
   Table "atbdb_schema.test_at_modify_generated"
 Column |  Type   |           Modifiers            
--------+---------+--------------------------------
 a      | integer | 
 b      | boolean | generated always as (a) stored

SELECT * FROM test_at_modify_generated ORDER BY 1,2;
  a  | b 
-----+---
   0 | f
   1 | t
   1 | t
   1 | t
 100 | t
(5 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN a bool;
\d test_at_modify_generated
   Table "atbdb_schema.test_at_modify_generated"
 Column |  Type   |           Modifiers            
--------+---------+--------------------------------
 a      | boolean | 
 b      | boolean | generated always as (a) stored

SELECT * FROM test_at_modify_generated ORDER BY 1,2;
 a | b 
---+---
 f | f
 t | t
 t | t
 t | t
 t | t
(5 rows)

ALTER TABLE test_at_modify_generated MODIFY COLUMN a int;
INSERT INTO test_at_modify_generated(a,b) VALUES(100,DEFAULT);
\d test_at_modify_generated
   Table "atbdb_schema.test_at_modify_generated"
 Column |  Type   |           Modifiers            
--------+---------+--------------------------------
 a      | integer | 
 b      | boolean | generated always as (a) stored

SELECT * FROM test_at_modify_generated ORDER BY 1,2;
  a  | b 
-----+---
   0 | f
   1 | t
   1 | t
   1 | t
   1 | t
 100 | t
(6 rows)

DROP TABLE test_at_modify_generated;
-- error generated column reference generated column
CREATE TABLE test_at_modify_generated(
    a int,
    b int,
    c int GENERATED ALWAYS AS (b+1) STORED
);
INSERT INTO test_at_modify_generated(a,b) VALUES(1,1);
ALTER TABLE test_at_modify_generated MODIFY b float4 GENERATED ALWAYS AS (a+1000) STORED; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  A generated column cannot reference another generated column.
ALTER TABLE test_at_modify_generated MODIFY b float4 GENERATED ALWAYS AS (c+1000) STORED; -- ERROR
ERROR:  cannot use generated column "c" in column generation expression
DETAIL:  A generated column cannot reference another generated column.
ALTER TABLE test_at_modify_generated MODIFY a float4 GENERATED ALWAYS AS (b+1000) STORED, MODIFY c float4 GENERATED ALWAYS AS (a+1000) STORED; -- ERROR
ERROR:  cannot use generated column "a" in column generation expression
DETAIL:  A generated column cannot reference another generated column.
ALTER TABLE test_at_modify_generated MODIFY COLUMN c float4, MODIFY b float4 GENERATED ALWAYS AS (c+1000) STORED;
DROP TABLE test_at_modify_generated;
-- test modify column AUTO_INCREMENT
CREATE TABLE test_at_modify_autoinc(
    a int,
    b int
);
INSERT INTO test_at_modify_autoinc VALUES(1,NULL);
INSERT INTO test_at_modify_autoinc VALUES(2,0);
ALTER TABLE test_at_modify_autoinc MODIFY b int2 AUTO_INCREMENT; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq" for serial column "test_at_modify_autoinc.b"
ERROR:  auto_increment column must be defined as a unique or primary key
ALTER TABLE test_at_modify_autoinc MODIFY b DECIMAL(4,2) AUTO_INCREMENT UNIQUE KEY; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq" for serial column "test_at_modify_autoinc.b"
ERROR:  The datatype of column 'b' does not support auto_increment
ALTER TABLE test_at_modify_autoinc MODIFY b serial AUTO_INCREMENT UNIQUE KEY; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change column to type 'serial'
ALTER TABLE test_at_modify_autoinc MODIFY b int2 AUTO_INCREMENT NULL UNIQUE KEY;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq" for serial column "test_at_modify_autoinc.b"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_modify_autoinc_b_key" for table "test_at_modify_autoinc"
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a | b 
---+---
 1 |  
 2 | 2
(2 rows)

INSERT INTO test_at_modify_autoinc VALUES(3,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a | b 
---+---
 1 |  
 2 | 2
 3 | 3
(3 rows)

ALTER TABLE test_at_modify_autoinc MODIFY COLUMN b int;
INSERT INTO test_at_modify_autoinc VALUES(4,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a | b 
---+---
 1 |  
 2 | 2
 3 | 3
 4 | 0
(4 rows)

ALTER TABLE test_at_modify_autoinc MODIFY b int AUTO_INCREMENT PRIMARY KEY, AUTO_INCREMENT=100;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq" for serial column "test_at_modify_autoinc.b"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_autoinc_pkey" for table "test_at_modify_autoinc"
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a |  b  
---+-----
 1 | 100
 2 |   2
 3 |   3
 4 | 101
(4 rows)

INSERT INTO test_at_modify_autoinc VALUES(5,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a |  b  
---+-----
 1 | 100
 2 |   2
 3 |   3
 4 | 101
 5 | 102
(5 rows)

ALTER TABLE test_at_modify_autoinc AUTO_INCREMENT=1000;
ALTER TABLE test_at_modify_autoinc MODIFY b int2 AUTO_INCREMENT;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq1" for serial column "test_at_modify_autoinc.b"
INSERT INTO test_at_modify_autoinc VALUES(6,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a |  b   
---+------
 1 |  100
 2 |    2
 3 |    3
 4 |  101
 5 |  102
 6 | 1000
(6 rows)

ALTER TABLE test_at_modify_autoinc ADD COLUMN c int AUTO_INCREMENT UNIQUE, MODIFY  b int2 AUTO_INCREMENT UNIQUE KEY; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_c_seq" for serial column "test_at_modify_autoinc.c"
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq" for serial column "test_at_modify_autoinc.b"
ERROR:  Incorrect table definition, there can be only one auto_increment column
ALTER TABLE test_at_modify_autoinc ADD COLUMN c int AUTO_INCREMENT UNIQUE; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_c_seq" for serial column "test_at_modify_autoinc.c"
ERROR:  Incorrect column definition, there can be only one auto_increment column
ALTER TABLE test_at_modify_autoinc MODIFY COLUMN b int;
ALTER TABLE test_at_modify_autoinc ADD COLUMN c int AUTO_INCREMENT UNIQUE;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_c_seq" for serial column "test_at_modify_autoinc.c"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_modify_autoinc_c_key" for table "test_at_modify_autoinc"
INSERT INTO test_at_modify_autoinc VALUES(7,0,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 1,2;
 a |  b   | c 
---+------+---
 1 |  100 | 1
 2 |    2 | 2
 3 |    3 | 3
 4 |  101 | 4
 5 |  102 | 5
 6 | 1000 | 6
 7 |    0 | 7
(7 rows)

ALTER TABLE test_at_modify_autoinc DROP COLUMN c , MODIFY b int2 AUTO_INCREMENT UNIQUE KEY FIRST;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_autoinc_b_seq" for serial column "test_at_modify_autoinc.b"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_modify_autoinc_b_key1" for table "test_at_modify_autoinc"
INSERT INTO test_at_modify_autoinc(a,b) VALUES(8,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 2,1;
  b   | a 
------+---
  100 | 1
    2 | 2
    3 | 3
  101 | 4
  102 | 5
 1000 | 6
 1001 | 7
 1002 | 8
(8 rows)

ALTER TABLE test_at_modify_autoinc MODIFY b float4; -- ALTER TYPE ONLY, KEEP AUTO_INCREMENT
INSERT INTO test_at_modify_autoinc(a,b) VALUES(9,0);
SELECT * FROM test_at_modify_autoinc ORDER BY 2,1;
  b   | a 
------+---
  100 | 1
    2 | 2
    3 | 3
  101 | 4
  102 | 5
 1000 | 6
 1001 | 7
 1002 | 8
 1003 | 9
(9 rows)

DROP TABLE test_at_modify_autoinc;
-- test generated column reference auto_increment column
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,0);
INSERT INTO test_at_modify_fa VALUES(21,22,0);
ALTER TABLE test_at_modify_fa MODIFY COLUMN c int AUTO_INCREMENT PRIMARY KEY, MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
ERROR:  generated column cannot refer to auto_increment column
ALTER TABLE test_at_modify_fa MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED, MODIFY COLUMN c int AUTO_INCREMENT PRIMARY KEY; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
ERROR:  generated column cannot refer to auto_increment column
ALTER TABLE test_at_modify_fa MODIFY COLUMN c bigint AUTO_INCREMENT PRIMARY KEY, MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
ERROR:  generated column cannot refer to auto_increment column
ALTER TABLE test_at_modify_fa MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED, MODIFY COLUMN c bigint AUTO_INCREMENT PRIMARY KEY; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
ERROR:  generated column cannot refer to auto_increment column
DROP TABLE test_at_modify_fa;
-- test modify column depended by other objects
CREATE TABLE test_at_modify_depend(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_modify_depend VALUES(1,1);
INSERT INTO test_at_modify_depend VALUES(2,2);
INSERT INTO test_at_modify_depend VALUES(3,3);
-- --PROCEDURE contains column
CREATE OR REPLACE PROCEDURE test_at_modify_proc(IN p_in int)
    AS
    BEGIN
        INSERT INTO test_at_modify_depend(a,b) VALUES(p_in, p_in);
    END;
/
ALTER TABLE test_at_modify_depend MODIFY b varchar(8) NOT NULL;
CALL test_at_modify_proc(2);
 test_at_modify_proc 
---------------------
 
(1 row)

DROP PROCEDURE test_at_modify_proc;
-- --TRIGGER contains and depends column
CREATE OR REPLACE FUNCTION tg_bf_test_at_modify_func() RETURNS TRIGGER AS
$$
    DECLARE
    BEGIN
        UPDATE test_at_modify_depend SET b = NULL WHERE a < NEW.a;
        RETURN NEW;
    END
$$ LANGUAGE PLPGSQL;
CREATE TRIGGER tg_bf_test_at_modify
    AFTER UPDATE ON test_at_modify_depend
    FOR EACH ROW WHEN ( NEW.b IS NULL AND OLD.b = OLD.a)
    EXECUTE PROCEDURE tg_bf_test_at_modify_func();
ALTER TABLE test_at_modify_depend MODIFY b int NULL DEFAULT 0;
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a | b 
---+---
 1 | 1
 2 | 2
 2 | 2
 3 | 3
(4 rows)

UPDATE test_at_modify_depend SET b = NULL WHERE a = 2;
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a | b 
---+---
 1 |  
 2 |  
 2 |  
 3 | 3
(4 rows)

DROP TRIGGER tg_bf_test_at_modify ON test_at_modify_depend;
-- --TRIGGER contains but does not depend column
CREATE TRIGGER tg_bf_test_at_modify
    BEFORE INSERT ON test_at_modify_depend
    FOR EACH ROW
    EXECUTE PROCEDURE tg_bf_test_at_modify_func();
ALTER TABLE test_at_modify_depend MODIFY b varchar(8) NULL;
INSERT INTO test_at_modify_depend VALUES (4, 4);
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a | b 
---+---
 1 | 
 2 | 
 2 | 
 3 | 
 4 | 4
(5 rows)

DROP TRIGGER tg_bf_test_at_modify ON test_at_modify_depend;
DROP PROCEDURE tg_bf_test_at_modify_func;
-- --VIEW depends column
CREATE VIEW test_at_modify_view AS SELECT b FROM test_at_modify_depend;
ALTER TABLE test_at_modify_depend MODIFY b bigint NULL; -- ERROR
ERROR:  cannot change data type of view column "b" from character varying(8) to bigint
ALTER TABLE test_at_modify_depend MODIFY b int NULL; -- ERROR
ERROR:  cannot change data type of view column "b" from character varying(8) to integer
ALTER TABLE test_at_modify_depend MODIFY b varchar(8) NULL;
SELECT * FROM test_at_modify_view ORDER BY 1;
 b 
---
 4
 
 
 
 
(5 rows)

DROP VIEW test_at_modify_view;
CREATE VIEW test_at_modify_view AS SELECT a FROM test_at_modify_depend where b > 0;
CREATE VIEW test_at_modify_view1 AS SELECT * FROM test_at_modify_view;
ALTER TABLE test_at_modify_depend MODIFY b bigint NULL GENERATED ALWAYS AS (a+1);
ALTER TABLE test_at_modify_depend MODIFY b varchar(8) NULL;
ALTER TABLE test_at_modify_depend MODIFY b int NULL;
DROP VIEW test_at_modify_view1;
DROP VIEW test_at_modify_view;
CREATE materialized VIEW test_at_modify_view AS SELECT b FROM test_at_modify_depend;
ALTER TABLE test_at_modify_depend MODIFY COLUMN b bigint not null; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change a column used by materialized view or rule is not supported
DROP MATERIALIZED VIEW test_at_modify_view;
-- --TABLE reference column.
DELETE FROM test_at_modify_depend;
ALTER TABLE test_at_modify_depend MODIFY b INT PRIMARY KEY;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_depend_pkey" for table "test_at_modify_depend"
CREATE TABLE test_at_modify_ref(
    a int,
    b int,
    FOREIGN KEY (b) REFERENCES test_at_modify_depend(b) ON DELETE SET NULL
);
ALTER TABLE test_at_modify_depend MODIFY COLUMN b varchar(8);
INSERT INTO test_at_modify_ref VALUES(0,0); -- ERROR
ERROR:  insert or update on table "test_at_modify_ref" violates foreign key constraint "test_at_modify_ref_b_fkey"
DETAIL:  Key (b)=(0) is not present in table "test_at_modify_depend".
INSERT INTO test_at_modify_depend VALUES(0,0);
INSERT INTO test_at_modify_ref VALUES(0,0);
ALTER TABLE test_at_modify_ref MODIFY COLUMN b varchar(8) GENERATED ALWAYS AS (a+1) STORED; -- ERROR
ERROR:  invalid ON DELETE action for foreign key constraint containing generated column
ALTER TABLE test_at_modify_ref MODIFY COLUMN b varchar(8);
\d+ test_at_modify_ref
                      Table "atbdb_schema.test_at_modify_ref"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) |           | extended |              | 
Foreign-key constraints:
    "test_at_modify_ref_b_fkey" FOREIGN KEY (b) REFERENCES test_at_modify_depend(b) ON DELETE SET NULL
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE test_at_modify_ref;
-- --TABLE reference self column.
CREATE TABLE test_at_modify_ref(
    a int PRIMARY KEY,
    b int,
    FOREIGN KEY (b) REFERENCES test_at_modify_ref(a) ON DELETE SET NULL
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_ref_pkey" for table "test_at_modify_ref"
INSERT INTO test_at_modify_ref VALUES(0,0);
ALTER TABLE test_at_modify_ref MODIFY COLUMN b varchar(8) GENERATED ALWAYS AS (a+1) STORED; -- ERROR
ERROR:  invalid ON DELETE action for foreign key constraint containing generated column
ALTER TABLE test_at_modify_ref MODIFY COLUMN b varchar(8);
ALTER TABLE test_at_modify_ref MODIFY COLUMN a varchar(8);
INSERT INTO test_at_modify_ref VALUES('a','a');
DROP TABLE test_at_modify_ref;
-- --RULE reference column.
CREATE RULE test_at_modify_rule AS ON INSERT TO test_at_modify_depend WHERE (b is null) DO INSTEAD UPDATE test_at_modify_depend SET b=0;
ALTER TABLE test_at_modify_depend MODIFY COLUMN b int not null; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change a column used by materialized view or rule is not supported
DROP RULE test_at_modify_rule ON test_at_modify_depend;
-- --RLSPOLICY reference column.
DROP TABLE test_at_modify_depend;
CREATE ROLE at_modify_role PASSWORD 'Gauss@123';
CREATE TABLE test_at_modify_depend(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_modify_depend VALUES(0,0);
GRANT USAGE ON SCHEMA atbdb_schema TO at_modify_role;
GRANT SELECT ON test_at_modify_depend TO at_modify_role;
ALTER TABLE test_at_modify_depend ENABLE ROW LEVEL SECURITY;
CREATE ROW LEVEL SECURITY POLICY test_at_modify_rls ON test_at_modify_depend AS RESTRICTIVE FOR SELECT TO at_modify_role USING(b >= 20);
ALTER TABLE test_at_modify_depend MODIFY COLUMN b int not null;
INSERT INTO test_at_modify_depend VALUES(21,21);
SET ROLE at_modify_role PASSWORD 'Gauss@123';
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a  | b  
----+----
 21 | 21
(1 row)

RESET ROLE;
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a  | b  
----+----
  0 |  0
 21 | 21
(2 rows)

ALTER TABLE test_at_modify_depend MODIFY COLUMN b bool not null;
ALTER TABLE test_at_modify_depend MODIFY COLUMN b int not null;
INSERT INTO test_at_modify_depend VALUES(22,22);
SET ROLE at_modify_role PASSWORD 'Gauss@123';
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a  | b  
----+----
 22 | 22
(1 row)

RESET ROLE;
SELECT * FROM test_at_modify_depend ORDER BY 1,2;
 a  | b  
----+----
  0 |  0
 21 |  1
 22 | 22
(3 rows)

DROP TABLE test_at_modify_depend;
REVOKE ALL PRIVILEGES ON SCHEMA atbdb_schema FROM at_modify_role;
DROP ROLE at_modify_role;
-- ------------------------------------------------------ test ALTER TABLE CHANGE
-- test change column syntax
CREATE TABLE test_at_change_syntax(
    a int,
    b int NOT NULL
);
ALTER TABLE test_at_change_syntax CHANGE b b1 int INVISIBLE; -- ERROR
ERROR:  syntax error at or near "INVISIBLE"
LINE 1: ALTER TABLE test_at_change_syntax CHANGE b b1 int INVISIBLE;
                                                          ^
ALTER TABLE test_at_change_syntax CHANGE b b1 int CHECK (b < 100) NOT ENFORCED; -- ERROR
ERROR:  syntax error at or near "ENFORCED"
LINE 1: ..._change_syntax CHANGE b b1 int CHECK (b < 100) NOT ENFORCED;
                                                              ^
ALTER TABLE test_at_change_syntax CHANGE b b1 int GENERATED ALWAYS AS (a+1) VIRTUAL; -- ERROR
ERROR:  syntax error at or near "VIRTUAL"
LINE 1: ...ge_syntax CHANGE b b1 int GENERATED ALWAYS AS (a+1) VIRTUAL;
                                                               ^
ALTER TABLE test_at_change_syntax CHANGE b b1 int KEY; -- ERROR
ERROR:  syntax error at or near "KEY"
LINE 1: ALTER TABLE test_at_change_syntax CHANGE b b1 int KEY;
                                                          ^
ALTER TABLE test_at_change_syntax CHANGE b b1 int encrypted with (column_encryption_key = ImgCEK, encryption_type = DETERMINISTIC); -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change column to encrypted column is not supported
ALTER TABLE test_at_change_syntax CHANGE b a int UNIQUE KEY; -- ERROR
ERROR:  column "a" of relation "test_at_change_syntax" already exists
ALTER TABLE test_at_change_syntax CHANGE COLUMN b a int NOT NULL,CHANGE COLUMN a b int; -- ERROR
ERROR:  column "a" of relation "test_at_change_syntax" already exists
ALTER TABLE test_at_change_syntax CHANGE b b1 int UNIQUE KEY;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_syntax_b1_key" for table "test_at_change_syntax"
\d+ test_at_change_syntax;
             Table "atbdb_schema.test_at_change_syntax"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b1     | integer |           | plain   |              | 
Indexes:
    "test_at_change_syntax_b1_key" UNIQUE CONSTRAINT, btree (b1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change_syntax CHANGE COLUMN b1 b int PRIMARY KEY;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_change_syntax_pkey" for table "test_at_change_syntax"
\d+ test_at_change_syntax;
             Table "atbdb_schema.test_at_change_syntax"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer | not null  | plain   |              | 
Indexes:
    "test_at_change_syntax_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default
    "test_at_change_syntax_b1_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change_syntax CHANGE COLUMN b b123456789012345678901234567890123456789012345678901234567890123 int UNIQUE KEY;
NOTICE:  identifier "b123456789012345678901234567890123456789012345678901234567890123" will be truncated to "b12345678901234567890123456789012345678901234567890123456789012"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_syntax_b123456789012345678901234567890123456_key" for table "test_at_change_syntax"
\d+ test_at_change_syntax;
                                          Table "atbdb_schema.test_at_change_syntax"
                             Column                              |  Type   | Modifiers | Storage | Stats target | Description 
-----------------------------------------------------------------+---------+-----------+---------+--------------+-------------
 a                                                               | integer |           | plain   |              | 
 b12345678901234567890123456789012345678901234567890123456789012 | integer | not null  | plain   |              | 
Indexes:
    "test_at_change_syntax_pkey" PRIMARY KEY, btree (b12345678901234567890123456789012345678901234567890123456789012) TABLESPACE pg_default
    "test_at_change_syntax_b123456789012345678901234567890123456_key" UNIQUE CONSTRAINT, btree (b12345678901234567890123456789012345678901234567890123456789012) TABLESPACE pg_default
    "test_at_change_syntax_b1_key" UNIQUE CONSTRAINT, btree (b12345678901234567890123456789012345678901234567890123456789012) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE test_at_change_syntax;
-- test modify syntax with on update and comment
CREATE TABLE at_change_comment(col1 timestamp not null default current_timestamp comment 'last changed time');
\d+ at_change_comment
                                         Table "atbdb_schema.at_change_comment"
 Column |            Type             |             Modifiers              | Storage | Stats target |    Description    
--------+-----------------------------+------------------------------------+---------+--------------+-------------------
 col1   | timestamp without time zone | not null default pg_systimestamp() | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE COLUMN col1 col2 timestamp not null comment 'last changed time' default current_timestamp on update current_timestamp; -- ERROR, comment clause must be after column constraints
ERROR:  syntax error at or near "default"
LINE 1: ...l2 timestamp not null comment 'last changed time' default cu...
                                                             ^
ALTER TABLE at_change_comment CHANGE COLUMN col1 col2 timestamp not null default current_timestamp on update current_timestamp comment 'last changed time';
\d+ at_change_comment
                                                       Table "atbdb_schema.at_change_comment"
 Column |            Type             |                           Modifiers                            | Storage | Stats target |    Description    
--------+-----------------------------+----------------------------------------------------------------+---------+--------------+-------------------
 col2   | timestamp without time zone | not null default pg_systimestamp() on update pg_systimestamp() | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE col2 col1 timestamp on update current_timestamp;
\d+ at_change_comment
                                  Table "atbdb_schema.at_change_comment"
 Column |            Type             |          Modifiers          | Storage | Stats target | Description 
--------+-----------------------------+-----------------------------+---------+--------------+-------------
 col1   | timestamp without time zone | on update pg_systimestamp() | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE col1 col2 timestamp comment 'last changed time';
\d+ at_change_comment
                            Table "atbdb_schema.at_change_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description    
--------+-----------------------------+-----------+---------+--------------+-------------------
 col2   | timestamp without time zone |           | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE COLUMN col2 col1 timestamp on update current_timestamp;
\d+ at_change_comment
                                  Table "atbdb_schema.at_change_comment"
 Column |            Type             |          Modifiers          | Storage | Stats target | Description 
--------+-----------------------------+-----------------------------+---------+--------------+-------------
 col1   | timestamp without time zone | on update pg_systimestamp() | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE COLUMN col1 col2 timestamp comment 'last changed time';
\d+ at_change_comment
                            Table "atbdb_schema.at_change_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description    
--------+-----------------------------+-----------+---------+--------------+-------------------
 col2   | timestamp without time zone |           | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment ADD COLUMN id1 int FIRST, CHANGE COLUMN col2 col1 timestamp on update current_timestamp;
\d+ at_change_comment
                                  Table "atbdb_schema.at_change_comment"
 Column |            Type             |          Modifiers          | Storage | Stats target | Description 
--------+-----------------------------+-----------------------------+---------+--------------+-------------
 id1    | integer                     |                             | plain   |              | 
 col1   | timestamp without time zone | on update pg_systimestamp() | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE COLUMN col1 col2 timestamp AFTER id1 comment 'last changed time'; -- ERROR
ERROR:  syntax error at or near "comment"
LINE 1: ...mment CHANGE COLUMN col1 col2 timestamp AFTER id1 comment 'l...
                                                             ^
ALTER TABLE at_change_comment ADD COLUMN id2 int AFTER id1, CHANGE COLUMN col1 col2 timestamp comment 'last changed time' AFTER id1;
\d+ at_change_comment
                            Table "atbdb_schema.at_change_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description    
--------+-----------------------------+-----------+---------+--------------+-------------------
 id1    | integer                     |           | plain   |              | 
 id2    | integer                     |           | plain   |              | 
 col2   | timestamp without time zone |           | plain   |              | last changed time
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE at_change_comment CHANGE COLUMN col2 col1 timestamp comment 'last changed time1' comment 'last changed time2' comment 'last changed time3';
\d+ at_change_comment
                             Table "atbdb_schema.at_change_comment"
 Column |            Type             | Modifiers | Storage | Stats target |    Description     
--------+-----------------------------+-----------+---------+--------------+--------------------
 id1    | integer                     |           | plain   |              | 
 id2    | integer                     |           | plain   |              | 
 col1   | timestamp without time zone |           | plain   |              | last changed time3
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE IF EXISTS at_change_comment;
-- test change column without data
CREATE TABLE test_at_change(
    a int,
    b int NOT NULL
);
ALTER TABLE test_at_change CHANGE b b1 varchar(8) NULL;
\d+ test_at_change;
                        Table "atbdb_schema.test_at_change"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b1     | character varying(8) |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b1 b varchar(8) DEFAULT '0';
\d+ test_at_change;
                                  Table "atbdb_schema.test_at_change"
 Column |         Type         |           Modifiers            | Storage  | Stats target | Description 
--------+----------------------+--------------------------------+----------+--------------+-------------
 a      | integer              |                                | plain    |              | 
 b      | character varying(8) | default '0'::character varying | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b b1 int AUTO_INCREMENT PRIMARY KEY;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_b1_seq" for serial column "test_at_change.b1"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_change_pkey" for table "test_at_change"
\d+ test_at_change;
                        Table "atbdb_schema.test_at_change"
 Column |  Type   |        Modifiers        | Storage | Stats target | Description 
--------+---------+-------------------------+---------+--------------+-------------
 a      | integer |                         | plain   |              | 
 b1     | integer | not null AUTO_INCREMENT | plain   |              | 
Indexes:
    "test_at_change_pkey" PRIMARY KEY, btree (b1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b1 b varchar(8) UNIQUE;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_b_key" for table "test_at_change"
\d+ test_at_change;
                        Table "atbdb_schema.test_at_change"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b      | character varying(8) | not null  | extended |              | 
Indexes:
    "test_at_change_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default
    "test_at_change_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b b1 varchar(8) CHECK (b1 < 'a');
\d+ test_at_change;
                        Table "atbdb_schema.test_at_change"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b1     | character varying(8) | not null  | extended |              | 
Indexes:
    "test_at_change_pkey" PRIMARY KEY, btree (b1) TABLESPACE pg_default
    "test_at_change_b_key" UNIQUE CONSTRAINT, btree (b1) TABLESPACE pg_default
Check constraints:
    "test_at_change_b1_check" CHECK (b1::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b1 b varchar(8) COLLATE "POSIX";
\d+ test_at_change;
                              Table "atbdb_schema.test_at_change"
 Column |         Type         |       Modifiers        | Storage  | Stats target | Description 
--------+----------------------+------------------------+----------+--------------+-------------
 a      | integer              |                        | plain    |              | 
 b      | character varying(8) | collate POSIX not null | extended |              | 
Indexes:
    "test_at_change_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default
    "test_at_change_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Check constraints:
    "test_at_change_b1_check" CHECK (b::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b b1 varchar(8) GENERATED ALWAYS AS (a+1) STORED;
\d+ test_at_change;
                                          Table "atbdb_schema.test_at_change"
 Column |         Type         |                   Modifiers                   | Storage  | Stats target | Description 
--------+----------------------+-----------------------------------------------+----------+--------------+-------------
 a      | integer              |                                               | plain    |              | 
 b1     | character varying(8) | not null generated always as ((a + 1)) stored | extended |              | 
Indexes:
    "test_at_change_pkey" PRIMARY KEY, btree (b1) TABLESPACE pg_default
    "test_at_change_b_key" UNIQUE CONSTRAINT, btree (b1) TABLESPACE pg_default
Check constraints:
    "test_at_change_b1_check" CHECK (b1::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change CHANGE b1 b int NOT NULL;
\d+ test_at_change;
                 Table "atbdb_schema.test_at_change"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer | not null  | plain   |              | 
Indexes:
    "test_at_change_pkey" PRIMARY KEY, btree (b) TABLESPACE pg_default
    "test_at_change_b_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Check constraints:
    "test_at_change_b1_check" CHECK (b::text < 'a'::text)
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_tabledef('test_at_change'::regclass);
                                       pg_get_tabledef                                       
---------------------------------------------------------------------------------------------
 SET search_path = atbdb_schema;                                                            +
 CREATE TABLE test_at_change (                                                              +
     a integer,                                                                             +
     b integer NOT NULL,                                                                    +
     CONSTRAINT test_at_change_b1_check CHECK (((b)::text < 'a'::text))                     +
 )                                                                                          +
 WITH (orientation=row, compression=no);                                                    +
 ALTER TABLE test_at_change ADD CONSTRAINT test_at_change_b_key UNIQUE USING btree (b);     +
 ALTER TABLE test_at_change ADD CONSTRAINT test_at_change_pkey PRIMARY KEY USING btree  (b);
(1 row)

INSERT INTO test_at_change VALUES(1,1);
DROP TABLE test_at_change;
-- test change column datatype
CREATE TABLE test_at_change_type(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_change_type VALUES(1,1);
INSERT INTO test_at_change_type VALUES(2,2);
INSERT INTO test_at_change_type VALUES(3,3);
ALTER TABLE test_at_change_type CHANGE b b1 varchar(8);
SELECT * FROM test_at_change_type where b1 = '3';
 a | b1 
---+----
 3 | 3
(1 row)

ALTER TABLE test_at_change_type CHANGE b1 b DATE; -- ERROR
ERROR:  invalid input syntax for type date: "1"
ALTER TABLE test_at_change_type CHANGE b1 b RAW;
SELECT * FROM test_at_change_type ORDER BY 1,2;
 a | b  
---+----
 1 | 01
 2 | 02
 3 | 03
(3 rows)

DROP TABLE test_at_change_type;
CREATE TABLE test_at_change_type(
    a int,
    b serial NOT NULL
);
NOTICE:  CREATE TABLE will create implicit sequence "test_at_change_type_b_seq" for serial column "test_at_change_type.b"
INSERT INTO test_at_change_type VALUES(1,1);
INSERT INTO test_at_change_type VALUES(2,2);
INSERT INTO test_at_change_type VALUES(3,3);
ALTER TABLE test_at_change_type CHANGE b b1 int;
ALTER TABLE test_at_change_type CHANGE b1 b serial; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change column to type 'serial'
ALTER TABLE test_at_change_type CHANGE b1 b DECIMAL(4,2);
SELECT * FROM test_at_change_type where b = 3;
 a |  b   
---+------
 3 | 3.00
(1 row)

ALTER TABLE test_at_change_type CHANGE b b1 BOOLEAN;
SELECT * FROM test_at_change_type ORDER BY 1,2;
 a | b1 
---+----
 1 | t
 2 | t
 3 | t
(3 rows)

DROP TABLE test_at_change_type;
CREATE TABLE test_at_change_type(
    a int,
    b text
);
INSERT INTO test_at_change_type VALUES(1,'beijing');
INSERT INTO test_at_change_type VALUES(2,'shanghai');
INSERT INTO test_at_change_type VALUES(3,'guangzhou');
ALTER TABLE test_at_change_type CHANGE b b1 SET('beijing','shanghai','nanjing','wuhan'); -- ERROR
NOTICE:  ALTER TABLE will create implicit set "test_at_change_type_b1_set" for column "test_at_change_type.b1"
ERROR:  invalid input value for set test_at_change_type_b1_set: 'guangzhou'
ALTER TABLE test_at_change_type CHANGE b b1 SET('beijing','shanghai','nanjing','guangzhou');
NOTICE:  ALTER TABLE will create implicit set "test_at_change_type_b1_set" for column "test_at_change_type.b1"
ALTER TABLE test_at_change_type CHANGE b1 b SET('beijing','shanghai','guangzhou','wuhan'); -- ERROR
ERROR:  can not alter column type to another set
select pg_get_tabledef('test_at_change_type'::regclass);
                      pg_get_tabledef                      
-----------------------------------------------------------
 SET search_path = atbdb_schema;                          +
 CREATE TABLE test_at_change_type (                       +
     a integer,                                           +
     b1 SET('beijing', 'shanghai', 'nanjing', 'guangzhou')+
 )                                                        +
 WITH (orientation=row, compression=no);
(1 row)

DROP TABLE test_at_change_type;
CREATE TABLE test_at_change_type(
    a int,
    b varchar(32)
);
INSERT INTO test_at_change_type VALUES(1,'2022-11-22 12:00:00');
INSERT INTO test_at_change_type VALUES(2,'2022-11-23 12:00:00');
INSERT INTO test_at_change_type VALUES(3,'2022-11-24 12:00:00');
ALTER TABLE test_at_change_type CHANGE b b1 varchar(10); -- ERROR
ERROR:  value too long for type character varying(10)
ALTER TABLE test_at_change_type CHANGE b b1 DATE;
SELECT * FROM test_at_change_type ORDER BY 1,2;
 a |     b1     
---+------------
 1 | 11-22-2022
 2 | 11-23-2022
 3 | 11-24-2022
(3 rows)

DROP TABLE test_at_change_type;
-- test change column constraint
CREATE TABLE test_at_change_constr(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_change_constr VALUES(1,1);
INSERT INTO test_at_change_constr VALUES(2,2);
INSERT INTO test_at_change_constr VALUES(3,3);
ALTER TABLE test_at_change_constr CHANGE b b1 varchar(8) NOT NULL NULL; -- ERROR
ERROR:  conflicting NULL/NOT NULL declarations for column "b1" of table "test_at_change_constr"
LINE 1: ... test_at_change_constr CHANGE b b1 varchar(8) NOT NULL NULL;
                                                                  ^
ALTER TABLE test_at_change_constr CHANGE b b1 varchar(8) UNIQUE KEY NULL;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_constr_b1_key" for table "test_at_change_constr"
INSERT INTO test_at_change_constr VALUES(3,3); -- ERROR
ERROR:  duplicate key value violates unique constraint "test_at_change_constr_b1_key"
DETAIL:  Key (b1)=(3) already exists.
INSERT INTO test_at_change_constr VALUES(4,NULL);
ALTER TABLE test_at_change_constr CHANGE b1 b int NULL PRIMARY KEY; -- ERROR
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_change_constr_pkey" for table "test_at_change_constr"
ERROR:  column "b" contains null values
DELETE FROM test_at_change_constr WHERE b1 IS NULL;
ALTER TABLE test_at_change_constr CHANGE b1 b int NULL PRIMARY KEY;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_change_constr_pkey" for table "test_at_change_constr"
INSERT INTO test_at_change_constr VALUES(4,NULL); -- ERROR
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (4, null).
ALTER TABLE test_at_change_constr CHANGE b b1 varchar(8) CONSTRAINT t_at_m_check CHECK (b1 < 3); -- ERROR
ERROR:  check constraint "t_at_m_check" is violated by some row
ALTER TABLE test_at_change_constr CHANGE b b1 varchar(8) CONSTRAINT t_at_m_check CHECK (b1 < 5);
ALTER TABLE test_at_change_constr CHANGE b1 b varchar(8) CONSTRAINT t_at_m_check CHECK (b = a); -- ERROR
ERROR:  constraint "t_at_m_check" for relation "test_at_change_constr" already exists
ALTER TABLE test_at_change_constr CHANGE b1 b varchar(8) CONSTRAINT t_at_m_check_1 CHECK (b = a);
INSERT INTO test_at_change_constr VALUES(4,4);
INSERT INTO test_at_change_constr VALUES(5,5); -- ERROR
ERROR:  new row for relation "test_at_change_constr" violates check constraint "t_at_m_check"
DETAIL:  N/A
INSERT INTO test_at_change_constr VALUES(6,'a'); -- ERROR
ERROR:  new row for relation "test_at_change_constr" violates check constraint "t_at_m_check_1"
DETAIL:  N/A
INSERT INTO test_at_change_constr VALUES(0,'a');
ALTER TABLE test_at_change_constr CHANGE b b1 int NOT NULL PRIMARY KEY; -- ERROR
ERROR:  multiple primary keys for table "test_at_change_constr" are not allowed
ALTER TABLE test_at_change_constr CHANGE b b1 int NOT NULL;
INSERT INTO test_at_change_constr VALUES(5,5); -- ERROR
ERROR:  new row for relation "test_at_change_constr" violates check constraint "t_at_m_check"
DETAIL:  N/A
SELECT b1 FROM test_at_change_constr ORDER BY 1;
 b1 
----
  0
  1
  2
  3
  4
(5 rows)

select pg_get_tabledef('test_at_change_constr'::regclass);
                                              pg_get_tabledef                                               
------------------------------------------------------------------------------------------------------------
 SET search_path = atbdb_schema;                                                                           +
 CREATE TABLE test_at_change_constr (                                                                      +
     a integer,                                                                                            +
     b1 integer NOT NULL,                                                                                  +
     CONSTRAINT t_at_m_check_1 CHECK (((b1)::bigint = a)),                                                 +
     CONSTRAINT t_at_m_check CHECK (((b1)::bigint < 5))                                                    +
 )                                                                                                         +
 WITH (orientation=row, compression=no);                                                                   +
 ALTER TABLE test_at_change_constr ADD CONSTRAINT test_at_change_constr_b1_key UNIQUE USING btree (b1);    +
 ALTER TABLE test_at_change_constr ADD CONSTRAINT test_at_change_constr_pkey PRIMARY KEY USING btree  (b1);
(1 row)

ALTER TABLE test_at_change_constr CHANGE b1 b int NOT NULL REFERENCES test_at_ref (a); -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change column REFERENCES constraint is not supported
DROP TABLE test_at_change_constr;
-- test change column default
CREATE TABLE test_at_change_default(
    a int,
    b int DEFAULT NULL
);
INSERT INTO test_at_change_default VALUES(1,1);
INSERT INTO test_at_change_default VALUES(2,2);
INSERT INTO test_at_change_default VALUES(3,3);
ALTER TABLE test_at_change_default CHANGE b b1 bigint DEFAULT (a+1); -- ERROR
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
ALTER TABLE test_at_change_default CHANGE b b1 bigint DEFAULT NULL;
\d+ test_at_change_default;
             Table "atbdb_schema.test_at_change_default"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b1     | bigint  |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change_default CHANGE b1 b varchar(8) DEFAULT 'a' GENERATED ALWAYS AS (a+1) STORED; -- ERROR
ERROR:  both default and generation expression specified for column "b" of table "test_at_change_default"
LINE 1: ...change_default CHANGE b1 b varchar(8) DEFAULT 'a' GENERATED ...
                                                             ^
ALTER TABLE test_at_change_default CHANGE b1 b varchar(8) DEFAULT 'a';
\d+ test_at_change_default;
                              Table "atbdb_schema.test_at_change_default"
 Column |         Type         |           Modifiers            | Storage  | Stats target | Description 
--------+----------------------+--------------------------------+----------+--------------+-------------
 a      | integer              |                                | plain    |              | 
 b      | character varying(8) | default 'a'::character varying | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

INSERT INTO test_at_change_default VALUES(0,DEFAULT);
SELECT b FROM test_at_change_default ORDER BY 1;
 b 
---
 1
 2
 3
 a
(4 rows)

ALTER TABLE test_at_change_default CHANGE b b1 int DEFAULT 4 AUTO_INCREMENT; -- ERROR
ERROR:  multiple default values specified for column "b1" of table "test_at_change_default"
LINE 1: ... test_at_change_default CHANGE b b1 int DEFAULT 4 AUTO_INCRE...
                                                             ^
ALTER TABLE test_at_change_default CHANGE b b1 int DEFAULT 4;
INSERT INTO test_at_change_default VALUES(4,DEFAULT);
SELECT b1 FROM test_at_change_default ORDER BY 1;
 b1 
----
  0
  1
  2
  3
  4
(5 rows)

ALTER TABLE test_at_change_default CHANGE b1 b varchar(8) GENERATED ALWAYS AS (a+1) STORED;
SELECT a,b FROM test_at_change_default ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 1 | 2
 2 | 3
 3 | 4
 4 | 5
(5 rows)

ALTER TABLE test_at_change_default CHANGE a a1 varchar(8) DEFAULT 'a';
INSERT INTO test_at_change_default VALUES(DEFAULT,DEFAULT);
SELECT * FROM test_at_change_default ORDER BY 1,2;
 a1 | b 
----+---
 0  | 1
 1  | 2
 2  | 3
 3  | 4
 4  | 5
 a  | 1
(6 rows)

\d+ test_at_change_default;
                                       Table "atbdb_schema.test_at_change_default"
 Column |         Type         |                    Modifiers                    | Storage  | Stats target | Description 
--------+----------------------+-------------------------------------------------+----------+--------------+-------------
 a1     | character varying(8) | default 'a'::character varying                  | extended |              | 
 b      | character varying(8) | generated always as (((a1)::bigint + 1)) stored | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE test_at_change_default;
-- test change column depended by generated column
CREATE TABLE test_at_change_generated(
    a int,
    b varchar(32),
    c varchar(32) GENERATED ALWAYS AS (b) STORED
);
INSERT INTO test_at_change_generated(a,b) VALUES(1,'2022-11-22 12:00:00');
INSERT INTO test_at_change_generated(a,b) VALUES(2,'2022-11-23 12:00:00');
INSERT INTO test_at_change_generated(a,b) VALUES(3,'2022-11-24 12:00:00');
SELECT * FROM test_at_change_generated ORDER BY 1,2;
 a |          b          |          c          
---+---------------------+---------------------
 1 | 2022-11-22 12:00:00 | 2022-11-22 12:00:00
 2 | 2022-11-23 12:00:00 | 2022-11-23 12:00:00
 3 | 2022-11-24 12:00:00 | 2022-11-24 12:00:00
(3 rows)

ALTER TABLE test_at_change_generated CHANGE COLUMN b b1 DATE;
SELECT * FROM test_at_change_generated ORDER BY 1,2;
 a |     b1     |     c      
---+------------+------------
 1 | 11-22-2022 | 11-22-2022
 2 | 11-23-2022 | 11-23-2022
 3 | 11-24-2022 | 11-24-2022
(3 rows)

\d+ test_at_change_generated
                              Table "atbdb_schema.test_at_change_generated"
 Column |         Type          |            Modifiers            | Storage  | Stats target | Description 
--------+-----------------------+---------------------------------+----------+--------------+-------------
 a      | integer               |                                 | plain    |              | 
 b1     | date                  |                                 | plain    |              | 
 c      | character varying(32) | generated always as (b1) stored | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test_at_change_generated CHANGE COLUMN b1 b varchar(32) AFTER c;
SELECT * FROM test_at_change_generated ORDER BY 1,2;
 a |     c      |     b      
---+------------+------------
 1 | 11-22-2022 | 11-22-2022
 2 | 11-23-2022 | 11-23-2022
 3 | 11-24-2022 | 11-24-2022
(3 rows)

DROP TABLE test_at_change_generated;
CREATE TABLE test_at_change_generated(
    a int,
    b int GENERATED ALWAYS AS (a+1) STORED
);
INSERT INTO test_at_change_generated(a,b) VALUES(-1,DEFAULT);
INSERT INTO test_at_change_generated(a,b) VALUES(0,DEFAULT);
INSERT INTO test_at_change_generated(a,b) VALUES(1,DEFAULT);
ALTER TABLE test_at_change_generated CHANGE COLUMN a a1 bool;
ALTER TABLE test_at_change_generated CHANGE COLUMN a1 a int;
INSERT INTO test_at_change_generated(a,b) VALUES(100,DEFAULT);
SELECT * FROM test_at_change_generated ORDER BY 1,2;
  a  |  b  
-----+-----
   0 |   1
   1 |   2
   1 |   2
 100 | 101
(4 rows)

ALTER TABLE test_at_change_generated CHANGE COLUMN a a1 bool, MODIFY COLUMN b varchar(32);
\d test_at_change_generated
Table "atbdb_schema.test_at_change_generated"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 a1     | boolean               | 
 b      | character varying(32) | 

SELECT * FROM test_at_change_generated ORDER BY 1,2;
 a1 |  b  
----+-----
 f  | 1
 t  | 101
 t  | 2
 t  | 2
(4 rows)

ALTER TABLE test_at_change_generated MODIFY COLUMN b int GENERATED ALWAYS AS (a+1) STORED, CHANGE COLUMN a1 a int;
\d test_at_change_generated
           Table "atbdb_schema.test_at_change_generated"
 Column |  Type   |                   Modifiers                    
--------+---------+------------------------------------------------
 a      | integer | 
 b      | integer | generated always as (((a)::bigint + 1)) stored

SELECT * FROM test_at_change_generated ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 1 | 2
 1 | 2
 1 | 2
(4 rows)

INSERT INTO test_at_change_generated(a,b) VALUES(100,DEFAULT);
SELECT * FROM test_at_change_generated ORDER BY 1,2;
  a  |  b  
-----+-----
   0 |   1
   1 |   2
   1 |   2
   1 |   2
 100 | 101
(5 rows)

ALTER TABLE test_at_change_generated MODIFY COLUMN b bool GENERATED ALWAYS AS (a) STORED;
\d test_at_change_generated
   Table "atbdb_schema.test_at_change_generated"
 Column |  Type   |           Modifiers            
--------+---------+--------------------------------
 a      | integer | 
 b      | boolean | generated always as (a) stored

SELECT * FROM test_at_change_generated ORDER BY 1,2;
  a  | b 
-----+---
   0 | f
   1 | t
   1 | t
   1 | t
 100 | t
(5 rows)

ALTER TABLE test_at_change_generated CHANGE COLUMN a a1 bool;
\d test_at_change_generated
   Table "atbdb_schema.test_at_change_generated"
 Column |  Type   |            Modifiers            
--------+---------+---------------------------------
 a1     | boolean | 
 b      | boolean | generated always as (a1) stored

SELECT * FROM test_at_change_generated ORDER BY 1,2;
 a1 | b 
----+---
 f  | f
 t  | t
 t  | t
 t  | t
 t  | t
(5 rows)

ALTER TABLE test_at_change_generated CHANGE COLUMN a1 a int;
INSERT INTO test_at_change_generated(a,b) VALUES(100,DEFAULT);
\d test_at_change_generated
   Table "atbdb_schema.test_at_change_generated"
 Column |  Type   |           Modifiers            
--------+---------+--------------------------------
 a      | integer | 
 b      | boolean | generated always as (a) stored

SELECT * FROM test_at_change_generated ORDER BY 1,2;
  a  | b 
-----+---
   0 | f
   1 | t
   1 | t
   1 | t
   1 | t
 100 | t
(6 rows)

DROP TABLE test_at_change_generated;
-- test change column AUTO_INCREMENT
CREATE TABLE test_at_change_autoinc(
    a int,
    b int
);
INSERT INTO test_at_change_autoinc VALUES(1,NULL);
INSERT INTO test_at_change_autoinc VALUES(2,0);
ALTER TABLE test_at_change_autoinc CHANGE b b1 int2 AUTO_INCREMENT; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b1_seq" for serial column "test_at_change_autoinc.b1"
ERROR:  auto_increment column must be defined as a unique or primary key
ALTER TABLE test_at_change_autoinc CHANGE b b1 DECIMAL(4,2) AUTO_INCREMENT UNIQUE KEY; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b1_seq" for serial column "test_at_change_autoinc.b1"
ERROR:  The datatype of column 'b1' does not support auto_increment
ALTER TABLE test_at_change_autoinc CHANGE b b1 serial AUTO_INCREMENT UNIQUE KEY; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change column to type 'serial'
ALTER TABLE test_at_change_autoinc CHANGE b b1 int2 AUTO_INCREMENT NULL UNIQUE KEY;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b1_seq" for serial column "test_at_change_autoinc.b1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_autoinc_b1_key" for table "test_at_change_autoinc"
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a | b1 
---+----
 1 |   
 2 |  2
(2 rows)

INSERT INTO test_at_change_autoinc VALUES(3,0);
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a | b1 
---+----
 1 |   
 2 |  2
 3 |  3
(3 rows)

ALTER TABLE test_at_change_autoinc CHANGE b1 b int;
INSERT INTO test_at_change_autoinc VALUES(4,0);
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a | b 
---+---
 1 |  
 2 | 2
 3 | 3
 4 | 0
(4 rows)

ALTER TABLE test_at_change_autoinc CHANGE b b1 int AUTO_INCREMENT PRIMARY KEY, AUTO_INCREMENT=100;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b1_seq" for serial column "test_at_change_autoinc.b1"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_change_autoinc_pkey" for table "test_at_change_autoinc"
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a | b1  
---+-----
 1 | 100
 2 |   2
 3 |   3
 4 | 101
(4 rows)

INSERT INTO test_at_change_autoinc VALUES(5,0);
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a | b1  
---+-----
 1 | 100
 2 |   2
 3 |   3
 4 | 101
 5 | 102
(5 rows)

ALTER TABLE test_at_change_autoinc AUTO_INCREMENT=1000;
ALTER TABLE test_at_change_autoinc CHANGE b1 b int2 AUTO_INCREMENT;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b_seq" for serial column "test_at_change_autoinc.b"
INSERT INTO test_at_change_autoinc VALUES(6,0);
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a |  b   
---+------
 1 |  100
 2 |    2
 3 |    3
 4 |  101
 5 |  102
 6 | 1000
(6 rows)

ALTER TABLE test_at_change_autoinc ADD COLUMN c int AUTO_INCREMENT UNIQUE, CHANGE b b1 int2 AUTO_INCREMENT UNIQUE KEY; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_c_seq" for serial column "test_at_change_autoinc.c"
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b1_seq" for serial column "test_at_change_autoinc.b1"
ERROR:  Incorrect table definition, there can be only one auto_increment column
ALTER TABLE test_at_change_autoinc ADD COLUMN c int AUTO_INCREMENT UNIQUE; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_c_seq" for serial column "test_at_change_autoinc.c"
ERROR:  Incorrect column definition, there can be only one auto_increment column
ALTER TABLE test_at_change_autoinc CHANGE b b1 int;
ALTER TABLE test_at_change_autoinc ADD COLUMN c int AUTO_INCREMENT UNIQUE;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_c_seq" for serial column "test_at_change_autoinc.c"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_autoinc_c_key" for table "test_at_change_autoinc"
INSERT INTO test_at_change_autoinc VALUES(7,0,0);
SELECT * FROM test_at_change_autoinc ORDER BY 1,2;
 a |  b1  | c 
---+------+---
 1 |  100 | 1
 2 |    2 | 2
 3 |    3 | 3
 4 |  101 | 4
 5 |  102 | 5
 6 | 1000 | 6
 7 |    0 | 7
(7 rows)

ALTER TABLE test_at_change_autoinc DROP COLUMN c , CHANGE b1 b int2 AUTO_INCREMENT UNIQUE KEY FIRST;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_change_autoinc_b_seq" for serial column "test_at_change_autoinc.b"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_change_autoinc_b_key" for table "test_at_change_autoinc"
INSERT INTO test_at_change_autoinc(a,b) VALUES(8,0);
SELECT * FROM test_at_change_autoinc ORDER BY 2,1;
  b   | a 
------+---
  100 | 1
    2 | 2
    3 | 3
  101 | 4
  102 | 5
 1000 | 6
 1001 | 7
 1002 | 8
(8 rows)

DROP TABLE test_at_change_autoinc;
-- test change column depended by other objects
CREATE TABLE test_at_change_depend(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_change_depend VALUES(1,1);
INSERT INTO test_at_change_depend VALUES(2,2);
INSERT INTO test_at_change_depend VALUES(3,3);
-- --PROCEDURE contains column
CREATE OR REPLACE PROCEDURE test_at_change_proc(IN p_in int)
    AS
    BEGIN
        INSERT INTO test_at_change_depend(a,b) VALUES(p_in, p_in);
    END;
/
ALTER TABLE test_at_change_depend CHANGE b b1 varchar(8) NOT NULL;
CALL test_at_change_proc(2); -- ERROR
ERROR:  column "b" of relation "test_at_change_depend" does not exist
LINE 1: INSERT INTO test_at_change_depend(a,b) VALUES(p_in, p_in)
                                            ^
QUERY:  INSERT INTO test_at_change_depend(a,b) VALUES(p_in, p_in)
CONTEXT:  PL/pgSQL function test_at_change_proc(integer) line 2 at SQL statement
DROP PROCEDURE test_at_change_proc;
-- --TRIGGER contains and depends column
CREATE OR REPLACE FUNCTION tg_bf_test_at_change_func() RETURNS TRIGGER AS
$$
    DECLARE
    BEGIN
        UPDATE test_at_change_depend SET b1 = NULL WHERE a < NEW.a;
        RETURN NEW;
    END
$$ LANGUAGE PLPGSQL;
CREATE TRIGGER tg_bf_test_at_change
    AFTER UPDATE ON test_at_change_depend
    FOR EACH ROW WHEN ( NEW.b1 IS NULL AND OLD.b1 = OLD.a)
    EXECUTE PROCEDURE tg_bf_test_at_change_func();
ALTER TABLE test_at_change_depend CHANGE b1 b varchar(8) NULL DEFAULT '0';
UPDATE test_at_change_depend SET b = NULL WHERE a = 2; -- ERROR
ERROR:  column "b1" of relation "test_at_change_depend" does not exist
LINE 1: UPDATE test_at_change_depend SET b1 = NULL WHERE a < NEW.a
                                         ^
QUERY:  UPDATE test_at_change_depend SET b1 = NULL WHERE a < NEW.a
CONTEXT:  PL/pgSQL function tg_bf_test_at_change_func() line 4 at SQL statement
DROP TRIGGER tg_bf_test_at_change ON test_at_change_depend;
DROP FUNCTION tg_bf_test_at_change_func;
-- --VIEW depends column
CREATE VIEW test_at_change_view AS SELECT b FROM test_at_change_depend;
ALTER TABLE test_at_change_depend CHANGE b b1 bigint NULL; -- ERROR
ERROR:  cannot change data type of view column "b" from character varying(8) to bigint
ALTER TABLE test_at_change_depend CHANGE b b1 int NULL; -- ERROR
ERROR:  cannot change data type of view column "b" from character varying(8) to integer
ALTER TABLE test_at_change_depend CHANGE b b1 varchar(8) NULL;
SELECT b FROM test_at_change_view ORDER BY 1;
 b 
---
 1
 2
 3
(3 rows)

DROP VIEW test_at_change_view;
CREATE VIEW test_at_change_view AS SELECT a FROM test_at_change_depend where b1 > 0;
CREATE VIEW test_at_change_view1 AS SELECT * FROM test_at_change_view;
ALTER TABLE test_at_change_depend CHANGE b1 b bigint NULL GENERATED ALWAYS AS (a+1);
ALTER TABLE test_at_change_depend CHANGE b b1 varchar(8) NULL;
ALTER TABLE test_at_change_depend CHANGE b1 b int NULL;
SELECT * FROM test_at_change_view1 ORDER BY 1;
 a 
---
 1
 2
 3
(3 rows)

DROP VIEW test_at_change_view1;
DROP VIEW test_at_change_view;
CREATE materialized VIEW test_at_change_view AS SELECT b FROM test_at_change_depend;
ALTER TABLE test_at_change_depend CHANGE COLUMN b b1 bigint not null; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change a column used by materialized view or rule is not supported
DROP MATERIALIZED VIEW test_at_change_view;
-- --TABLE reference column.
DELETE FROM test_at_change_depend;
ALTER TABLE test_at_change_depend CHANGE b b INT PRIMARY KEY;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_change_depend_pkey" for table "test_at_change_depend"
CREATE TABLE test_at_change_ref(
    a int,
    b int,
    FOREIGN KEY (b) REFERENCES test_at_change_depend(b) ON DELETE SET NULL
);
ALTER TABLE test_at_change_depend CHANGE COLUMN b b1 varchar(8);
INSERT INTO test_at_change_ref VALUES(0,0); -- ERROR
ERROR:  insert or update on table "test_at_change_ref" violates foreign key constraint "test_at_change_ref_b_fkey"
DETAIL:  Key (b)=(0) is not present in table "test_at_change_depend".
INSERT INTO test_at_change_depend VALUES(0,0);
INSERT INTO test_at_change_ref VALUES(0,0);
ALTER TABLE test_at_change_ref CHANGE COLUMN b b1 varchar(8) GENERATED ALWAYS AS (a+1) STORED; -- ERROR
ERROR:  invalid ON DELETE action for foreign key constraint containing generated column
ALTER TABLE test_at_change_ref CHANGE COLUMN b b1 varchar(8);
\d+ test_at_change_ref
                      Table "atbdb_schema.test_at_change_ref"
 Column |         Type         | Modifiers | Storage  | Stats target | Description 
--------+----------------------+-----------+----------+--------------+-------------
 a      | integer              |           | plain    |              | 
 b1     | character varying(8) |           | extended |              | 
Foreign-key constraints:
    "test_at_change_ref_b_fkey" FOREIGN KEY (b1) REFERENCES test_at_change_depend(b1) ON DELETE SET NULL
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE test_at_change_ref;
-- --TABLE reference self column.
CREATE TABLE test_at_change_ref(
    a int PRIMARY KEY,
    b int,
    FOREIGN KEY (b) REFERENCES test_at_change_ref(a) ON DELETE SET NULL
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_change_ref_pkey" for table "test_at_change_ref"
INSERT INTO test_at_change_ref VALUES(0,0);
ALTER TABLE test_at_change_ref CHANGE COLUMN b b1 varchar(8) GENERATED ALWAYS AS (a+1) STORED; -- ERROR
ERROR:  invalid ON DELETE action for foreign key constraint containing generated column
ALTER TABLE test_at_change_ref CHANGE COLUMN b b1 varchar(8);
ALTER TABLE test_at_change_ref CHANGE COLUMN a a1 varchar(8);
INSERT INTO test_at_change_ref VALUES('a','a');
DROP TABLE test_at_change_ref;
-- --RULE reference column.
CREATE RULE test_at_change_rule AS ON INSERT TO test_at_change_depend WHERE (b1 is null) DO INSTEAD UPDATE test_at_change_depend SET b1=0;
ALTER TABLE test_at_change_depend CHANGE COLUMN b1 b bigint not null; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change a column used by materialized view or rule is not supported
DROP RULE test_at_change_rule ON test_at_change_depend;
-- --RLSPOLICY reference column.
DROP TABLE test_at_change_depend;
CREATE ROLE at_change_role PASSWORD 'Gauss@123';
CREATE TABLE test_at_change_depend(
    a int,
    b int NOT NULL
);
INSERT INTO test_at_change_depend VALUES(0,0);
GRANT USAGE ON SCHEMA atbdb_schema TO at_change_role;
GRANT SELECT ON test_at_change_depend TO at_change_role;
ALTER TABLE test_at_change_depend ENABLE ROW LEVEL SECURITY;
CREATE ROW LEVEL SECURITY POLICY test_at_change_rls ON test_at_change_depend AS RESTRICTIVE FOR SELECT TO at_change_role USING(b >= 20);
ALTER TABLE test_at_change_depend CHANGE COLUMN b b1 int not null;
INSERT INTO test_at_change_depend VALUES(21,21);
SET ROLE at_change_role PASSWORD 'Gauss@123';
SELECT * FROM test_at_change_depend ORDER BY 1,2;
 a  | b1 
----+----
 21 | 21
(1 row)

RESET ROLE;
SELECT * FROM test_at_change_depend ORDER BY 1,2;
 a  | b1 
----+----
  0 |  0
 21 | 21
(2 rows)

ALTER TABLE test_at_change_depend CHANGE COLUMN b1 b2 bool not null;
ALTER TABLE test_at_change_depend CHANGE COLUMN b2 b3 int not null;
INSERT INTO test_at_change_depend VALUES(22,22);
SET ROLE at_change_role PASSWORD 'Gauss@123';
SELECT * FROM test_at_change_depend ORDER BY 1,2;
 a  | b3 
----+----
 22 | 22
(1 row)

RESET ROLE;
SELECT * FROM test_at_change_depend ORDER BY 1,2;
 a  | b3 
----+----
  0 |  0
 21 |  1
 22 | 22
(3 rows)

DROP TABLE test_at_change_depend;
REVOKE ALL PRIVILEGES ON SCHEMA atbdb_schema FROM at_change_role;
DROP ROLE at_change_role;
-- test alter command order
CREATE TABLE test_at_pass(
    a int,
    b int
);
INSERT INTO test_at_pass VALUES(1,0);
ALTER TABLE test_at_pass ADD COLUMN c int, DROP COLUMN c; -- ERROR
ERROR:  column "c" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass ADD COLUMN c int DEFAULT 0, MODIFY COLUMN c bigint; -- ERROR
ERROR:  column "c" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass ADD COLUMN c int DEFAULT 0, CHANGE COLUMN c c1 bigint; -- ERROR
ERROR:  column "c" does not exist
ALTER TABLE test_at_pass MODIFY COLUMN b bigint, MODIFY COLUMN b float4; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change column "b" twice
ALTER TABLE test_at_pass MODIFY COLUMN b bigint, CHANGE COLUMN b b1 float4; -- ERROR
ERROR:  column "b" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass CHANGE COLUMN b b1 bigint, CHANGE COLUMN b1 b2 bigint; -- ERROR
ERROR:  column "b1" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass MODIFY COLUMN b bigint, DROP COLUMN b; -- ERROR
ERROR:  column "b" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass CHANGE COLUMN b b1 bigint, DROP COLUMN b; -- ERROR
ERROR:  column "b" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass CHANGE COLUMN b b1 bigint, DROP COLUMN b1; -- ERROR
ERROR:  column "b1" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass MODIFY a bigint, MODIFY COLUMN a VARCHAR(8); -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change column "a" twice
ALTER TABLE test_at_pass CHANGE COLUMN b a bigint, CHANGE COLUMN a b VARCHAR(8); -- ERROR
ERROR:  column "a" of relation "test_at_pass" already exists
ALTER TABLE test_at_pass MODIFY COLUMN b bigint, ALTER COLUMN b SET DEFAULT 100;
\d test_at_pass
Table "atbdb_schema.test_at_pass"
 Column |  Type   |  Modifiers  
--------+---------+-------------
 a      | integer | 
 b      | bigint  | default 100

ALTER TABLE test_at_pass MODIFY COLUMN b bigint DEFAULT 100, ALTER COLUMN b DROP DEFAULT;
\d test_at_pass
Table "atbdb_schema.test_at_pass"
 Column |  Type   |  Modifiers  
--------+---------+-------------
 a      | integer | 
 b      | bigint  | default 100

ALTER TABLE test_at_pass CHANGE COLUMN b b1 bigint, ALTER COLUMN b1 SET DEFAULT 100;
\d test_at_pass
Table "atbdb_schema.test_at_pass"
 Column |  Type   |  Modifiers  
--------+---------+-------------
 a      | integer | 
 b1     | bigint  | default 100

ALTER TABLE test_at_pass CHANGE COLUMN b1 b bigint DEFAULT 100, ALTER COLUMN b DROP DEFAULT;
\d test_at_pass
Table "atbdb_schema.test_at_pass"
 Column |  Type   |  Modifiers  
--------+---------+-------------
 a      | integer | 
 b      | bigint  | default 100

ALTER TABLE test_at_pass CHANGE COLUMN b b1 bigint DEFAULT 100, ALTER COLUMN b DROP DEFAULT; -- ERROR
ERROR:  column "b" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass MODIFY COLUMN a bigint CONSTRAINT atpass_pk PRIMARY KEY, DROP CONSTRAINT atpass_pk; -- ERROR
ERROR:  constraint "atpass_pk" of relation "test_at_pass" does not exist
ALTER TABLE test_at_pass MODIFY COLUMN a bigint CONSTRAINT atpass_pk PRIMARY KEY, ADD CONSTRAINT atpass_pk PRIMARY KEY(a); -- ERROR
ERROR:  multiple primary keys for table "test_at_pass" are not allowed
LINE 1: ...MN a bigint CONSTRAINT atpass_pk PRIMARY KEY, ADD CONSTRAINT...
                                                             ^
DROP TABLE test_at_pass;
-- test complex commands combined
CREATE TABLE test_at_complex(
    a int,
    b int GENERATED ALWAYS AS (a+1) STORED
);
INSERT INTO test_at_complex VALUES(0,DEFAULT);
INSERT INTO test_at_complex VALUES(1,DEFAULT);
INSERT INTO test_at_complex VALUES(2,DEFAULT);
INSERT INTO test_at_complex VALUES(-1,DEFAULT);
ALTER TABLE test_at_complex MODIFY COLUMN a varchar(8), MODIFY COLUMN b int AUTO_INCREMENT UNIQUE;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_complex_b_seq" for serial column "test_at_complex.b"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_complex_b_key" for table "test_at_complex"
INSERT INTO test_at_complex VALUES(3,DEFAULT);
SELECT * FROM test_at_complex ORDER BY a::int,b::int;
 a  | b 
----+---
 -1 | 4
 0  | 1
 1  | 2
 2  | 3
 3  | 5
(5 rows)

DROP TABLE test_at_complex;
CREATE TABLE test_at_complex(
    a int,
    b int GENERATED ALWAYS AS (a+1) STORED
);
INSERT INTO test_at_complex VALUES(0,DEFAULT);
INSERT INTO test_at_complex VALUES(1,DEFAULT);
INSERT INTO test_at_complex VALUES(2,DEFAULT);
INSERT INTO test_at_complex VALUES(-1,DEFAULT);
ALTER TABLE test_at_complex MODIFY COLUMN b int AUTO_INCREMENT UNIQUE, MODIFY COLUMN a varchar(8);
NOTICE:  ALTER TABLE will create implicit sequence "test_at_complex_b_seq" for serial column "test_at_complex.b"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_at_complex_b_key" for table "test_at_complex"
INSERT INTO test_at_complex VALUES(3,DEFAULT);
SELECT * FROM test_at_complex ORDER BY a::int,b::int;
 a  | b 
----+---
 -1 | 4
 0  | 1
 1  | 2
 2  | 3
 3  | 5
(5 rows)

DROP TABLE test_at_complex;
-- test modify partitioned table column without data
CREATE TABLE pt_at_modify (a int, b int NOT NULL, PRIMARY KEY(b,a))
PARTITION BY RANGE (a)
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (1000),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pt_at_modify_pkey" for table "pt_at_modify"
ALTER TABLE pt_at_modify MODIFY a int8 DEFAULT 0; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  modify or change partition key column is not supported
ALTER TABLE pt_at_modify MODIFY a int DEFAULT 0;
ALTER TABLE pt_at_modify MODIFY a int GENERATED ALWAYS AS (b+1) STORED; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  cannot modify or change a partition key column as a generated column
\d+ pt_at_modify;
                      Table "atbdb_schema.pt_at_modify"
 Column |  Type   |     Modifiers      | Storage | Stats target | Description 
--------+---------+--------------------+---------+--------------+-------------
 a      | integer | not null default 0 | plain   |              | 
 b      | integer | not null           | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b int8 NULL;
\d+ pt_at_modify;
                      Table "atbdb_schema.pt_at_modify"
 Column |  Type   |     Modifiers      | Storage | Stats target | Description 
--------+---------+--------------------+---------+--------------+-------------
 a      | integer | not null default 0 | plain   |              | 
 b      | bigint  | not null           | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b int8 DEFAULT 0;
\d+ pt_at_modify;
                      Table "atbdb_schema.pt_at_modify"
 Column |  Type   |     Modifiers      | Storage | Stats target | Description 
--------+---------+--------------------+---------+--------------+-------------
 a      | integer | not null default 0 | plain   |              | 
 b      | bigint  | not null default 0 | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b int AUTO_INCREMENT;
NOTICE:  ALTER TABLE will create implicit sequence "pt_at_modify_b_seq" for serial column "pt_at_modify.b"
\d+ pt_at_modify;
                         Table "atbdb_schema.pt_at_modify"
 Column |  Type   |        Modifiers        | Storage | Stats target | Description 
--------+---------+-------------------------+---------+--------------+-------------
 a      | integer | not null default 0      | plain   |              | 
 b      | integer | not null AUTO_INCREMENT | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b int2 UNIQUE;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "pt_at_modify_b_tableoid_key" for table "pt_at_modify"
\d+ pt_at_modify;
                       Table "atbdb_schema.pt_at_modify"
 Column |   Type   |     Modifiers      | Storage | Stats target | Description 
--------+----------+--------------------+---------+--------------+-------------
 a      | integer  | not null default 0 | plain   |              | 
 b      | smallint | not null           | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
    "pt_at_modify_b_tableoid_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b int CHECK (b < 10000);
\d+ pt_at_modify;
                      Table "atbdb_schema.pt_at_modify"
 Column |  Type   |     Modifiers      | Storage | Stats target | Description 
--------+---------+--------------------+---------+--------------+-------------
 a      | integer | not null default 0 | plain   |              | 
 b      | integer | not null           | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
    "pt_at_modify_b_tableoid_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Check constraints:
    "pt_at_modify_b_check" CHECK (b < 10000)
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b varchar(8) COLLATE "POSIX";
\d+ pt_at_modify;
                               Table "atbdb_schema.pt_at_modify"
 Column |         Type         |       Modifiers        | Storage  | Stats target | Description 
--------+----------------------+------------------------+----------+--------------+-------------
 a      | integer              | not null default 0     | plain    |              | 
 b      | character varying(8) | collate POSIX not null | extended |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
    "pt_at_modify_b_tableoid_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Check constraints:
    "pt_at_modify_b_check" CHECK (b::bigint < 10000)
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b int8 GENERATED ALWAYS AS (a+1) STORED;
\d+ pt_at_modify;
                                    Table "atbdb_schema.pt_at_modify"
 Column |  Type   |                   Modifiers                   | Storage | Stats target | Description 
--------+---------+-----------------------------------------------+---------+--------------+-------------
 a      | integer | not null default 0                            | plain   |              | 
 b      | bigint  | not null generated always as ((a + 1)) stored | plain   |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
    "pt_at_modify_b_tableoid_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Check constraints:
    "pt_at_modify_b_check" CHECK (b < 10000)
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE pt_at_modify MODIFY b varchar(8) NOT NULL;
\d+ pt_at_modify;
                             Table "atbdb_schema.pt_at_modify"
 Column |         Type         |     Modifiers      | Storage  | Stats target | Description 
--------+----------------------+--------------------+----------+--------------+-------------
 a      | integer              | not null default 0 | plain    |              | 
 b      | character varying(8) | not null           | extended |              | 
Indexes:
    "pt_at_modify_pkey" PRIMARY KEY, btree (b, a) LOCAL TABLESPACE pg_default
    "pt_at_modify_b_tableoid_key" UNIQUE CONSTRAINT, btree (b) TABLESPACE pg_default
Check constraints:
    "pt_at_modify_b_check" CHECK (b::bigint < 10000)
Partition By RANGE(a)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_tabledef('pt_at_modify'::regclass);
                                                pg_get_tabledef                                                 
----------------------------------------------------------------------------------------------------------------
 SET search_path = atbdb_schema;                                                                               +
 CREATE TABLE pt_at_modify (                                                                                   +
     a integer DEFAULT 0 NOT NULL,                                                                             +
     b character varying(8) NOT NULL,                                                                          +
     CONSTRAINT pt_at_modify_b_check CHECK (((b)::bigint < 10000))                                             +
 )                                                                                                             +
 WITH (orientation=row, compression=no)                                                                        +
 PARTITION BY RANGE (a)                                                                                        +
 (                                                                                                             +
     PARTITION p1 VALUES LESS THAN (100),                                                                      +
     PARTITION p2 VALUES LESS THAN (1000),                                                                     +
     PARTITION p3 VALUES LESS THAN (MAXVALUE)                                                                  +
 )                                                                                                             +
 ENABLE ROW MOVEMENT;                                                                                          +
 ALTER TABLE pt_at_modify ADD CONSTRAINT pt_at_modify_b_tableoid_key UNIQUE USING btree (b) INCLUDE (tableoid);+
 ALTER TABLE pt_at_modify ADD CONSTRAINT pt_at_modify_pkey PRIMARY KEY USING btree  (b, a);
(1 row)

INSERT INTO pt_at_modify VALUES(1,1);
DROP TABLE pt_at_modify;
-- test alter modify first after
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,13);
INSERT INTO test_at_modify_fa VALUES(21,22,23);
ALTER TABLE test_at_modify_fa ADD COLUMN d int GENERATED ALWAYS AS (a+100) STORED AFTER a, MODIFY c float4 FIRST;
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
 c  | a  |  d  | b  
----+----+-----+----
  3 |  1 | 101 |  2
 13 | 11 | 111 | 12
 23 | 21 | 121 | 22
(3 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,13);
INSERT INTO test_at_modify_fa VALUES(21,22,23);
ALTER TABLE test_at_modify_fa ADD COLUMN d int GENERATED ALWAYS AS (a+100) STORED FIRST, MODIFY c float4 GENERATED ALWAYS AS (b+100) STORED AFTER a;
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  d  | a  |  c  | b  
-----+----+-----+----
 101 |  1 | 102 |  2
 111 | 11 | 112 | 12
 121 | 21 | 122 | 22
(3 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,0);
INSERT INTO test_at_modify_fa VALUES(21,22,0);
ALTER TABLE test_at_modify_fa ADD COLUMN d int GENERATED ALWAYS AS (a+100) STORED FIRST, MODIFY c bigint AUTO_INCREMENT PRIMARY KEY AFTER a;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_fa_pkey" for table "test_at_modify_fa"
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  d  | a  | c | b  
-----+----+---+----
 101 |  1 | 3 |  2
 111 | 11 | 4 | 12
 121 | 21 | 5 | 22
(3 rows)

INSERT INTO test_at_modify_fa(a,b,c) VALUES(31,32,NULL);
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  d  | a  | c | b  
-----+----+---+----
 101 |  1 | 3 |  2
 111 | 11 | 4 | 12
 121 | 21 | 5 | 22
 131 | 31 | 6 | 32
(4 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int GENERATED ALWAYS AS (b+1) STORED
);
INSERT INTO test_at_modify_fa VALUES(1,2,DEFAULT);
INSERT INTO test_at_modify_fa VALUES(11,12,DEFAULT);
INSERT INTO test_at_modify_fa VALUES(21,22,DEFAULT);
ALTER TABLE test_at_modify_fa ADD COLUMN d int GENERATED ALWAYS AS (a+100) STORED AFTER a, MODIFY b float4 GENERATED ALWAYS AS (a+1000) STORED FIRST; -- ERROR
ERROR:  Invalid modify column operation
DETAIL:  A generated column cannot reference another generated column.
ALTER TABLE test_at_modify_fa ADD COLUMN d int GENERATED ALWAYS AS (b+100) STORED AFTER a, MODIFY a float4 GENERATED ALWAYS AS (b+1000) STORED FIRST;
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  a   |  d  | b  | c  
------+-----+----+----
 1002 | 102 |  2 |  3
 1012 | 112 | 12 | 13
 1022 | 122 | 22 | 23
(3 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,13);
INSERT INTO test_at_modify_fa VALUES(21,22,23);
SELECT a,b,c FROM test_at_modify_fa ORDER BY 1,2,3;
 a  | b  | c  
----+----+----
  1 |  2 |  3
 11 | 12 | 13
 21 | 22 | 23
(3 rows)

ALTER TABLE test_at_modify_fa ADD COLUMN d int GENERATED ALWAYS AS (a+100) STORED AFTER a, ADD COLUMN e int GENERATED ALWAYS AS (b+100) STORED FIRST;
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  e  | a  |  d  | b  | c  
-----+----+-----+----+----
 102 |  1 | 101 |  2 |  3
 112 | 11 | 111 | 12 | 13
 122 | 21 | 121 | 22 | 23
(3 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,13);
INSERT INTO test_at_modify_fa VALUES(21,22,23);
SELECT a,b,c FROM test_at_modify_fa ORDER BY 1,2,3;
 a  | b  | c  
----+----+----
  1 |  2 |  3
 11 | 12 | 13
 21 | 22 | 23
(3 rows)

ALTER TABLE test_at_modify_fa ADD COLUMN d bigint AUTO_INCREMENT PRIMARY KEY AFTER a, ADD COLUMN e int GENERATED ALWAYS AS (b+100) STORED FIRST;
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_d_seq" for serial column "test_at_modify_fa.d"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_at_modify_fa_pkey" for table "test_at_modify_fa"
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  e  | a  | d | b  | c  
-----+----+---+----+----
 102 |  1 | 1 |  2 |  3
 112 | 11 | 2 | 12 | 13
 122 | 21 | 3 | 22 | 23
(3 rows)

INSERT INTO test_at_modify_fa(a,b,c) VALUES(31,32,33);
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3,4;
  e  | a  | d | b  | c  
-----+----+---+----+----
 102 |  1 | 1 |  2 |  3
 112 | 11 | 2 | 12 | 13
 122 | 21 | 3 | 22 | 23
 132 | 31 | 4 | 32 | 33
(4 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,13);
INSERT INTO test_at_modify_fa VALUES(21,22,23);
ALTER TABLE test_at_modify_fa MODIFY COLUMN c float4 GENERATED ALWAYS AS (a+100) STORED FIRST, MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED AFTER c; -- ERROR
ERROR:  cannot use generated column "c" in column generation expression
DETAIL:  A generated column cannot reference another generated column.
ALTER TABLE test_at_modify_fa MODIFY COLUMN c float4 GENERATED ALWAYS AS (a+100) STORED FIRST, MODIFY COLUMN b int GENERATED ALWAYS AS (a+100) STORED AFTER c;
SELECT * FROM test_at_modify_fa ORDER BY 1,2,3;
  c  |  b  | a  
-----+-----+----
 101 | 101 |  1
 111 | 111 | 11
 121 | 121 | 21
(3 rows)

DROP TABLE test_at_modify_fa;
CREATE TABLE test_at_modify_fa(
    a int,
    b int,
    c int
);
INSERT INTO test_at_modify_fa VALUES(1,2,3);
INSERT INTO test_at_modify_fa VALUES(11,12,0);
INSERT INTO test_at_modify_fa VALUES(21,22,0);
ALTER TABLE test_at_modify_fa MODIFY COLUMN c bigint AUTO_INCREMENT PRIMARY KEY FIRST, MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED AFTER c; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
ERROR:  generated column cannot refer to auto_increment column
ALTER TABLE test_at_modify_fa MODIFY COLUMN b int GENERATED ALWAYS AS (c+100) STORED AFTER c, MODIFY COLUMN c bigint AUTO_INCREMENT PRIMARY KEY FIRST; -- ERROR
NOTICE:  ALTER TABLE will create implicit sequence "test_at_modify_fa_c_seq" for serial column "test_at_modify_fa.c"
ERROR:  generated column cannot refer to auto_increment column
DROP TABLE test_at_modify_fa;
-- primary key should be not null after modify 
create table test11(f11 int, f12 varchar(20), f13 bool, CONSTRAINT pk_test11_f11 primary key (f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pk_test11_f11" for table "test11"
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f11    | integer               | not null
 f12    | character varying(20) | 
 f13    | boolean               | 
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11) TABLESPACE pg_default

ALTER TABLE test11 MODIFY COLUMN f11 int;
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f11    | integer               | not null
 f12    | character varying(20) | 
 f13    | boolean               | 
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11) TABLESPACE pg_default

ALTER TABLE test11 MODIFY COLUMN f11 int AFTER f13;
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f12    | character varying(20) | 
 f13    | boolean               | 
 f11    | integer               | not null
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11) TABLESPACE pg_default

ALTER TABLE test11 DROP CONSTRAINT pk_test11_f11, MODIFY COLUMN f11 int NULL;
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f12    | character varying(20) | 
 f13    | boolean               | 
 f11    | integer               | 

ALTER TABLE test11 ADD CONSTRAINT pk_test11_f11 primary key (f11), MODIFY COLUMN f11 int NULL;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "pk_test11_f11" for table "test11"
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f12    | character varying(20) | 
 f13    | boolean               | 
 f11    | integer               | not null
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11) TABLESPACE pg_default

insert into test11(f11,f12,f13) values(NULL,'1',true); --ERROR
ERROR:  null value in column "f11" violates not-null constraint
DETAIL:  Failing row contains (1, t, null).
drop table test11;
-- primary keys should be not null after modify 
create table test11(f11 int, f12 varchar(20), f13 bool, CONSTRAINT pk_test11_f11 primary key (f11,f12));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pk_test11_f11" for table "test11"
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f11    | integer               | not null
 f12    | character varying(20) | not null
 f13    | boolean               | 
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default

ALTER TABLE test11 MODIFY COLUMN f11 int;
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f11    | integer               | not null
 f12    | character varying(20) | not null
 f13    | boolean               | 
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default

ALTER TABLE test11 MODIFY f11 int AFTER f13;
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f12    | character varying(20) | not null
 f13    | boolean               | 
 f11    | integer               | not null
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default

ALTER TABLE test11 DROP CONSTRAINT pk_test11_f11, MODIFY COLUMN f11 int NULL;
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f12    | character varying(20) | not null
 f13    | boolean               | 
 f11    | integer               | 

ALTER TABLE test11 ADD CONSTRAINT pk_test11_f11 primary key (f11), MODIFY COLUMN f11 int NULL;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "pk_test11_f11" for table "test11"
\d test11
        Table "atbdb_schema.test11"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 f12    | character varying(20) | not null
 f13    | boolean               | 
 f11    | integer               | not null
Indexes:
    "pk_test11_f11" PRIMARY KEY, btree (f11) TABLESPACE pg_default

insert into test11(f11,f12,f13) values(NULL,'1',true); --ERROR
ERROR:  null value in column "f11" violates not-null constraint
DETAIL:  Failing row contains (1, t, null).
drop table test11;
-- primary keys in partition table should be not null after modify 
create table range_range(id int, gender varchar not null, birthday date not null)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
ALTER TABLE range_range ADD CONSTRAINT range_range_pkey primary KEY USING btree  (id, birthday);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "range_range_pkey" for table "range_range"
\d+ range_range
                         Table "atbdb_schema.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 id       | integer           | not null  | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (id, birthday) LOCAL TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE range_range MODIFY COLUMN id int AFTER birthday;
\d+ range_range
                         Table "atbdb_schema.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
 id       | integer           | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (id, birthday) LOCAL TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists range_range cascade;
-- primary key in partition table should be not null after modify 
create table range_range(id int, gender varchar not null, birthday date not null)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
ALTER TABLE range_range ADD CONSTRAINT range_range_pkey primary KEY USING btree  (id);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "range_range_pkey" for table "range_range"
\d+ range_range
                         Table "atbdb_schema.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 id       | integer           | not null  | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (id) TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE range_range MODIFY COLUMN id int AFTER birthday;
\d+ range_range
                         Table "atbdb_schema.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
 id       | integer           | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (id) TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists range_range cascade;
-- primary key in partition table should be not null after modify 
create table range_range(id int, gender varchar not null, birthday date not null)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
ALTER TABLE range_range ADD CONSTRAINT range_range_pkey primary KEY USING btree  (gender);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "range_range_pkey" for table "range_range"
\d+ range_range
                         Table "atbdb_schema.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 id       | integer           |           | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (gender) TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE range_range MODIFY COLUMN gender varchar AFTER birthday;
\d+ range_range
                         Table "atbdb_schema.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 id       | integer           |           | plain    |              | 
 birthday | date              | not null  | plain    |              | 
 gender   | character varying | not null  | extended |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (gender) TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists range_range cascade;
-- primary keys in multi range keys partition table should be not null after modify 
create table multi_keys_range(f1 int, f2 int, f3 int)
partition by range(f1, f2)
(
        partition multi_keys_range_p0 values less than (10, 0),
        partition multi_keys_range_p1 values less than (20, 0),
        partition multi_keys_range_p2 values less than (30, 0)
);
-- primary key should be LOCAL INDEX
alter table multi_keys_range modify f1 int after f3, ADD CONSTRAINT multi_keys_range_pkey PRIMARY KEY USING btree (f1,f2);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "multi_keys_range_pkey" for table "multi_keys_range"
\d+ multi_keys_range
                Table "atbdb_schema.multi_keys_range"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer | not null  | plain   |              | 
 f3     | integer |           | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "multi_keys_range_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

alter table multi_keys_range modify f2 int after f3;
\d+ multi_keys_range
                Table "atbdb_schema.multi_keys_range"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "multi_keys_range_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists multi_keys_range cascade;
-- primary keys in multi list keys partition table should be not null after modify 
create table multi_keys_list(f1 int, f2 int, f3 int)
partition by list(f1, f2)
(
        partition multi_keys_list_p0 values ((10, 0)),
        partition multi_keys_list_p1 values ((20, 0)),
        partition multi_keys_list_p2 values (DEFAULT)
);
-- primary key should be LOCAL INDEX
alter table multi_keys_list modify f1 int after f3, ADD CONSTRAINT multi_keys_list_pkey PRIMARY KEY USING btree (f1,f2);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "multi_keys_list_pkey" for table "multi_keys_list"
\d+ multi_keys_list
                Table "atbdb_schema.multi_keys_list"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer | not null  | plain   |              | 
 f3     | integer |           | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "multi_keys_list_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By LIST(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

alter table multi_keys_list modify f2 int after f3;
\d+ multi_keys_list
                Table "atbdb_schema.multi_keys_list"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "multi_keys_list_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By LIST(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists multi_keys_list cascade;
-- test moidfy/change VIEW depends column
-- --modify
-- -- --test select *
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW test_modify_view_star AS select * from test_at_modify_view_column;
ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  MODIFY column f1 int;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
               pg_get_viewdef               
--------------------------------------------
 SELECT  * FROM test_at_modify_view_column;
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f1 int FIRST;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                           pg_get_viewdef                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f4, test_at_modify_view_column.f3, test_at_modify_view_column.f2, test_at_modify_view_column.f1 FROM test_at_modify_view_column;
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_star
-- -- --test select * with add column
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW test_modify_view_star AS select * from test_at_modify_view_column;
ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20), ADD COLUMN f0 int;
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  MODIFY column f1 int, ADD COLUMN f0 int;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                           pg_get_viewdef                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f4, test_at_modify_view_column.f3, test_at_modify_view_column.f2, test_at_modify_view_column.f1 FROM test_at_modify_view_column;
(1 row)

SELECT * FROM test_modify_view_star;
 f4 | f3 | f2 | f1 
----+----+----+----
  4 | 3  | 2  |  1
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f1 int FIRST, ADD COLUMN f5 int FIRST;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                           pg_get_viewdef                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f4, test_at_modify_view_column.f3, test_at_modify_view_column.f2, test_at_modify_view_column.f1 FROM test_at_modify_view_column;
(1 row)

SELECT * FROM test_modify_view_star;
 f4 | f3 | f2 | f1 
----+----+----+----
  4 | 3  | 2  |  1
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_star
-- -- --test select * special
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
create view test_modify_view_star(col1,col2) as
SELECT * FROM
(
    SELECT
        CAST(f1/10000 AS DECIMAL(18,2)),
        CAST(CAST(f4 AS DECIMAL(18,4))/f1*100 AS DECIMAL(18,2))
    FROM test_at_modify_view_column
);
SELECT * FROM test_modify_view_star;
 col1 |  col2  
------+--------
 0.00 | 400.00
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20);
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                                                                                               pg_get_viewdef                                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT  * FROM (SELECT (((test_at_modify_view_column.f1)::bigint / 10000))::numeric(18,2) AS "numeric", ((((test_at_modify_view_column.f4)::numeric(18,4) / (test_at_modify_view_column.f1)::numeric) * (100)::numeric))::numeric(18,2) AS "numeric" FROM test_at_modify_view_column) __unnamed_subquery__;
(1 row)

SELECT * FROM test_modify_view_star;
 col1 |  col2  
------+--------
 0.00 | 400.00
(1 row)

ALTER TABLE test_at_modify_view_column MODIFY column f1 int FIRST; -- ERROR
ERROR:  column reference "numeric" is ambiguous
LINE 1: ALTER TABLE test_at_modify_view_column MODIFY column f1 int ...
               ^
CONTEXT:  referenced column: col1
ALTER TABLE test_at_modify_view_column ADD COLUMN f5 int FIRST; -- ERROR
ERROR:  column reference "numeric" is ambiguous
LINE 1: ALTER TABLE test_at_modify_view_column ADD COLUMN f5 int FIR...
               ^
CONTEXT:  referenced column: col1
DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_star
-- -- --test modify view column
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW test_modify_view_f1f2 WITH(security_barrier=TRUE) AS select F1,F2 from test_at_modify_view_column;
ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  MODIFY column f1 int;
SELECT pg_get_viewdef('test_modify_view_f1f2'::regclass);
                                            pg_get_viewdef                                            
------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2 FROM test_at_modify_view_column;
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f1 int FIRST;
SELECT pg_get_viewdef('test_modify_view_f1f2'::regclass);
                                            pg_get_viewdef                                            
------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2 FROM test_at_modify_view_column;
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_f1f2
-- -- --test view and column name
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW "test_modify_view_f1f2F3" AS select F1,F2,F3 AS "F3" from test_at_modify_view_column where f4 > 0;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                    pg_get_viewdef                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE (test_at_modify_view_column.f4 > 0);
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  MODIFY column f1 int;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                    pg_get_viewdef                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE (test_at_modify_view_column.f4 > 0);
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f4 varchar(20);
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                         pg_get_viewdef                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.f4)::bigint > 0);
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f4 int AFTER f1;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                         pg_get_viewdef                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.f4)::bigint > 0);
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view "test_modify_view_f1f2F3"
-- -- --test drop column
CREATE TABLE test_at_modify_view_column (f5 int, f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(5, 4, '3', '2', 1);
CREATE VIEW "test_modify_view_f1f2F3" AS select F1,F2,F3 AS "F3" from test_at_modify_view_column where f4 > 0;
ALTER TABLE test_at_modify_view_column  MODIFY column f1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  MODIFY column f4 varchar(20), DROP COLUMN f5;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                         pg_get_viewdef                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.f4)::bigint > 0);
(1 row)

SELECT * FROM "test_modify_view_f1f2F3";
 f1 | f2 | F3 
----+----+----
  1 | 2  | 3
(1 row)

ALTER TABLE test_at_modify_view_column  MODIFY column f4 int AFTER f1, DROP COLUMN f5;
ERROR:  column "f5" of relation "test_at_modify_view_column" does not exist
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                         pg_get_viewdef                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.f4)::bigint > 0);
(1 row)

SELECT * FROM "test_modify_view_f1f2F3";
 f1 | f2 | F3 
----+----+----
  1 | 2  | 3
(1 row)

DROP VIEW "test_modify_view_f1f2F3";
DROP TABLE test_at_modify_view_column CASCADE;
-- --change
-- -- --test select *
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW test_modify_view_star AS select * from test_at_modify_view_column;
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 int;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
               pg_get_viewdef               
--------------------------------------------
 SELECT  * FROM test_at_modify_view_column;
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column c1 f1 int FIRST;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                           pg_get_viewdef                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f4, test_at_modify_view_column.f3, test_at_modify_view_column.f2, test_at_modify_view_column.f1 FROM test_at_modify_view_column;
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_star
-- -- --test select * with add column
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW test_modify_view_star AS select * from test_at_modify_view_column;
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20), ADD COLUMN f0 int; -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 int, ADD COLUMN f0 int;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                              pg_get_viewdef                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f4, test_at_modify_view_column.f3, test_at_modify_view_column.f2, test_at_modify_view_column.c1 AS f1 FROM test_at_modify_view_column;
(1 row)

SELECT * FROM test_modify_view_star;
 f4 | f3 | f2 | f1 
----+----+----+----
  4 | 3  | 2  |  1
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column c1 f1 int FIRST, ADD COLUMN f5 int FIRST;
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                           pg_get_viewdef                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f4, test_at_modify_view_column.f3, test_at_modify_view_column.f2, test_at_modify_view_column.f1 FROM test_at_modify_view_column;
(1 row)

SELECT * FROM test_modify_view_star;
 f4 | f3 | f2 | f1 
----+----+----+----
  4 | 3  | 2  |  1
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_star
-- -- --test select * special
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
create view test_modify_view_star(col1,col2) as
SELECT * FROM
(
    SELECT
        CAST(f1/10000 AS DECIMAL(18,2)),
        CAST(CAST(f4 AS DECIMAL(18,4))/f1*100 AS DECIMAL(18,2))
    FROM test_at_modify_view_column
);
SELECT * FROM test_modify_view_star;
 col1 |  col2  
------+--------
 0.00 | 400.00
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20);
SELECT pg_get_viewdef('test_modify_view_star'::regclass);
                                                                                                                                               pg_get_viewdef                                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT  * FROM (SELECT (((test_at_modify_view_column.c1)::bigint / 10000))::numeric(18,2) AS "numeric", ((((test_at_modify_view_column.f4)::numeric(18,4) / (test_at_modify_view_column.c1)::numeric) * (100)::numeric))::numeric(18,2) AS "numeric" FROM test_at_modify_view_column) __unnamed_subquery__;
(1 row)

SELECT * FROM test_modify_view_star;
 col1 |  col2  
------+--------
 0.00 | 400.00
(1 row)

ALTER TABLE test_at_modify_view_column CHANGE column c1 f1 int FIRST; -- ERROR
ERROR:  column reference "numeric" is ambiguous
LINE 1: ALTER TABLE test_at_modify_view_column CHANGE column c1 f1 i...
               ^
CONTEXT:  referenced column: col1
ALTER TABLE test_at_modify_view_column ADD COLUMN f5 int FIRST; -- ERROR
ERROR:  column reference "numeric" is ambiguous
LINE 1: ALTER TABLE test_at_modify_view_column ADD COLUMN f5 int FIR...
               ^
CONTEXT:  referenced column: col1
DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_star
-- -- --test CHANGE view column
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW test_modify_view_f1f2 WITH(security_barrier=TRUE) AS select F1,F2 from test_at_modify_view_column;
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 int;
SELECT pg_get_viewdef('test_modify_view_f1f2'::regclass);
                                               pg_get_viewdef                                               
------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.c1 AS f1, test_at_modify_view_column.f2 FROM test_at_modify_view_column;
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column c1 f1 int FIRST;
SELECT pg_get_viewdef('test_modify_view_f1f2'::regclass);
                                            pg_get_viewdef                                            
------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2 FROM test_at_modify_view_column;
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view test_modify_view_f1f2
-- -- --test view and column name
CREATE TABLE test_at_modify_view_column (f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(4, '3', '2', 1);
CREATE VIEW "test_modify_view_f1f2F3" AS select F1,F2,F3 AS "F3" from test_at_modify_view_column where f4 > 0;
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                    pg_get_viewdef                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE (test_at_modify_view_column.f4 > 0);
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 int;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                       pg_get_viewdef                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.c1 AS f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE (test_at_modify_view_column.f4 > 0);
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column f4 c4 varchar(20);
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                            pg_get_viewdef                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.c1 AS f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.c4)::bigint > 0);
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column c4 f4 int AFTER c1;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                            pg_get_viewdef                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.c1 AS f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.f4)::bigint > 0);
(1 row)

DROP TABLE test_at_modify_view_column CASCADE;
NOTICE:  drop cascades to view "test_modify_view_f1f2F3"
-- -- --test drop column
CREATE TABLE test_at_modify_view_column (f5 int, f4 int primary key, f3 text, f2 text, f1 int unique);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_at_modify_view_column_pkey" for table "test_at_modify_view_column"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_at_modify_view_column_f1_key" for table "test_at_modify_view_column"
INSERT INTO test_at_modify_view_column VALUES(5, 4, '3', '2', 1);
CREATE VIEW "test_modify_view_f1f2F3" AS select F1,F2,F3 AS "F3" from test_at_modify_view_column where f4 > 0;
ALTER TABLE test_at_modify_view_column  CHANGE column f1 c1 varchar(20); -- ERROR
ERROR:  cannot change data type of view column "f1" from integer to character varying(20)
ALTER TABLE test_at_modify_view_column  CHANGE column f4 c4 varchar(20), DROP COLUMN f5;
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                         pg_get_viewdef                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.c4)::bigint > 0);
(1 row)

SELECT * FROM "test_modify_view_f1f2F3";
 f1 | f2 | F3 
----+----+----
  1 | 2  | 3
(1 row)

ALTER TABLE test_at_modify_view_column  CHANGE column c4 f4 int AFTER f1, DROP COLUMN f5;
ERROR:  column "f5" of relation "test_at_modify_view_column" does not exist
SELECT pg_get_viewdef('"test_modify_view_f1f2F3"'::regclass);
                                                                                         pg_get_viewdef                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT test_at_modify_view_column.f1, test_at_modify_view_column.f2, test_at_modify_view_column.f3 AS "F3" FROM test_at_modify_view_column WHERE ((test_at_modify_view_column.c4)::bigint > 0);
(1 row)

SELECT * FROM "test_modify_view_f1f2F3";
 f1 | f2 | F3 
----+----+----
  1 | 2  | 3
(1 row)

DROP VIEW "test_modify_view_f1f2F3";
DROP TABLE test_at_modify_view_column CASCADE;
-- test MODIFY after ADD COLUMN DEFAULT
CREATE TABLE test_modify_after_add (
 c1 INT,
 value_column INT
);
insert into test_modify_after_add values (1,2);
ALTER TABLE test_modify_after_add ADD COLUMN c2 TIMESTAMP(5) default '2025-11-11 11:11:11';
select * from test_modify_after_add;
 c1 | value_column |            c2            
----+--------------+--------------------------
  1 |            2 | Tue Nov 11 11:11:11 2025
(1 row)

ALTER TABLE test_modify_after_add MODIFY column c2 TIMESTAMP(5);
select * from test_modify_after_add;
 c1 | value_column |            c2            
----+--------------+--------------------------
  1 |            2 | Tue Nov 11 11:11:11 2025
(1 row)

DROP TABLE test_modify_after_add;
-- END
RESET CURRENT_SCHEMA;
DROP SCHEMA atbdb_schema CASCADE;
\c regression
clean connection to all force for database atbdb;
drop database if exists atbdb;
