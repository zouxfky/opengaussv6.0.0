CREATE SCHEMA partition_a_db_schema;
SET CURRENT_SCHEMA TO partition_a_db_schema;
-- -----------------------------------test partitions clause with A compatibility
-- range with partitions clause
CREATE TABLE t_range_partitions_clause (a int, b int, c int)
PARTITION BY RANGE (a,b) PARTITIONS 3;
ERROR:  syntax error at or near ";"
LINE 2: PARTITION BY RANGE (a,b) PARTITIONS 3;
                                             ^
CREATE TABLE t_range_partitions_clause (a int, b int, c int)
PARTITION BY RANGE (a,b) PARTITIONS 3
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY RANGE (a,b) PARTITIONS 3
                                 ^
DETAIL:  range partition with partitions clause is supported only in B compatibility
-- list with partitions clause
CREATE TABLE t_list_partitions_clause (a int, b int, c int)
PARTITION BY LIST (a,b) PARTITIONS 3;
ERROR:  syntax error at or near ";"
LINE 2: PARTITION BY LIST (a,b) PARTITIONS 3;
                                            ^
CREATE TABLE t_list_partitions_clause (a int, b int, c int)
PARTITION BY LIST (a,b) PARTITIONS 3
(
    PARTITION p1 VALUES ((0,0)),
    PARTITION p2 VALUES ((1,1), (1,2)),
    PARTITION p3 VALUES ((2,1), (2,2), (2,3))
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY LIST (a,b) PARTITIONS 3
                                ^
DETAIL:  list partition with partitions clause is supported only in B compatibility
-- hash with partitions clause
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 3;
DROP TABLE t_hash_partitions_clause;
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 0;
ERROR:  Invalid number of partitions
LINE 2: PARTITION BY HASH(a) PARTITIONS 0;
                                        ^
DETAIL:  partitions number must be a positive integer
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS -1;
ERROR:  syntax error at or near "-"
LINE 2: PARTITION BY HASH(a) PARTITIONS -1;
                                        ^
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 2.5;
ERROR:  syntax error at or near "2.5"
LINE 2: PARTITION BY HASH(a) PARTITIONS 2.5;
                                        ^
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS '5';
ERROR:  syntax error at or near "'5'"
LINE 2: PARTITION BY HASH(a) PARTITIONS '5';
                                        ^
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 1048576;
ERROR:  Invalid number of partitions
DETAIL:  partitions number '1048576' cannot be greater than 1048575
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 3
(
    PARTITION p1,
    PARTITION p2,
    PARTITION p3
);
DROP TABLE t_hash_partitions_clause;
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 4
(
    PARTITION p1,
    PARTITION p2,
    PARTITION p3
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '4'
-- range-range with subpartitions clause
CREATE TABLE t_range_range_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) PARTITIONS 2 SUBPARTITION BY RANGE(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY RANGE (a) PARTITIONS 2 SUBPARTITION BY RANGE(c)
                               ^
DETAIL:  range partition with partitions clause is supported only in B compatibility
CREATE TABLE t_range_range_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY RANGE(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
ERROR:  syntax error at or near "SUBPARTITIONS"
LINE 2: PARTITION BY RANGE (a) SUBPARTITION BY RANGE(c) SUBPARTITION...
                                                        ^
-- range-list with subpartitions clause
CREATE TABLE t_range_list_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) PARTITIONS 2 SUBPARTITION BY LIST(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY RANGE (a) PARTITIONS 2 SUBPARTITION BY LIST(c)
                               ^
DETAIL:  range partition with partitions clause is supported only in B compatibility
CREATE TABLE t_range_list_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY LIST(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
ERROR:  syntax error at or near "SUBPARTITIONS"
LINE 2: PARTITION BY RANGE (a) SUBPARTITION BY LIST(c) SUBPARTITIONS...
                                                       ^
-- range-hash with subpartitions clause
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 0
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  Invalid number of partitions
LINE 2: ...RTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 0
                                                                      ^
DETAIL:  subpartitions number must be a positive integer
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 0.2E+1
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  syntax error at or near "0.2E+1"
LINE 2: ...ON BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 0.2E+1
                                                                 ^
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2.5
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  syntax error at or near "2.5"
LINE 2: ...ITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2.5
                                                                    ^
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS '5'
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  syntax error at or near "'5'"
LINE 2: ...ITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS '5'
                                                                    ^
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 1048576
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  Invalid number of partitions
DETAIL:  subpartitions number '1048576' cannot be greater than 1048575
-- list-range with subpartitions clause
CREATE TABLE t_hash_range_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST (a) SUBPARTITION BY RANGE(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES (100) (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE,MAXVALUE)
    ),
    PARTITION p2 VALUES (200) (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE,MAXVALUE)
    )
);
ERROR:  syntax error at or near "SUBPARTITIONS"
LINE 2: PARTITION BY LIST (a) SUBPARTITION BY RANGE(c) SUBPARTITIONS...
                                                       ^
-- list-list with subpartitions clause
CREATE TABLE t_hash_list_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST (a) SUBPARTITION BY LIST(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES (100) (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 VALUES (200) (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
ERROR:  syntax error at or near "SUBPARTITIONS"
LINE 2: PARTITION BY LIST (a) SUBPARTITION BY LIST(c) SUBPARTITIONS ...
                                                      ^
-- list-hash with subpartitions clause
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES (100),
    PARTITION p2 VALUES (200)
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST (a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 2;
ERROR:  syntax error at or near ";"
LINE 2: ...ST (a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 2;
                                                                      ^
-- hash-range with subpartitions clause
CREATE TABLE t_hash_range_subpartitions_clause (a int, b int, c int)
PARTITION BY HASH (a) PARTITIONS 2 SUBPARTITION BY RANGE(c)
(
    PARTITION p1 (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
DROP TABLE t_hash_range_subpartitions_clause;
-- hash-list with subpartitions clause
CREATE TABLE t_hash_list_subpartitions_clause (a int, b int, c int)
PARTITION BY HASH (a) PARTITIONS 2 SUBPARTITION BY LIST(c)
(
    PARTITION p1 (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
DROP TABLE t_hash_list_subpartitions_clause;
-- hash-hash with subpartitions clause
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY HASH (a) PARTITIONS 2 SUBPARTITION BY HASH(c)
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY HASH (a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY HASH (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY HASH (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1,
    PARTITION p2
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE (a int, b int, c int)
PARTITION BY HASH(a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 2;
SELECT pg_get_tabledef('T_HASH_HASH_SUBPARTITIONS_CLAUSE');
                 pg_get_tabledef                 
-------------------------------------------------
 SET search_path = partition_a_db_schema;       +
 CREATE TABLE t_hash_hash_subpartitions_clause (+
     a integer,                                 +
     b integer,                                 +
     c integer                                  +
 )                                              +
 WITH (orientation=row, compression=no)         +
 PARTITION BY HASH (a) SUBPARTITION BY HASH (c) +
 (                                              +
     PARTITION p0                               +
     (                                          +
         SUBPARTITION p0sp0,                    +
         SUBPARTITION p0sp1                     +
     ),                                         +
     PARTITION p1                               +
     (                                          +
         SUBPARTITION p1sp0,                    +
         SUBPARTITION p1sp1                     +
     )                                          +
 )                                              +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE;
CREATE TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE (a int, b int, c int)
PARTITION BY HASH (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2;
DROP TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE;
CREATE TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE (a int, b int, c int)
PARTITION BY HASH (a) PARTITIONS 2 SUBPARTITION BY HASH(c);
DROP TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE;
CREATE TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE (a int, b int, c int)
PARTITION BY HASH (a) SUBPARTITION BY HASH(c);
SELECT pg_get_tabledef('T_HASH_HASH_SUBPARTITIONS_CLAUSE');
                 pg_get_tabledef                 
-------------------------------------------------
 SET search_path = partition_a_db_schema;       +
 CREATE TABLE t_hash_hash_subpartitions_clause (+
     a integer,                                 +
     b integer,                                 +
     c integer                                  +
 )                                              +
 WITH (orientation=row, compression=no)         +
 PARTITION BY HASH (a) SUBPARTITION BY HASH (c) +
 (                                              +
     PARTITION p0                               +
     (                                          +
         SUBPARTITION p0_subpartdefault1        +
     )                                          +
 )                                              +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE T_HASH_HASH_SUBPARTITIONS_CLAUSE;
CREATE TABLE T_HASH_PARTITIONS_CLAUSE (a int, b int, c int)
PARTITION BY HASH (a) PARTITIONS 2;
SELECT pg_get_tabledef('T_HASH_PARTITIONS_CLAUSE');
             pg_get_tabledef              
------------------------------------------
 SET search_path = partition_a_db_schema;+
 CREATE TABLE t_hash_partitions_clause ( +
     a integer,                          +
     b integer,                          +
     c integer                           +
 )                                       +
 WITH (orientation=row, compression=no)  +
 PARTITION BY HASH (a)                   +
 (                                       +
     PARTITION p0,                       +
     PARTITION p1                        +
 )                                       +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE T_HASH_PARTITIONS_CLAUSE;
CREATE TABLE T_HASH_PARTITIONS_CLAUSE (a int, b int, c int)
PARTITION BY HASH (a);
SELECT pg_get_tabledef('T_HASH_PARTITIONS_CLAUSE');
             pg_get_tabledef              
------------------------------------------
 SET search_path = partition_a_db_schema;+
 CREATE TABLE t_hash_partitions_clause ( +
     a integer,                          +
     b integer,                          +
     c integer                           +
 )                                       +
 WITH (orientation=row, compression=no)  +
 PARTITION BY HASH (a)                   +
 (                                       +
     PARTITION p0                        +
 )                                       +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE T_HASH_PARTITIONS_CLAUSE;
-- -----------------------------------test A compatibility syntax error
CREATE TABLE t_multi_keys_range (a int, b int, c int)
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200),
    PARTITION p3 VALUES LESS THAN (300),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
ERROR:  Un-support feature in current compatibility
LINE 7:     PARTITION p4 VALUES LESS THAN MAXVALUE
                                          ^
DETAIL:  MAXVALUE without parentheses is supported only in B compatibility
CREATE TABLE t_multi_keys_range (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a,b)
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (300,300),
    PARTITION p4 VALUES LESS THAN (400,MAXVALUE),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY RANGE COLUMNS(a,b)
                           ^
DETAIL:  COLUMNS is supported only in B compatibility
CREATE TABLE t_multi_keys_range (a int, b int, c int)
PARTITION BY RANGE (a,b) PARTITIONS 5
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (300,300),
    PARTITION p4 VALUES LESS THAN (400,MAXVALUE),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY RANGE (a,b) PARTITIONS 5
                                 ^
DETAIL:  range partition with partitions clause is supported only in B compatibility
CREATE TABLE t_multi_keys_list (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN ( (0,0), (NULL,NULL) ),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p3 VALUES IN ( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p4 VALUES IN ( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY LIST COLUMNS(a,b)
                          ^
DETAIL:  COLUMNS is supported only in B compatibility
CREATE TABLE t_multi_keys_list (a int, b int, c int)
PARTITION BY LIST (a,b)
(
    PARTITION p1 VALUES IN ( (0,0), (NULL,NULL) ),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p3 VALUES IN ( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p4 VALUES IN ( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
ERROR:  Un-support syntax in current compatibility
LINE 4:     PARTITION p1 VALUES IN ( (0,0), (NULL,NULL) ),
                                ^
DETAIL:  VALUES IN is supported only in B compatibility
CREATE TABLE t_multi_keys_list (a int, b int, c int)
PARTITION BY LIST (a,b) PARTITIONS 5
(
    PARTITION p1 VALUES ( (0,0), (NULL,NULL) ),
    PARTITION p2 VALUES ( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p3 VALUES ( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p4 VALUES ( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY LIST (a,b) PARTITIONS 5
                                ^
DETAIL:  list partition with partitions clause is supported only in B compatibility
CREATE TABLE t_part_by_key (a int, b int, c int)
PARTITION BY KEY(a)
(
    PARTITION p1,
    PARTITION p2,
    PARTITION p3,
    PARTITION p4,
    PARTITION p5
);
ERROR:  Un-support syntax in current compatibility
LINE 2: PARTITION BY KEY(a)
                     ^
DETAIL:  PARTITION BY KEY is supported only in B compatibility
CREATE TABLE t_multi_keys_list_tbspc (a int, b varchar(4), c int)
PARTITION BY LIST (a,b)
(
    PARTITION p1 VALUES ( (0,NULL) ) TABLESPACE = pg_default,
    PARTITION p2 VALUES ( (0,'1'), (0,'2'), (0,'3'), (1,'1'), (1,'2') )
);
DROP TABLE t_multi_keys_list_tbspc;
-- -----------------------------------test multi list keys with A compatibility
CREATE TABLE t_multi_keys_list_default (a int, b int, c int)
PARTITION BY LIST (a,b)
(
    PARTITION p1 VALUES ( DEFAULT ),
    PARTITION p2 VALUES ( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p3 VALUES ( (NULL,0), (2,1) ),
    PARTITION p4 VALUES ( (3,2), (NULL,NULL) ),
    PARTITION pd VALUES ( DEFAULT )
);
ERROR:  Partition table has multiple default partitions
CREATE TABLE t_multi_keys_list_default (a int, b varchar(4), c int)
PARTITION BY LIST (a,b)
(
    PARTITION p1 VALUES ( (0,NULL) ),
    PARTITION p2 VALUES ( (0,'1'), (0,'2'), (0,'3'), (1,'1'), (1,'2') ),
    PARTITION p3 VALUES ( (NULL,'0'), (2,'1') ),
    PARTITION p4 VALUES ( (3,'2'), (NULL,NULL) ),
    PARTITION pd VALUES ( DEFAULT )
);
CREATE INDEX t_multi_keys_list_default_idx_l ON t_multi_keys_list_default(a,b,c) LOCAL;
SELECT pg_get_tabledef('t_multi_keys_list_default'::regclass);
                                                                                                                    pg_get_tabledef                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_a_db_schema;                                                                                                                                                                                                             +
 CREATE TABLE t_multi_keys_list_default (                                                                                                                                                                                                             +
     a integer,                                                                                                                                                                                                                                       +
     b character varying(4),                                                                                                                                                                                                                          +
     c integer                                                                                                                                                                                                                                        +
 )                                                                                                                                                                                                                                                    +
 WITH (orientation=row, compression=no)                                                                                                                                                                                                               +
 PARTITION BY LIST (a, b)                                                                                                                                                                                                                             +
 (                                                                                                                                                                                                                                                    +
     PARTITION p2 VALUES ((0,'1'),(0,'2'),(0,'3'),(1,'1'),(1,'2')),                                                                                                                                                                                   +
     PARTITION p1 VALUES ((0,NULL)),                                                                                                                                                                                                                  +
     PARTITION p4 VALUES ((3,'2'),(NULL,NULL)),                                                                                                                                                                                                       +
     PARTITION pd VALUES (DEFAULT),                                                                                                                                                                                                                   +
     PARTITION p3 VALUES ((NULL,'0'),(2,'1'))                                                                                                                                                                                                         +
 )                                                                                                                                                                                                                                                    +
 ENABLE ROW MOVEMENT;                                                                                                                                                                                                                                 +
 CREATE INDEX t_multi_keys_list_default_idx_l ON t_multi_keys_list_default USING btree (a, b, c) LOCAL(PARTITION p3_a_b_c_idx, PARTITION p1_a_b_c_idx, PARTITION p2_a_b_c_idx, PARTITION p4_a_b_c_idx, PARTITION pd_a_b_c_idx)  TABLESPACE pg_default;
(1 row)

INSERT INTO t_multi_keys_list_default VALUES(0,NULL,0);
SELECT * FROM t_multi_keys_list_default PARTITION(p1) ORDER BY a,b;
 a | b | c 
---+---+---
 0 |   | 0
(1 row)

INSERT INTO t_multi_keys_list_default VALUES(0,'1',0);
INSERT INTO t_multi_keys_list_default VALUES(0,'2',0);
INSERT INTO t_multi_keys_list_default VALUES(0,'3',0);
INSERT INTO t_multi_keys_list_default VALUES(1,'1',0);
INSERT INTO t_multi_keys_list_default VALUES(1,'2',0);
SELECT * FROM t_multi_keys_list_default PARTITION(p2) ORDER BY a,b;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 1 | 1 | 0
 1 | 2 | 0
(5 rows)

INSERT INTO t_multi_keys_list_default VALUES(NULL,0,0);
INSERT INTO t_multi_keys_list_default VALUES(2,'1',0);
SELECT * FROM t_multi_keys_list_default PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
   | 0 | 0
(2 rows)

INSERT INTO t_multi_keys_list_default VALUES(3,'2',0);
INSERT INTO t_multi_keys_list_default VALUES(NULL,NULL,0);
SELECT * FROM t_multi_keys_list_default PARTITION(p4) ORDER BY a,b;
 a | b | c 
---+---+---
 3 | 2 | 0
   |   | 0
(2 rows)

INSERT INTO t_multi_keys_list_default VALUES(4,'4',4);
SELECT * FROM t_multi_keys_list_default PARTITION(pd) ORDER BY a,b;
 a | b | c 
---+---+---
 4 | 4 | 4
(1 row)

EXPLAIN (costs false)
SELECT a FROM t_multi_keys_list_default WHERE a IS NULL;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Partition Iterator
   Iterations: 3
   ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
         Recheck Cond: (a IS NULL)
         Selected Partitions:  1,4..5
         ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
               Index Cond: (a IS NULL)
               Selected Partitions:  1,4..5
(8 rows)

SELECT a FROM t_multi_keys_list_default WHERE a IS NULL;
 a 
---
  
  
(2 rows)

EXPLAIN (costs false)
SELECT a FROM t_multi_keys_list_default WHERE a = 0;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Partition Iterator
   Iterations: 3
   ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
         Recheck Cond: (a = 0)
         Selected Partitions:  2..3,5
         ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
               Index Cond: (a = 0)
               Selected Partitions:  2..3,5
(8 rows)

SELECT a FROM t_multi_keys_list_default WHERE a = 0;
 a 
---
 0
 0
 0
 0
(4 rows)

EXPLAIN (costs false)
SELECT b FROM t_multi_keys_list_default WHERE b IS NULL;
                       QUERY PLAN                        
---------------------------------------------------------
 Partition Iterator
   Iterations: 3
   ->  Partitioned Seq Scan on t_multi_keys_list_default
         Filter: (b IS NULL)
         Selected Partitions:  2,4..5
(5 rows)

SELECT b FROM t_multi_keys_list_default WHERE b IS NULL;
 b 
---
 
 
(2 rows)

EXPLAIN (costs false)
SELECT b FROM t_multi_keys_list_default WHERE b = '1';
                       QUERY PLAN                        
---------------------------------------------------------
 Partition Iterator
   Iterations: 3
   ->  Partitioned Seq Scan on t_multi_keys_list_default
         Filter: ((b)::text = '1'::text)
         Selected Partitions:  1,3,5
(5 rows)

SELECT b FROM t_multi_keys_list_default WHERE b = '1';
 b 
---
 1
 1
 1
(3 rows)

EXPLAIN (costs false)
SELECT a FROM t_multi_keys_list_default WHERE a = 4;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on t_multi_keys_list_default
   Recheck Cond: (a = 4)
   Selected Partitions:  5
   ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
         Index Cond: (a = 4)
         Selected Partitions:  5
(6 rows)

SELECT a FROM t_multi_keys_list_default WHERE a = 4;
 a 
---
 4
(1 row)

EXPLAIN (costs false)
SELECT a,b FROM t_multi_keys_list_default WHERE a < 1 ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: (a < 1)
               Selected Partitions:  1..5
(7 rows)

SELECT a,b FROM t_multi_keys_list_default WHERE a < 1 ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 0 | 2
 0 | 3
 0 | 
(4 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a,b) = (0,'1');
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
   Index Cond: ((a = 0) AND (b = '1'::text))
   Selected Partitions:  3
(3 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a,b) = (0,'1');
 a | b | c 
---+---+---
 0 | 1 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a,b) = (NULL,'0');
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a,b) = (NULL,'0');
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND b = '0';
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
   Index Cond: ((a IS NULL) AND (b = '0'::text))
   Selected Partitions:  1
(3 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND b = '0';
 a | b | c 
---+---+---
   | 0 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a IS NULL AND a = 0) AND b = '0' ORDER BY 1,2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Partition Iterator
   Iterations: 0
   ->  Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
         Index Cond: ((a IS NULL) AND (a = 0) AND (b = '0'::text))
         Selected Partitions:  NONE
(5 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a IS NULL AND a = 0) AND b = '0' ORDER BY 1,2;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a IS NULL OR a = 3) AND b = '2' ORDER BY 1,2;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: a
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: (((a IS NULL) AND ((b)::text = '2'::text)) OR ((a = 3) AND ((b)::text = '2'::text)))
               Selected Partitions:  4..5
               ->  BitmapOr
                     ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                           Index Cond: ((a IS NULL) AND ((b)::text = '2'::text))
                           Selected Partitions:  4..5
                     ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                           Index Cond: ((a = 3) AND ((b)::text = '2'::text))
                           Selected Partitions:  4..5
(14 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a IS NULL OR a = 3) AND b = '2' ORDER BY 1,2;
 a | b | c 
---+---+---
 3 | 2 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a IS NULL OR a IS NOT NULL) AND b = '0' ORDER BY 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort
   Sort Key: a
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: (((a IS NULL) OR (a IS NOT NULL)) AND ((b)::text = '0'::text))
               Selected Partitions:  1,5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a IS NULL OR a IS NOT NULL) AND b = '0' ORDER BY 1,2;
 a | b | c 
---+---+---
   | 0 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE b IS NOT NULL AND a = 0 ORDER BY 1,2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: b
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: ((a = 0) AND (b IS NOT NULL))
               Selected Partitions:  3,5
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                     Index Cond: ((a = 0) AND (b IS NOT NULL))
                     Selected Partitions:  3,5
(10 rows)

SELECT * FROM t_multi_keys_list_default WHERE b IS NOT NULL AND a = 0 ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
(3 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (b IS NOT NULL AND b = '1') AND a = 2 ORDER BY 1,2;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
   Index Cond: ((a = 2) AND (b IS NOT NULL) AND (b = '1'::text))
   Selected Partitions:  1
(3 rows)

SELECT * FROM t_multi_keys_list_default WHERE (b IS NOT NULL AND b = '1') AND a = 2 ORDER BY 1,2;
 a | b | c 
---+---+---
 2 | 1 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (b IS NOT NULL OR b = '0') AND a = 0 ORDER BY 1,2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: b
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: (a = 0)
               Filter: ((b IS NOT NULL) OR ((b)::text = '0'::text))
               Selected Partitions:  3,5
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                     Index Cond: (a = 0)
                     Selected Partitions:  3,5
(11 rows)

SELECT * FROM t_multi_keys_list_default WHERE (b IS NOT NULL OR b = '0') AND a = 0 ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
(3 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND b IS NULL ORDER BY 1,2;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
   Index Cond: ((a IS NULL) AND (b IS NULL))
   Selected Partitions:  4
(3 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND b IS NULL ORDER BY 1,2;
 a | b | c 
---+---+---
   |   | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND b IS NOT NULL ORDER BY 1,2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: ((a IS NULL) AND (b IS NOT NULL))
               Selected Partitions:  1,4..5
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                     Index Cond: ((a IS NULL) AND (b IS NOT NULL))
                     Selected Partitions:  1,4..5
(10 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND b IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
   | 0 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL AND b IS NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NOT NULL) AND (b IS NULL))
               Selected Partitions:  2,4..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL AND b IS NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 |   | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL AND b IS NOT NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 4
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NOT NULL) AND (b IS NOT NULL))
               Selected Partitions:  1,3..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL AND b IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
(8 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR b IS NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 4
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NULL) OR (b IS NULL))
               Selected Partitions:  1..2,4..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR b IS NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 |   | 0
   | 0 | 0
   |   | 0
(3 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR b IS NOT NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 4
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NULL) OR (b IS NOT NULL))
               Selected Partitions:  1,3..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR b IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
   | 0 | 0
   |   | 0
(10 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL OR b IS NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NOT NULL) OR (b IS NULL))
               Selected Partitions:  1..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL OR b IS NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
   |   | 0
(10 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL OR b IS NOT NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NOT NULL) OR (b IS NOT NULL))
               Selected Partitions:  1..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL OR b IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
   | 0 | 0
(10 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR a IS NULL ORDER BY 1,2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: (a IS NULL)
               Selected Partitions:  1,4..5
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                     Index Cond: (a IS NULL)
                     Selected Partitions:  1,4..5
(10 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR a IS NULL ORDER BY 1,2;
 a | b | c 
---+---+---
   | 0 | 0
   |   | 0
(2 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND a IS NULL ORDER BY 1,2;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
               Index Cond: ((a IS NULL) AND (a IS NULL))
               Selected Partitions:  1,4..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND a IS NULL ORDER BY 1,2;
 a | b | c 
---+---+---
   | 0 | 0
   |   | 0
(2 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL OR a IS NOT NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: (a IS NOT NULL)
               Selected Partitions:  1..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL OR a IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
(9 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL AND a IS NOT NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NOT NULL) AND (a IS NOT NULL))
               Selected Partitions:  1..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NOT NULL AND a IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
(9 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR a IS NOT NULL ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a IS NULL) OR (a IS NOT NULL))
               Selected Partitions:  1..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL OR a IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
 1 | 1 | 0
 1 | 2 | 0
 2 | 1 | 0
 3 | 2 | 0
 4 | 4 | 4
   | 0 | 0
   |   | 0
(11 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND a IS NOT NULL ORDER BY 1,2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: ((a IS NULL) AND (a IS NOT NULL))
               Selected Partitions:  1,4..5
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                     Index Cond: ((a IS NULL) AND (a IS NOT NULL))
                     Selected Partitions:  1,4..5
(10 rows)

SELECT * FROM t_multi_keys_list_default WHERE a IS NULL AND a IS NOT NULL ORDER BY 1,2;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a = 0 OR b = '0' ORDER BY 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 4
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((a = 0) OR ((b)::text = '0'::text))
               Selected Partitions:  1..3,5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE a = 0 OR b = '0' ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
   | 0 | 0
(5 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a,b) IN ((NULL,'0'), (3,'2')) ORDER BY 1,2;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
   Index Cond: ((a = 3) AND (b = '2'::text))
   Selected Partitions:  4
(3 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a,b) IN ((NULL,'0'), (3,'2')) ORDER BY 1,2;
 a | b | c 
---+---+---
 3 | 2 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE (a,b) =ANY(ARRAY[(2,'1'::varchar), (3,'2'::varchar)]) ORDER BY 1,2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 5
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: (ROW(a, b) = ANY (ARRAY[ROW(2, '1'::character varying), ROW(3, '2'::character varying)]))
               Selected Partitions:  1..5
(7 rows)

SELECT * FROM t_multi_keys_list_default WHERE (a,b) =ANY(ARRAY[(2,'1'::varchar), (3,'2'::varchar)]) ORDER BY 1,2;
 a | b | c 
---+---+---
 2 | 1 | 0
 3 | 2 | 0
(2 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_default WHERE a =ANY(ARRAY[2, 3]) ORDER BY 1,2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_default
               Recheck Cond: (a = ANY ('{2,3}'::integer[]))
               Selected Partitions:  1,4..5
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_default_idx_l
                     Index Cond: (a = ANY ('{2,3}'::integer[]))
                     Selected Partitions:  1,4..5
(10 rows)

SELECT * FROM t_multi_keys_list_default WHERE a =ANY(ARRAY[2, 3]) ORDER BY 1,2;
 a | b | c 
---+---+---
 2 | 1 | 0
 3 | 2 | 0
(2 rows)

PREPARE part_bdb_stmt(varchar) as SELECT a,b FROM t_multi_keys_list_default WHERE b = $1 ORDER BY 1,2;
EXPLAIN (costs false)
EXECUTE part_bdb_stmt('3');
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a
   ->  Partition Iterator
         Iterations: PART
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: ((b)::text = ($1)::text)
               Selected Partitions:  PART
(7 rows)

EXECUTE part_bdb_stmt('1');
 a | b 
---+---
 0 | 1
 1 | 1
 2 | 1
(3 rows)

EXECUTE part_bdb_stmt('2');
 a | b 
---+---
 0 | 2
 1 | 2
 3 | 2
(3 rows)

PREPARE part_bdb_stmt1(int) as SELECT a,b FROM t_multi_keys_list_default WHERE a != $1 ORDER BY 1,2;
EXPLAIN (costs false)
EXECUTE part_bdb_stmt1(3);
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: PART
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: (a <> $1)
               Selected Partitions:  PART
(7 rows)

EXECUTE part_bdb_stmt1(1);
 a | b 
---+---
 0 | 1
 0 | 2
 0 | 3
 0 | 
 2 | 1
 3 | 2
 4 | 4
(7 rows)

EXECUTE part_bdb_stmt1(2);
 a | b 
---+---
 0 | 1
 0 | 2
 0 | 3
 0 | 
 1 | 1
 1 | 2
 3 | 2
 4 | 4
(8 rows)

PREPARE part_bdb_stmt2(int) as SELECT a,b FROM t_multi_keys_list_default WHERE a >= $1 ORDER BY 1,2;
EXPLAIN (costs false)
EXECUTE part_bdb_stmt2(3);
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: PART
         ->  Partitioned Seq Scan on t_multi_keys_list_default
               Filter: (a >= $1)
               Selected Partitions:  PART
(7 rows)

EXECUTE part_bdb_stmt2(1);
 a | b 
---+---
 1 | 1
 1 | 2
 2 | 1
 3 | 2
 4 | 4
(5 rows)

EXECUTE part_bdb_stmt2(2);
 a | b 
---+---
 2 | 1
 3 | 2
 4 | 4
(3 rows)

PREPARE part_bdb_stmt3(int, varchar) as SELECT a,b FROM t_multi_keys_list_default WHERE (a,b) = ($1,$2);
EXPLAIN (costs false)
EXECUTE part_bdb_stmt3(0,'1');
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Partition Iterator
   Iterations: PART
   ->  Partitioned Index Only Scan using t_multi_keys_list_default_idx_l on t_multi_keys_list_default
         Index Cond: ((a = $1) AND (b = ($2)::text))
         Selected Partitions:  PART
(5 rows)

EXECUTE part_bdb_stmt3(0,'1');
 a | b 
---+---
 0 | 1
(1 row)

EXECUTE part_bdb_stmt3(3,'2');
 a | b 
---+---
 3 | 2
(1 row)

UPDATE t_multi_keys_list_default SET a=2, b='1' where a=1 and b='1';
SELECT * FROM t_multi_keys_list_default PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
   | 0 | 0
(3 rows)

UPDATE t_multi_keys_list_default SET a=NULL, b='0' where a=1 and b='2';
SELECT * FROM t_multi_keys_list_default PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
   | 0 | 0
   | 0 | 0
(4 rows)

EXPLAIN (costs false)
DELETE t_multi_keys_list_default PARTITION(p3) where b = '0';
                       QUERY PLAN                        
---------------------------------------------------------
 Delete on t_multi_keys_list_default
   ->  Partitioned Seq Scan on t_multi_keys_list_default
         Filter: ((b)::text = '0'::text)
         Selected Partitions:  1
(4 rows)

DELETE t_multi_keys_list_default PARTITION(p3) where b = '0';
SELECT * FROM t_multi_keys_list_default PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
(2 rows)

EXPLAIN (costs false)
DELETE t_multi_keys_list_default PARTITION FOR(0,NULL);
                       QUERY PLAN                        
---------------------------------------------------------
 Delete on t_multi_keys_list_default
   ->  Partitioned Seq Scan on t_multi_keys_list_default
         Selected Partitions:  2
(3 rows)

DELETE t_multi_keys_list_default PARTITION FOR(0,NULL);
SELECT * FROM t_multi_keys_list_default PARTITION(p1) ORDER BY a,b;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (costs false)
DELETE t_multi_keys_list_default PARTITION FOR(0,'3');
                       QUERY PLAN                        
---------------------------------------------------------
 Delete on t_multi_keys_list_default
   ->  Partitioned Seq Scan on t_multi_keys_list_default
         Selected Partitions:  3
(3 rows)

DELETE t_multi_keys_list_default PARTITION FOR(0,'3');
SELECT * FROM t_multi_keys_list_default PARTITION(p2) ORDER BY a,b;
 a | b | c 
---+---+---
(0 rows)

-- alter table partition
CREATE INDEX test_multi_list_key_gi on t_multi_keys_list_default(c);
CREATE TABLESPACE part_adb_temp_tbspc RELATIVE LOCATION 'tablespace/part_adb_temp_tbspc';
ALTER TABLE t_multi_keys_list_default MOVE PARTITION FOR(0,NULL) TABLESPACE part_adb_temp_tbspc;
SELECT pg_get_tabledef('t_multi_keys_list_default'::regclass);
                                                                                                                    pg_get_tabledef                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_a_db_schema;                                                                                                                                                                                                             +
 CREATE TABLE t_multi_keys_list_default (                                                                                                                                                                                                             +
     a integer,                                                                                                                                                                                                                                       +
     b character varying(4),                                                                                                                                                                                                                          +
     c integer                                                                                                                                                                                                                                        +
 )                                                                                                                                                                                                                                                    +
 WITH (orientation=row, compression=no)                                                                                                                                                                                                               +
 PARTITION BY LIST (a, b)                                                                                                                                                                                                                             +
 (                                                                                                                                                                                                                                                    +
     PARTITION p2 VALUES ((0,'1'),(0,'2'),(0,'3'),(1,'1'),(1,'2')),                                                                                                                                                                                   +
     PARTITION p1 VALUES ((0,NULL)) TABLESPACE part_adb_temp_tbspc,                                                                                                                                                                                   +
     PARTITION p4 VALUES ((3,'2'),(NULL,NULL)),                                                                                                                                                                                                       +
     PARTITION pd VALUES (DEFAULT),                                                                                                                                                                                                                   +
     PARTITION p3 VALUES ((NULL,'0'),(2,'1'))                                                                                                                                                                                                         +
 )                                                                                                                                                                                                                                                    +
 ENABLE ROW MOVEMENT;                                                                                                                                                                                                                                 +
 CREATE INDEX test_multi_list_key_gi ON t_multi_keys_list_default USING btree (c) TABLESPACE pg_default;                                                                                                                                              +
 CREATE INDEX t_multi_keys_list_default_idx_l ON t_multi_keys_list_default USING btree (a, b, c) LOCAL(PARTITION p3_a_b_c_idx, PARTITION p1_a_b_c_idx, PARTITION p2_a_b_c_idx, PARTITION p4_a_b_c_idx, PARTITION pd_a_b_c_idx)  TABLESPACE pg_default;
(1 row)

CREATE TABLE t_alter_partition_temp (a int, b varchar(4), c int);
INSERT INTO t_alter_partition_temp VALUES(NULL,'0',1);
INSERT INTO t_alter_partition_temp VALUES(2,'1',2);
CREATE INDEX t_alter_partition_temp_idx_l ON t_alter_partition_temp(a,b,c);
SELECT * FROM t_alter_partition_temp ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 2
   | 0 | 1
(2 rows)

SELECT * FROM t_multi_keys_list_default PARTITION(p3) ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
(2 rows)

ALTER TABLE t_multi_keys_list_default EXCHANGE PARTITION (p3) WITH TABLE t_alter_partition_temp UPDATE GLOBAL INDEX;
SELECT * FROM t_alter_partition_temp ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
(2 rows)

SELECT * FROM t_multi_keys_list_default PARTITION(p3) ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 2
   | 0 | 1
(2 rows)

DROP TABLE IF EXISTS t_alter_partition_temp;
ALTER TABLE t_multi_keys_list_default ADD PARTITION p5 VALUES ((2,1));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
ALTER TABLE t_multi_keys_list_default DROP PARTITION FOR (1,'5');
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
ALTER TABLE t_multi_keys_list_default DROP PARTITION FOR (2,'1') UPDATE GLOBAL INDEX;
SELECT * FROM t_multi_keys_list_default PARTITION FOR (1,'5') ORDER BY a,b;
ERROR:  Cannot find partition by the value
DETAIL:  N/A.
SELECT * FROM t_multi_keys_list_default PARTITION FOR (2,'1') ORDER BY a,b;
ERROR:  Cannot find partition by the value
DETAIL:  N/A.
ALTER TABLE t_multi_keys_list_default TRUNCATE PARTITION FOR (NULL,NULL) UPDATE GLOBAL INDEX;
SELECT * FROM t_multi_keys_list_default PARTITION FOR (NULL,NULL) ORDER BY a,b;
 a | b | c 
---+---+---
(0 rows)

ALTER TABLE t_multi_keys_list_default RENAME PARTITION FOR (0,NULL) TO p0;
ALTER TABLE t_multi_keys_list_default ADD PARTITION pd VALUES (DEFAULT);
SELECT pg_get_tabledef('t_multi_keys_list_default'::regclass);
                                                                                                        pg_get_tabledef                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_a_db_schema;                                                                                                                                                                                     +
 CREATE TABLE t_multi_keys_list_default (                                                                                                                                                                                     +
     a integer,                                                                                                                                                                                                               +
     b character varying(4),                                                                                                                                                                                                  +
     c integer                                                                                                                                                                                                                +
 )                                                                                                                                                                                                                            +
 WITH (orientation=row, compression=no)                                                                                                                                                                                       +
 PARTITION BY LIST (a, b)                                                                                                                                                                                                     +
 (                                                                                                                                                                                                                            +
     PARTITION p2 VALUES ((0,'1'),(0,'2'),(0,'3'),(1,'1'),(1,'2')),                                                                                                                                                           +
     PARTITION p0 VALUES ((0,NULL)) TABLESPACE part_adb_temp_tbspc,                                                                                                                                                           +
     PARTITION p4 VALUES ((3,'2'),(NULL,NULL)),                                                                                                                                                                               +
     PARTITION pd VALUES (DEFAULT)                                                                                                                                                                                            +
 )                                                                                                                                                                                                                            +
 ENABLE ROW MOVEMENT;                                                                                                                                                                                                         +
 CREATE INDEX t_multi_keys_list_default_idx_l ON t_multi_keys_list_default USING btree (a, b, c) LOCAL(PARTITION p1_a_b_c_idx, PARTITION p2_a_b_c_idx, PARTITION p4_a_b_c_idx, PARTITION pd_a_b_c_idx)  TABLESPACE pg_default;
(1 row)

-- test views
SELECT table_name,partitioning_type,partition_count,partitioning_key_count,subpartitioning_type FROM MY_PART_TABLES WHERE table_name = 't_multi_keys_list_default' ORDER BY 1;
ERROR:  relation "my_part_tables" does not exist on datanode1
LINE 1: ...,partitioning_key_count,subpartitioning_type FROM MY_PART_TA...
                                                             ^
SELECT table_name,partition_name,high_value,subpartition_count FROM MY_TAB_PARTITIONS WHERE table_name = 't_multi_keys_list_default' ORDER BY 1,2;
ERROR:  relation "my_tab_partitions" does not exist on datanode1
LINE 1: ...partition_name,high_value,subpartition_count FROM MY_TAB_PAR...
                                                             ^
SELECT table_name,partition_name,subpartition_name,high_value,high_value_length FROM MY_TAB_SUBPARTITIONS WHERE table_name = 't_multi_keys_list_default' ORDER BY 1,2,3;
ERROR:  relation "my_tab_subpartitions" does not exist on datanode1
LINE 1: ...bpartition_name,high_value,high_value_length FROM MY_TAB_SUB...
                                                             ^
SELECT table_name,index_name,partition_count,partitioning_key_count,partitioning_type,subpartitioning_type FROM MY_PART_INDEXES WHERE table_name = 't_multi_keys_list_default' ORDER BY 1,2;
ERROR:  relation "my_part_indexes" does not exist on datanode1
LINE 1: ...count,partitioning_type,subpartitioning_type FROM MY_PART_IN...
                                                             ^
SELECT index_name,partition_name,high_value,high_value_length FROM MY_IND_PARTITIONS WHERE index_name = 't_multi_keys_list_default_idx_l' ORDER BY 1,2;
ERROR:  relation "my_ind_partitions" does not exist on datanode1
LINE 1: ...,partition_name,high_value,high_value_length FROM MY_IND_PAR...
                                                             ^
SELECT index_name,partition_name,subpartition_name,high_value,high_value_length FROM MY_IND_SUBPARTITIONS WHERE index_name = 't_multi_keys_list_default_idx_l' ORDER BY 1,2,3;
ERROR:  relation "my_ind_subpartitions" does not exist on datanode1
LINE 1: ...bpartition_name,high_value,high_value_length FROM MY_IND_SUB...
                                                             ^
-- test partition key value and datatype not matched
CREATE TABLE t_single_key_list_value (a int, b int, c int)
PARTITION BY LIST (a)
(
    PARTITION p1 VALUES ( 0 ),
    PARTITION p2 VALUES ( 1 ),
    PARTITION p3 VALUES ( 2, date '12-10-2010' )
); -- ERROR
ERROR:  list partition value in "p3" does not match datatype of partition key "a"
CREATE TABLE t_multi_keys_list_value (a int, b int, c int)
PARTITION BY LIST (a,b)
(
    PARTITION p1 VALUES ( (0,0) ),
    PARTITION p2 VALUES ( (0,1) ),
    PARTITION p3 VALUES ( (2,1), (NULL,date '12-10-2010') )
); -- ERROR
ERROR:  list partition value in "p3" does not match datatype of partition key "b"
DROP TABLE IF EXISTS t_multi_keys_list_default;
DROP TABLESPACE part_adb_temp_tbspc;
DROP SCHEMA partition_a_db_schema CASCADE;
-- -----------------------------------test with B compatibility
create database part_bdb WITH ENCODING 'UTF-8' dbcompatibility 'B';
\c part_bdb
CREATE SCHEMA partition_b_db_schema;
SET CURRENT_SCHEMA TO partition_b_db_schema;
-- -----------------------------------test partitions clause with B compatibility
-- range with partitions clause
CREATE TABLE t_range_partitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a,b) PARTITIONS 3;
ERROR:  syntax error at or near ";"
LINE 2: PARTITION BY RANGE COLUMNS(a,b) PARTITIONS 3;
                                                    ^
CREATE TABLE t_range_partitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a,b) PARTITIONS 3
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
DROP TABLE t_range_partitions_clause;
CREATE TABLE t_range_partitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a,b) PARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '2'
-- list with partitions clause
CREATE TABLE t_list_partitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b) PARTITIONS 3;
ERROR:  syntax error at or near ";"
LINE 2: PARTITION BY LIST COLUMNS(a,b) PARTITIONS 3;
                                                   ^
CREATE TABLE t_list_partitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b) PARTITIONS 3
(
    PARTITION p1 VALUES IN ((0,0)),
    PARTITION p2 VALUES IN ((1,1), (1,2)),
    PARTITION p3 VALUES IN ((2,1), (2,2), (2,3))
);
DROP TABLE t_list_partitions_clause;
CREATE TABLE t_list_partitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b) PARTITIONS 1
(
    PARTITION p1 VALUES IN ((0,0)),
    PARTITION p2 VALUES IN ((1,1), (1,2)),
    PARTITION p3 VALUES IN ((2,1), (2,2), (2,3))
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '1'
-- key with partitions clause
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS 3;
DROP TABLE t_hash_partitions_clause;
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS 0;
ERROR:  Invalid number of partitions
LINE 2: PARTITION BY KEY(a) PARTITIONS 0;
                                       ^
DETAIL:  partitions number must be a positive integer
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS -1;
ERROR:  syntax error at or near "-"
LINE 2: PARTITION BY KEY(a) PARTITIONS -1;
                                       ^
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS 2.5;
ERROR:  syntax error at or near "2.5"
LINE 2: PARTITION BY KEY(a) PARTITIONS 2.5;
                                       ^
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS '5';
ERROR:  syntax error at or near "'5'"
LINE 2: PARTITION BY KEY(a) PARTITIONS '5';
                                       ^
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS 1048576;
ERROR:  Invalid number of partitions
DETAIL:  partitions number '1048576' cannot be greater than 1048575
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS 3
(
    PARTITION p1,
    PARTITION p2,
    PARTITION p3
);
DROP TABLE t_hash_partitions_clause;
CREATE TABLE t_hash_partitions_clause (a int, b int, c int)
PARTITION BY KEY(a) PARTITIONS 4
(
    PARTITION p1,
    PARTITION p2,
    PARTITION p3
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '4'
-- range-range with subpartitions clause
CREATE TABLE t_range_range_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY RANGE(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
DROP TABLE t_range_range_subpartitions_clause;
CREATE TABLE t_range_range_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 3 SUBPARTITION BY RANGE(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '3'
-- range-list with subpartitions clause
CREATE TABLE t_range_list_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY LIST(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
DROP TABLE t_range_list_subpartitions_clause;
CREATE TABLE t_range_list_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 1 SUBPARTITION BY LIST(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '1'
-- range-key with subpartitions clause
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY key(c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY key(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 0
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  Invalid number of partitions
LINE 2: ...N BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 0
                                                                      ^
DETAIL:  subpartitions number must be a positive integer
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 0.2E+1
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  syntax error at or near "0.2E+1"
LINE 2: ...RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 0.2E+1
                                                                 ^
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 2.5
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  syntax error at or near "2.5"
LINE 2: ...BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 2.5
                                                                    ^
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS '5'
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  syntax error at or near "'5'"
LINE 2: ...BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS '5'
                                                                    ^
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY key(c) SUBPARTITIONS 1048576
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  Invalid number of partitions
DETAIL:  subpartitions number '1048576' cannot be greater than 1048575
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY KEY(c) SUBPARTITIONS 3
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2,
        SUBPARTITION p1sub3
    )
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '2'
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY KEY(c) SUBPARTITIONS 3
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2,
        SUBPARTITION p1sub3
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2,
        SUBPARTITION p2sub3,
        SUBPARTITION p2sub4
    )
);
ERROR:  Invalid number of partitions
DETAIL:  The number of defined subpartitions in partition "p2" does not match the subpartitions number: 3
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY KEY(c) SUBPARTITIONS 3
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2,
        SUBPARTITION p2sub3
    )
);
DROP TABLE t_range_hash_subpartitions_clause;
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY KEY(c) SUBPARTITIONS 3
(
    PARTITION p1 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2,
        SUBPARTITION p1sp0
    )
);
ERROR:  duplicate subpartition name: "p1sp0"
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 11
(
    PARTITION p11111111111111111111111111111111111111111111111111111111111 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
ERROR:  identifier too long
DETAIL:  The subpartition name "p11111111111111111111111111111111111111111111111111111111111sp10" is too long
CREATE TABLE t_range_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 11
(
    PARTITION p1111111111111111111111111111111111111111111111111111111111 VALUES LESS THAN (100),
    PARTITION p2 VALUES LESS THAN (200)
);
SELECT pg_get_tabledef('t_range_hash_subpartitions_clause'::regclass);
                                         pg_get_tabledef                                          
--------------------------------------------------------------------------------------------------
 SET search_path = partition_b_db_schema;                                                        +
 CREATE TABLE t_range_hash_subpartitions_clause (                                                +
     a integer,                                                                                  +
     b integer,                                                                                  +
     c integer                                                                                   +
 )                                                                                               +
 WITH (orientation=row, compression=no)                                                          +
 PARTITION BY RANGE (a) SUBPARTITION BY HASH (c)                                                 +
 (                                                                                               +
     PARTITION p1111111111111111111111111111111111111111111111111111111111 VALUES LESS THAN (100)+
     (                                                                                           +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp0,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp1,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp2,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp3,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp4,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp5,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp6,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp7,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp8,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp9,            +
         SUBPARTITION p1111111111111111111111111111111111111111111111111111111111sp10            +
     ),                                                                                          +
     PARTITION p2 VALUES LESS THAN (200)                                                         +
     (                                                                                           +
         SUBPARTITION p2sp0,                                                                     +
         SUBPARTITION p2sp1,                                                                     +
         SUBPARTITION p2sp2,                                                                     +
         SUBPARTITION p2sp3,                                                                     +
         SUBPARTITION p2sp4,                                                                     +
         SUBPARTITION p2sp5,                                                                     +
         SUBPARTITION p2sp6,                                                                     +
         SUBPARTITION p2sp7,                                                                     +
         SUBPARTITION p2sp8,                                                                     +
         SUBPARTITION p2sp9,                                                                     +
         SUBPARTITION p2sp10                                                                     +
     )                                                                                           +
 )                                                                                               +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE t_range_hash_subpartitions_clause;
-- list-range with subpartitions clause
CREATE TABLE t_hash_range_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) PARTITIONS 2 SUBPARTITION BY RANGE(c)
(
    PARTITION p1 VALUES IN (100) (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 VALUES IN (200) (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
DROP TABLE t_hash_range_subpartitions_clause;
-- list-list with subpartitions clause
CREATE TABLE t_hash_list_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) PARTITIONS 2 SUBPARTITION BY LIST(c)
(
    PARTITION p1 VALUES IN (100) (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 VALUES IN (200) (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
DROP TABLE t_hash_list_subpartitions_clause;
-- list-key with subpartitions clause
CREATE TABLE t_list_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) PARTITIONS 2 SUBPARTITION BY KEY(c)
(
    PARTITION p1 VALUES IN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES IN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_list_hash_subpartitions_clause;
CREATE TABLE t_list_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) PARTITIONS 2 SUBPARTITION BY KEY(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES IN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES IN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_list_hash_subpartitions_clause;
CREATE TABLE t_list_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) SUBPARTITION BY KEY(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES IN (100) (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 VALUES IN (200) (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_list_hash_subpartitions_clause;
CREATE TABLE t_list_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) SUBPARTITION BY KEY(c) SUBPARTITIONS 2
(
    PARTITION p1 VALUES IN (100),
    PARTITION p2 VALUES IN (200)
);
DROP TABLE t_list_hash_subpartitions_clause;
CREATE TABLE t_list_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY LIST COLUMNS (a) SUBPARTITION BY KEY(c) SUBPARTITIONS 2;
ERROR:  syntax error at or near ";"
LINE 2: ... BY LIST COLUMNS (a) SUBPARTITION BY KEY(c) SUBPARTITIONS 2;
                                                                      ^
-- key-range with subpartitions clause
CREATE TABLE t_hash_range_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) PARTITIONS 2 SUBPARTITION BY RANGE(c)
(
    PARTITION p1 (
        SUBPARTITION p1sub1 VALUES LESS THAN (100),
        SUBPARTITION p1sub2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1 VALUES LESS THAN (100),
        SUBPARTITION p2sub2 VALUES LESS THAN (MAXVALUE)
    )
);
DROP TABLE t_hash_range_subpartitions_clause;
-- key-list with subpartitions clause
CREATE TABLE t_hash_list_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) PARTITIONS 2 SUBPARTITION BY LIST(c)
(
    PARTITION p1 (
        SUBPARTITION p1sub1 VALUES (0),
        SUBPARTITION p1sub2 VALUES (1)
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1 VALUES (0),
        SUBPARTITION p2sub2 VALUES (1)
    )
);
DROP TABLE t_hash_list_subpartitions_clause;
-- key-hash with subpartitions clause
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) PARTITIONS 2 SUBPARTITION BY HASH(c)
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) PARTITIONS 1 SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
ERROR:  Invalid number of partitions
DETAIL:  the number of defined partitions does not match the partitions number '1'
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) PARTITIONS 2 SUBPARTITION BY HASH(c) SUBPARTITIONS 3
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
ERROR:  Invalid number of partitions
DETAIL:  The number of defined subpartitions in partition "p1" does not match the subpartitions number: 3
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1 (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    PARTITION p2 (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
DROP TABLE t_hash_hash_subpartitions_clause;
CREATE TABLE t_hash_hash_subpartitions_clause (a int, b int, c int)
PARTITION BY KEY (a) SUBPARTITION BY HASH(c) SUBPARTITIONS 2
(
    PARTITION p1,
    PARTITION p2
);
DROP TABLE t_hash_hash_subpartitions_clause;
-- test the key of partition and subpartition is same column
CREATE TABLE t_single_key_range_subpart(id int, birthdate int)
    PARTITION BY RANGE (birthdate)
    SUBPARTITION BY HASH (birthdate)
    SUBPARTITIONS 2 (
    PARTITION p0 VALUES LESS THAN (1990),
    PARTITION p1 VALUES LESS THAN (2000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);
DROP TABLE IF EXISTS t_single_key_range_subpart;
-- --------------------------------------------------------test range columns syntax with B compatibility
CREATE TABLE t_single_key_range (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a)
(
    PARTITION p1 VALUES LESS THAN (100) TABLESPACE = pg_default,
    PARTITION p2 VALUES LESS THAN (200),
    PARTITION p3 VALUES LESS THAN (300),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
SELECT pg_get_tabledef('t_single_key_range'::regclass);
               pg_get_tabledef                
----------------------------------------------
 SET search_path = partition_b_db_schema;    +
 CREATE TABLE t_single_key_range (           +
     a integer,                              +
     b integer,                              +
     c integer                               +
 )                                           +
 WITH (orientation=row, compression=no)      +
 PARTITION BY RANGE (a)                      +
 (                                           +
     PARTITION p1 VALUES LESS THAN (100),    +
     PARTITION p2 VALUES LESS THAN (200),    +
     PARTITION p3 VALUES LESS THAN (300),    +
     PARTITION p4 VALUES LESS THAN (MAXVALUE)+
 )                                           +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE IF EXISTS t_single_key_range;
-- error
CREATE TABLE t_multi_keys_range (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a,b)
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (300,300),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
ERROR:  partition bound list contains too few elements
CREATE TABLE t_multi_keys_range (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a,b)
(
    PARTITION p1 VALUES LESS THAN (100,100),
    PARTITION p2 VALUES LESS THAN (200,200),
    PARTITION p3 VALUES LESS THAN (300,300),
    PARTITION p4 VALUES LESS THAN (400,MAXVALUE),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
\d+ t_multi_keys_range
          Table "partition_b_db_schema.t_multi_keys_range"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
 c      | integer |           | plain   |              | 
Partition By RANGE(a, b)
Number of partitions: 5 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

SELECT pg_get_tabledef('t_multi_keys_range'::regclass);
                    pg_get_tabledef                     
--------------------------------------------------------
 SET search_path = partition_b_db_schema;              +
 CREATE TABLE t_multi_keys_range (                     +
     a integer,                                        +
     b integer,                                        +
     c integer                                         +
 )                                                     +
 WITH (orientation=row, compression=no)                +
 PARTITION BY RANGE (a, b)                             +
 (                                                     +
     PARTITION p1 VALUES LESS THAN (100, 100),         +
     PARTITION p2 VALUES LESS THAN (200, 200),         +
     PARTITION p3 VALUES LESS THAN (300, 300),         +
     PARTITION p4 VALUES LESS THAN (400, MAXVALUE),    +
     PARTITION p5 VALUES LESS THAN (MAXVALUE, MAXVALUE)+
 )                                                     +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE IF EXISTS t_multi_keys_range;
-- --------------------------------------------------------test number of columns
CREATE TABLE t_multi_keys_range_num (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY RANGE COLUMNS(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)
(
    PARTITION p1 VALUES LESS THAN (100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p2 VALUES LESS THAN (200,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p3 VALUES LESS THAN (300,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p4 VALUES LESS THAN (400,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)
);
ERROR:  too many partition keys for partitioned table
HINT:  Partittion key columns can not be more than 16
CREATE TABLE t_multi_keys_range_num (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY RANGE COLUMNS(a,b,c,d)
(
    PARTITION p1 VALUES LESS THAN (100,100,100,100),
    PARTITION p2 VALUES LESS THAN (200,100,100,100),
    PARTITION p3 VALUES LESS THAN (300,100,100),
    PARTITION p4 VALUES LESS THAN (400,100,100,100),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,100,100,100)
);
ERROR:  partition bound list contains too few elements
CREATE TABLE t_multi_keys_range_num (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY RANGE COLUMNS(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
(
    PARTITION p1 VALUES LESS THAN (100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p2 VALUES LESS THAN (200,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p3 VALUES LESS THAN (300,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p4 VALUES LESS THAN (400,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)
);
DROP TABLE IF EXISTS t_multi_keys_range_num;
-- --------------------------------------------------------test key partition with B compatibility
CREATE TABLE t_part_by_key (a int, b int, c int)
PARTITION BY KEY(a)
(
    PARTITION p1 TABLESPACE = pg_default,
    PARTITION p2,
    PARTITION p3,
    PARTITION p4,
    PARTITION p5
);
\d+ t_part_by_key
             Table "partition_b_db_schema.t_part_by_key"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
 c      | integer |           | plain   |              | 
Partition By HASH(a)
Number of partitions: 5 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

SELECT pg_get_tabledef('t_part_by_key'::regclass);
             pg_get_tabledef              
------------------------------------------
 SET search_path = partition_b_db_schema;+
 CREATE TABLE t_part_by_key (            +
     a integer,                          +
     b integer,                          +
     c integer                           +
 )                                       +
 WITH (orientation=row, compression=no)  +
 PARTITION BY HASH (a)                   +
 (                                       +
     PARTITION p1,                       +
     PARTITION p2,                       +
     PARTITION p3,                       +
     PARTITION p4,                       +
     PARTITION p5                        +
 )                                       +
 ENABLE ROW MOVEMENT;
(1 row)

DROP TABLE IF EXISTS t_part_by_key;
CREATE TABLE t_part_by_key_num (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY KEY(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
(
    PARTITION p1,
    PARTITION p2,
    PARTITION p3,
    PARTITION p4,
    PARTITION p5
);
ERROR:  Un-support feature
DETAIL:  The partition key's length should be 1.
-- --------------------------------------------------------test list partition with B compatibility
-- errors
CREATE TABLE t_multi_keys_list_err (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
(
    PARTITION p1 VALUES IN (100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p2 VALUES IN (200,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p3 VALUES IN (300,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100),
    PARTITION p4 VALUES IN (400,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)
);
ERROR:  Invalid partition values
DETAIL:  list partition values in "p1" does not match the number of partition keys
CREATE TABLE t_multi_keys_list_err (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d)
(
    PARTITION p1 VALUES IN (100,100,100,100),
    PARTITION p2 VALUES IN (200,100,100,100),
    PARTITION p3 VALUES IN (300,100,100,100),
    PARTITION p4 VALUES IN (400,100,100,100)
);
ERROR:  Invalid partition values
DETAIL:  list partition values in "p1" does not match the number of partition keys
CREATE TABLE t_multi_keys_list_err (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d)
(
    PARTITION p1 VALUES IN ((100,100,100,100)),
    PARTITION p2 VALUES IN ((200,100,100,100)),
    PARTITION p3 VALUES IN ((300,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p4 VALUES IN ((400,100,100,100))
);
ERROR:  Invalid partition values
DETAIL:  list partition values in "p3" does not match the number of partition keys
CREATE TABLE t_multi_keys_list_err (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d)
(
    PARTITION p1 VALUES IN ((100,100,NULL,100),(100,100,NULL,100)),
    PARTITION p2 VALUES IN ((200,200,100,100),(100,100,100,200)),
    PARTITION p3 VALUES IN ((300,300,100,100),(100,100,100,300)),
    PARTITION p4 VALUES IN ((400,400,100,100),(100,100,100,400))
);
ERROR:  list partition p1 has overlapped value
CREATE TABLE t_multi_keys_list_err (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d)
(
    PARTITION p1 VALUES IN ((100,100,NULL,100),(100,100,100,400)),
    PARTITION p2 VALUES IN ((200,200,100,100),(100,100,100,300)),
    PARTITION p3 VALUES IN ((300,300,100,100),(100,100,100,200)),
    PARTITION p4 VALUES IN ((400,400,100,100),(100,100,NULL,100))
);
ERROR:  list partition p1 and p4 has overlapped value
CREATE TABLE t_multi_keys_list_err (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN ( (0,MAXVALUE) ),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) )
);
ERROR:  syntax error at or near "MAXVALUE"
LINE 4:     PARTITION p1 VALUES IN ( (0,MAXVALUE) ),
                                        ^
CREATE TABLE t_multi_keys_list_err (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN ( (0,DEFAULT) ),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) )
);
ERROR:  syntax error at or near "DEFAULT"
LINE 4:     PARTITION p1 VALUES IN ( (0,DEFAULT) ),
                                        ^
CREATE TABLE t_multi_keys_list_err (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN (MAXVALUE),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) )
);
ERROR:  syntax error at or near "MAXVALUE"
LINE 4:     PARTITION p1 VALUES IN (MAXVALUE),
                                    ^
CREATE TABLE t_multi_keys_list_err (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN ( (NULL, NULL)),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,A), (1,1), (1,2) )
);
ERROR:  column "a" does not exist
LINE 5:     PARTITION p2 VALUES IN ( (0,1), (0,2), (0,A), (1,1), (1,...
                                                      ^
CREATE TABLE t_multi_keys_list_err (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)
(
    PARTITION p1 VALUES IN ((100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p2 VALUES IN ((200,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p3 VALUES IN ((300,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p4 VALUES IN ((400,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100))
);
ERROR:  too many partition keys for partitioned table
HINT:  Partittion key columns can not be more than 16
-- normal
CREATE TABLE t_multi_keys_list (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int)
PARTITION BY LIST COLUMNS(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
(
    PARTITION p1 VALUES IN ((100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p2 VALUES IN ((200,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p3 VALUES IN ((300,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100)),
    PARTITION p4 VALUES IN ((400,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100))
);
DROP TABLE IF EXISTS t_multi_keys_list;
CREATE TABLE t_multi_keys_list (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN ( (0,0) ) TABLESPACE = pg_default,
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p3 VALUES IN ( (2,0), (2,1) ),
    PARTITION p4 VALUES IN ( (3,2), (3,3) )
);
SELECT pg_get_tabledef('t_multi_keys_list'::regclass);
                     pg_get_tabledef                      
----------------------------------------------------------
 SET search_path = partition_b_db_schema;                +
 CREATE TABLE t_multi_keys_list (                        +
     a integer,                                          +
     b integer,                                          +
     c integer                                           +
 )                                                       +
 WITH (orientation=row, compression=no)                  +
 PARTITION BY LIST (a, b)                                +
 (                                                       +
     PARTITION p1 VALUES ((0,0)),                        +
     PARTITION p2 VALUES ((0,1),(0,2),(0,3),(1,1),(1,2)),+
     PARTITION p3 VALUES ((2,0),(2,1)),                  +
     PARTITION p4 VALUES ((3,2),(3,3))                   +
 )                                                       +
 ENABLE ROW MOVEMENT;
(1 row)

INSERT INTO t_multi_keys_list VALUES(0,0,0);
SELECT * FROM t_multi_keys_list PARTITION(p1) ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

INSERT INTO t_multi_keys_list VALUES(0,1,0);
INSERT INTO t_multi_keys_list VALUES(0,2,0);
INSERT INTO t_multi_keys_list VALUES(0,3,0);
INSERT INTO t_multi_keys_list VALUES(1,1,0);
INSERT INTO t_multi_keys_list VALUES(1,2,0);
SELECT * FROM t_multi_keys_list PARTITION(p2) ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 1 | 1 | 0
 1 | 2 | 0
(5 rows)

INSERT INTO t_multi_keys_list VALUES(2,0,0);
INSERT INTO t_multi_keys_list VALUES(2,1,0);
SELECT * FROM t_multi_keys_list PARTITION(p3) ORDER BY 1,2;
 a | b | c 
---+---+---
 2 | 0 | 0
 2 | 1 | 0
(2 rows)

INSERT INTO t_multi_keys_list VALUES(3,2,0);
INSERT INTO t_multi_keys_list VALUES(3,3,0);
SELECT * FROM t_multi_keys_list PARTITION(p4) ORDER BY 1,2;
 a | b | c 
---+---+---
 3 | 2 | 0
 3 | 3 | 0
(2 rows)

INSERT INTO t_multi_keys_list VALUES(4,4,4);
ERROR:  inserted partition key does not map to any table partition
DROP TABLE IF EXISTS t_multi_keys_list;
-- test with null keys
CREATE TABLE t_multi_keys_list_null (a int, b int, c int)
PARTITION BY LIST COLUMNS(a,b)
(
    PARTITION p1 VALUES IN ( (0,NULL) ),
    PARTITION p2 VALUES IN ( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p3 VALUES IN ( (NULL,0), (2,1) ),
    PARTITION p4 VALUES IN ( (3,2), (NULL,NULL) )
);
CREATE INDEX t_multi_keys_list_null_idx_l ON t_multi_keys_list_null(a,b,c) LOCAL;
SELECT pg_get_tabledef('t_multi_keys_list_null'::regclass);
                                                                                                     pg_get_tabledef                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_b_db_schema;                                                                                                                                                                               +
 CREATE TABLE t_multi_keys_list_null (                                                                                                                                                                                  +
     a integer,                                                                                                                                                                                                         +
     b integer,                                                                                                                                                                                                         +
     c integer                                                                                                                                                                                                          +
 )                                                                                                                                                                                                                      +
 WITH (orientation=row, compression=no)                                                                                                                                                                                 +
 PARTITION BY LIST (a, b)                                                                                                                                                                                               +
 (                                                                                                                                                                                                                      +
     PARTITION p2 VALUES ((0,1),(0,2),(0,3),(1,1),(1,2)),                                                                                                                                                               +
     PARTITION p1 VALUES ((0,NULL)),                                                                                                                                                                                    +
     PARTITION p4 VALUES ((3,2),(NULL,NULL)),                                                                                                                                                                           +
     PARTITION p3 VALUES ((NULL,0),(2,1))                                                                                                                                                                               +
 )                                                                                                                                                                                                                      +
 ENABLE ROW MOVEMENT;                                                                                                                                                                                                   +
 CREATE INDEX t_multi_keys_list_null_idx_l ON t_multi_keys_list_null USING btree (a, b, c) LOCAL(PARTITION p3_a_b_c_idx, PARTITION p1_a_b_c_idx, PARTITION p2_a_b_c_idx, PARTITION p4_a_b_c_idx)  TABLESPACE pg_default;
(1 row)

INSERT INTO t_multi_keys_list_null VALUES(0,NULL,0);
SELECT * FROM t_multi_keys_list_null PARTITION(p1) ORDER BY a,b;
 a | b | c 
---+---+---
 0 |   | 0
(1 row)

INSERT INTO t_multi_keys_list_null VALUES(0,1,0);
INSERT INTO t_multi_keys_list_null VALUES(0,2,0);
INSERT INTO t_multi_keys_list_null VALUES(0,3,0);
INSERT INTO t_multi_keys_list_null VALUES(1,1,0);
INSERT INTO t_multi_keys_list_null VALUES(1,2,0);
SELECT * FROM t_multi_keys_list_null PARTITION(p2) ORDER BY a,b;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 1 | 1 | 0
 1 | 2 | 0
(5 rows)

INSERT INTO t_multi_keys_list_null VALUES(NULL,0,0);
INSERT INTO t_multi_keys_list_null VALUES(2,1,0);
SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
   | 0 | 0
(2 rows)

INSERT INTO t_multi_keys_list_null VALUES(3,2,0);
INSERT INTO t_multi_keys_list_null VALUES(NULL,NULL,0);
SELECT * FROM t_multi_keys_list_null PARTITION(p4) ORDER BY a,b;
 a | b | c 
---+---+---
 3 | 2 | 0
   |   | 0
(2 rows)

INSERT INTO t_multi_keys_list_null VALUES(4,4,4);
ERROR:  inserted partition key does not map to any table partition
EXPLAIN (costs false)
SELECT a FROM t_multi_keys_list_null WHERE a IS NULL;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Partition Iterator
   Iterations: 2
   ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_null
         Recheck Cond: (a IS NULL)
         Selected Partitions:  1,4
         ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
               Index Cond: (a IS NULL)
               Selected Partitions:  1,4
(8 rows)

SELECT a FROM t_multi_keys_list_null WHERE a IS NULL;
 a 
---
  
  
(2 rows)

EXPLAIN (costs false)
SELECT a FROM t_multi_keys_list_null WHERE a = 0;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Partition Iterator
   Iterations: 2
   ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_null
         Recheck Cond: (a = 0)
         Selected Partitions:  2..3
         ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
               Index Cond: (a = 0)
               Selected Partitions:  2..3
(8 rows)

SELECT a FROM t_multi_keys_list_null WHERE a = 0;
 a 
---
 0
 0
 0
 0
(4 rows)

EXPLAIN (costs false)
SELECT b FROM t_multi_keys_list_null WHERE b IS NULL;
                      QUERY PLAN                      
------------------------------------------------------
 Partition Iterator
   Iterations: 2
   ->  Partitioned Seq Scan on t_multi_keys_list_null
         Filter: (b IS NULL)
         Selected Partitions:  2,4
(5 rows)

SELECT b FROM t_multi_keys_list_null WHERE b IS NULL;
 b 
---
  
  
(2 rows)

EXPLAIN (costs false)
SELECT b FROM t_multi_keys_list_null WHERE b = 1;
                      QUERY PLAN                      
------------------------------------------------------
 Partition Iterator
   Iterations: 2
   ->  Partitioned Seq Scan on t_multi_keys_list_null
         Filter: (b = 1)
         Selected Partitions:  1,3
(5 rows)

SELECT b FROM t_multi_keys_list_null WHERE b = 1;
 b 
---
 1
 1
 1
(3 rows)

EXPLAIN (costs false)
SELECT a FROM t_multi_keys_list_null WHERE a = 4;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Partition Iterator
   Iterations: 0
   ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_null
         Recheck Cond: (a = 4)
         Selected Partitions:  NONE
         ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
               Index Cond: (a = 4)
               Selected Partitions:  NONE
(8 rows)

SELECT a FROM t_multi_keys_list_null WHERE a = 4;
 a 
---
(0 rows)

EXPLAIN (costs false)
SELECT a,b FROM t_multi_keys_list_null WHERE a < 1 ORDER BY 1,2;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 4
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: (a < 1)
               Selected Partitions:  1..4
(7 rows)

SELECT a,b FROM t_multi_keys_list_null WHERE a < 1 ORDER BY 1,2;
 a | b 
---+---
 0 | 1
 0 | 2
 0 | 3
 0 |  
(4 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE (a,b) = (0,1);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_null_idx_l on t_multi_keys_list_null
   Index Cond: ((a = 0) AND (b = 1))
   Selected Partitions:  3
(3 rows)

SELECT * FROM t_multi_keys_list_null WHERE (a,b) = (0,1);
 a | b | c 
---+---+---
 0 | 1 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE (a,b) = (NULL,0);
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

SELECT * FROM t_multi_keys_list_null WHERE (a,b) = (NULL,0);
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE a IS NULL AND b = 0;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Partitioned Index Only Scan using t_multi_keys_list_null_idx_l on t_multi_keys_list_null
   Index Cond: ((a IS NULL) AND (b = 0))
   Selected Partitions:  1
(3 rows)

SELECT * FROM t_multi_keys_list_null WHERE a IS NULL AND b = 0;
 a | b | c 
---+---+---
   | 0 | 0
(1 row)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE a = 0 OR b = 0 ORDER BY 1,2;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: ((a = 0) OR (b = 0))
               Selected Partitions:  1..3
(7 rows)

SELECT * FROM t_multi_keys_list_null WHERE a = 0 OR b = 0 ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
   | 0 | 0
(5 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE a IN (2,0) ORDER BY 1,2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_null
               Recheck Cond: (a = ANY ('{2,0}'::integer[]))
               Selected Partitions:  1..3
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
                     Index Cond: (a = ANY ('{2,0}'::integer[]))
                     Selected Partitions:  1..3
(10 rows)

SELECT * FROM t_multi_keys_list_null WHERE a IN (2,0) ORDER BY 1,2;
 a | b | c 
---+---+---
 0 | 1 | 0
 0 | 2 | 0
 0 | 3 | 0
 0 |   | 0
 2 | 1 | 0
(5 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE (a,b) IN ((1,1), (3,2)) ORDER BY 1,2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_null
               Recheck Cond: (((a = 1) AND (b = 1)) OR ((a = 3) AND (b = 2)))
               Selected Partitions:  3..4
               ->  BitmapOr
                     ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
                           Index Cond: ((a = 1) AND (b = 1))
                           Selected Partitions:  3..4
                     ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
                           Index Cond: ((a = 3) AND (b = 2))
                           Selected Partitions:  3..4
(14 rows)

SELECT * FROM t_multi_keys_list_null WHERE (a,b) IN ((1,1), (3,2)) ORDER BY 1,2;
 a | b | c 
---+---+---
 1 | 1 | 0
 3 | 2 | 0
(2 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE (a,b) =ANY(ARRAY[(2,1), (3,2)]) ORDER BY 1,2;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 4
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: (ROW(a, b) = ANY (ARRAY[ROW(2, 1), ROW(3, 2)]))
               Selected Partitions:  1..4
(7 rows)

SELECT * FROM t_multi_keys_list_null WHERE (a,b) =ANY(ARRAY[(2,1), (3,2)]) ORDER BY 1,2;
 a | b | c 
---+---+---
 2 | 1 | 0
 3 | 2 | 0
(2 rows)

EXPLAIN (costs false)
SELECT * FROM t_multi_keys_list_null WHERE a =ANY(ARRAY[2, 3]) ORDER BY 1,2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Bitmap Heap Scan on t_multi_keys_list_null
               Recheck Cond: (a = ANY ('{2,3}'::integer[]))
               Selected Partitions:  1,4
               ->  Partitioned Bitmap Index Scan on t_multi_keys_list_null_idx_l
                     Index Cond: (a = ANY ('{2,3}'::integer[]))
                     Selected Partitions:  1,4
(10 rows)

SELECT * FROM t_multi_keys_list_null WHERE a =ANY(ARRAY[2, 3]) ORDER BY 1,2;
 a | b | c 
---+---+---
 2 | 1 | 0
 3 | 2 | 0
(2 rows)

PREPARE part_bdb_stmt(int) as SELECT a,b FROM t_multi_keys_list_null WHERE b = $1 ORDER BY 1,2;
EXPLAIN (costs false)
EXECUTE part_bdb_stmt(3);
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: a
   ->  Partition Iterator
         Iterations: PART
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: (b = $1)
               Selected Partitions:  PART
(7 rows)

EXECUTE part_bdb_stmt(1);
 a | b 
---+---
 0 | 1
 1 | 1
 2 | 1
(3 rows)

EXECUTE part_bdb_stmt(2);
 a | b 
---+---
 0 | 2
 1 | 2
 3 | 2
(3 rows)

PREPARE part_bdb_stmt1(int) as SELECT a,b FROM t_multi_keys_list_null WHERE a != $1 ORDER BY 1,2;
EXPLAIN (costs false)
EXECUTE part_bdb_stmt1(3);
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: PART
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: (a <> $1)
               Selected Partitions:  PART
(7 rows)

EXECUTE part_bdb_stmt1(1);
 a | b 
---+---
 0 | 1
 0 | 2
 0 | 3
 0 |  
 2 | 1
 3 | 2
(6 rows)

EXECUTE part_bdb_stmt1(2);
 a | b 
---+---
 0 | 1
 0 | 2
 0 | 3
 0 |  
 1 | 1
 1 | 2
 3 | 2
(7 rows)

PREPARE part_bdb_stmt2(int) as SELECT a,b FROM t_multi_keys_list_null WHERE a >= $1 ORDER BY 1,2;
EXPLAIN (costs false)
EXECUTE part_bdb_stmt2(3);
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: a, b
   ->  Partition Iterator
         Iterations: PART
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: (a >= $1)
               Selected Partitions:  PART
(7 rows)

EXECUTE part_bdb_stmt2(1);
 a | b 
---+---
 1 | 1
 1 | 2
 2 | 1
 3 | 2
(4 rows)

EXECUTE part_bdb_stmt2(2);
 a | b 
---+---
 2 | 1
 3 | 2
(2 rows)

PREPARE part_bdb_stmt3(int, int) as SELECT a,b FROM t_multi_keys_list_null WHERE (a,b) = ($1,$2);
EXPLAIN (costs false)
EXECUTE part_bdb_stmt3(0,1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Partition Iterator
   Iterations: PART
   ->  Partitioned Index Only Scan using t_multi_keys_list_null_idx_l on t_multi_keys_list_null
         Index Cond: ((a = $1) AND (b = $2))
         Selected Partitions:  PART
(5 rows)

EXECUTE part_bdb_stmt3(0,1);
 a | b 
---+---
 0 | 1
(1 row)

EXECUTE part_bdb_stmt3(3,2);
 a | b 
---+---
 3 | 2
(1 row)

UPDATE t_multi_keys_list_null SET a=2, b=1 where a=1 and b=1;
SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
   | 0 | 0
(3 rows)

UPDATE t_multi_keys_list_null SET a=NULL, b=0 where a=1 and b=2;
SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
   | 0 | 0
   | 0 | 0
(4 rows)

EXPLAIN (costs false)
DELETE t_multi_keys_list_null PARTITION(p3, p4) where b = 0;
                         QUERY PLAN                         
------------------------------------------------------------
 Delete on t_multi_keys_list_null
   ->  Partition Iterator
         Iterations: 2
         ->  Partitioned Seq Scan on t_multi_keys_list_null
               Filter: (b = 0)
               Selected Partitions:  1,4
(6 rows)

DELETE t_multi_keys_list_null PARTITION(p3, p4) where b = 0;
SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
(2 rows)

EXPLAIN (costs false)
DELETE t_multi_keys_list_null PARTITION FOR(0,NULL);
                      QUERY PLAN                      
------------------------------------------------------
 Delete on t_multi_keys_list_null
   ->  Partitioned Seq Scan on t_multi_keys_list_null
         Selected Partitions:  2
(3 rows)

DELETE t_multi_keys_list_null PARTITION FOR(0,NULL);
SELECT * FROM t_multi_keys_list_null PARTITION(p1) ORDER BY a,b;
 a | b | c 
---+---+---
(0 rows)

-- alter table partition
CREATE INDEX test_multi_list_key_gi on t_multi_keys_list_null(c);
CREATE TABLESPACE part_bdb_temp_tbspc RELATIVE LOCATION 'tablespace/part_bdb_temp_tbspc';
ALTER TABLE t_multi_keys_list_null MOVE PARTITION FOR(0,NULL) TABLESPACE part_bdb_temp_tbspc;
SELECT pg_get_tabledef('t_multi_keys_list_null'::regclass);
                                                                                                     pg_get_tabledef                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_b_db_schema;                                                                                                                                                                               +
 CREATE TABLE t_multi_keys_list_null (                                                                                                                                                                                  +
     a integer,                                                                                                                                                                                                         +
     b integer,                                                                                                                                                                                                         +
     c integer                                                                                                                                                                                                          +
 )                                                                                                                                                                                                                      +
 WITH (orientation=row, compression=no)                                                                                                                                                                                 +
 PARTITION BY LIST (a, b)                                                                                                                                                                                               +
 (                                                                                                                                                                                                                      +
     PARTITION p2 VALUES ((0,1),(0,2),(0,3),(1,1),(1,2)),                                                                                                                                                               +
     PARTITION p1 VALUES ((0,NULL)) TABLESPACE part_bdb_temp_tbspc,                                                                                                                                                     +
     PARTITION p4 VALUES ((3,2),(NULL,NULL)),                                                                                                                                                                           +
     PARTITION p3 VALUES ((NULL,0),(2,1))                                                                                                                                                                               +
 )                                                                                                                                                                                                                      +
 ENABLE ROW MOVEMENT;                                                                                                                                                                                                   +
 CREATE INDEX test_multi_list_key_gi ON t_multi_keys_list_null USING btree (c) TABLESPACE pg_default;                                                                                                                   +
 CREATE INDEX t_multi_keys_list_null_idx_l ON t_multi_keys_list_null USING btree (a, b, c) LOCAL(PARTITION p3_a_b_c_idx, PARTITION p1_a_b_c_idx, PARTITION p2_a_b_c_idx, PARTITION p4_a_b_c_idx)  TABLESPACE pg_default;
(1 row)

CREATE TABLE t_alter_partition_temp (a int, b int, c int);
INSERT INTO t_alter_partition_temp VALUES(NULL,0,1);
INSERT INTO t_alter_partition_temp VALUES(2,1,2);
CREATE INDEX t_alter_partition_temp_idx_l ON t_alter_partition_temp(a,b,c);
SELECT * FROM t_alter_partition_temp ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 2
   | 0 | 1
(2 rows)

SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
(2 rows)

ALTER TABLE t_multi_keys_list_null EXCHANGE PARTITION (p3) WITH TABLE t_alter_partition_temp UPDATE GLOBAL INDEX;
SELECT * FROM t_alter_partition_temp ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 0
 2 | 1 | 0
(2 rows)

SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b,c;
 a | b | c 
---+---+---
 2 | 1 | 2
   | 0 | 1
(2 rows)

DROP TABLE IF EXISTS t_alter_partition_temp;
ALTER TABLE t_multi_keys_list_null ADD PARTITION p5 VALUES (1);
ERROR:  Invalid partition values
DETAIL:  list partition values in "p5" does not match the number of partition keys
ALTER TABLE t_multi_keys_list_null ADD PARTITION p5 VALUES ((2,1));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
ALTER TABLE t_multi_keys_list_null ADD PARTITION p5 VALUES ((2,1,1));
ERROR:  Invalid partition values
DETAIL:  list partition values in "p5" does not match the number of partition keys
ALTER TABLE t_multi_keys_list_null ADD PARTITION p5 VALUES ((4,NULL),(2,2),(4,NULL));
ERROR:  list partition p5 has overlapped value
ALTER TABLE t_multi_keys_list_null ADD PARTITION p5 VALUES ((4,4));
INSERT INTO t_multi_keys_list_null VALUES(4,4,4);
SELECT * FROM t_multi_keys_list_null PARTITION(p5) ORDER BY a,b;
 a | b | c 
---+---+---
 4 | 4 | 4
(1 row)

ALTER TABLE t_multi_keys_list_null DROP PARTITION FOR (1);
ERROR:  number of boundary items NOT EQUAL to number of partition keys
ALTER TABLE t_multi_keys_list_null DROP PARTITION FOR (1,5,8);
ERROR:  number of boundary items NOT EQUAL to number of partition keys
ALTER TABLE t_multi_keys_list_null DROP PARTITION FOR (1,5);
ERROR:  The partition number is invalid or out-of-range
ALTER TABLE t_multi_keys_list_null DROP PARTITION FOR (2,1) UPDATE GLOBAL INDEX;
SELECT * FROM t_multi_keys_list_null PARTITION(p3) ORDER BY a,b;
ERROR:  partition "p3" of relation "t_multi_keys_list_null" does not exist
ALTER TABLE t_multi_keys_list_null TRUNCATE PARTITION FOR (4,4) UPDATE GLOBAL INDEX;
SELECT * FROM t_multi_keys_list_null PARTITION(p5) ORDER BY a,b;
 a | b | c 
---+---+---
(0 rows)

ALTER TABLE t_multi_keys_list_null RENAME PARTITION FOR (0,NULL) TO p0;
SELECT pg_get_tabledef('t_multi_keys_list_null'::regclass);
                                                                                                     pg_get_tabledef                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_b_db_schema;                                                                                                                                                                               +
 CREATE TABLE t_multi_keys_list_null (                                                                                                                                                                                  +
     a integer,                                                                                                                                                                                                         +
     b integer,                                                                                                                                                                                                         +
     c integer                                                                                                                                                                                                          +
 )                                                                                                                                                                                                                      +
 WITH (orientation=row, compression=no)                                                                                                                                                                                 +
 PARTITION BY LIST (a, b)                                                                                                                                                                                               +
 (                                                                                                                                                                                                                      +
     PARTITION p2 VALUES ((0,1),(0,2),(0,3),(1,1),(1,2)),                                                                                                                                                               +
     PARTITION p0 VALUES ((0,NULL)) TABLESPACE part_bdb_temp_tbspc,                                                                                                                                                     +
     PARTITION p4 VALUES ((3,2),(NULL,NULL)),                                                                                                                                                                           +
     PARTITION p5 VALUES ((4,4))                                                                                                                                                                                        +
 )                                                                                                                                                                                                                      +
 ENABLE ROW MOVEMENT;                                                                                                                                                                                                   +
 CREATE INDEX test_multi_list_key_gi ON t_multi_keys_list_null USING btree (c) TABLESPACE pg_default;                                                                                                                   +
 CREATE INDEX t_multi_keys_list_null_idx_l ON t_multi_keys_list_null USING btree (a, b, c) LOCAL(PARTITION p1_a_b_c_idx, PARTITION p2_a_b_c_idx, PARTITION p4_a_b_c_idx, PARTITION p5_a_b_c_idx)  TABLESPACE pg_default;
(1 row)

-- test views
SELECT table_name,partitioning_type,partition_count,partitioning_key_count,subpartitioning_type FROM MY_PART_TABLES ORDER BY 1;
ERROR:  relation "my_part_tables" does not exist on datanode1
LINE 1: ...,partitioning_key_count,subpartitioning_type FROM MY_PART_TA...
                                                             ^
SELECT table_name,partition_name,high_value,subpartition_count FROM MY_TAB_PARTITIONS ORDER BY 1,2;
ERROR:  relation "my_tab_partitions" does not exist on datanode1
LINE 1: ...partition_name,high_value,subpartition_count FROM MY_TAB_PAR...
                                                             ^
SELECT table_name,partition_name,subpartition_name,high_value,high_value_length FROM MY_TAB_SUBPARTITIONS ORDER BY 1,2,3;
ERROR:  relation "my_tab_subpartitions" does not exist on datanode1
LINE 1: ...bpartition_name,high_value,high_value_length FROM MY_TAB_SUB...
                                                             ^
SELECT table_name,index_name,partition_count,partitioning_key_count,partitioning_type,subpartitioning_type FROM MY_PART_INDEXES ORDER BY 1,2;
ERROR:  relation "my_part_indexes" does not exist on datanode1
LINE 1: ...count,partitioning_type,subpartitioning_type FROM MY_PART_IN...
                                                             ^
SELECT index_name,partition_name,high_value,high_value_length FROM MY_IND_PARTITIONS ORDER BY 1,2;
ERROR:  relation "my_ind_partitions" does not exist on datanode1
LINE 1: ...,partition_name,high_value,high_value_length FROM MY_IND_PAR...
                                                             ^
SELECT index_name,partition_name,subpartition_name,high_value,high_value_length FROM MY_IND_SUBPARTITIONS ORDER BY 1,2,3;
ERROR:  relation "my_ind_subpartitions" does not exist on datanode1
LINE 1: ...bpartition_name,high_value,high_value_length FROM MY_IND_SUB...
                                                             ^
DROP TABLE IF EXISTS t_multi_keys_list_null;
DROP TABLESPACE part_bdb_temp_tbspc;
-- test subpart
CREATE TABLE t_keys_range_list (a int, b int, c int)
PARTITION BY RANGE COLUMNS(a) SUBPARTITION BY LIST (b,c)
(
    PARTITION p1 VALUES LESS THAN (100) (
        SUBPARTITION sbp11 VALUES ((1,1)),
        SUBPARTITION sbp12 VALUES ((1,2)),
    ),
    PARTITION p2 VALUES LESS THAN (200) (
        SUBPARTITION sbp21 VALUES ((2,1)),
        SUBPARTITION sbp22 VALUES ((2,2)),
    ),
    PARTITION p5 VALUES LESS THAN (MAXVALUE) (
        SUBPARTITION sbp31 VALUES ((3,1)),
        SUBPARTITION sbp32 VALUES ((3,2)),
    )
);
ERROR:  Un-support feature
DETAIL:  The partition key's length should be 1.
\d+ t_keys_range_list
SELECT pg_get_tabledef('t_keys_range_list'::regclass);
ERROR:  relation "t_keys_range_list" does not exist
LINE 1: SELECT pg_get_tabledef('t_keys_range_list'::regclass);
                               ^
CONTEXT:  referenced column: pg_get_tabledef
DROP TABLE IF EXISTS t_keys_range_list;
NOTICE:  table "t_keys_range_list" does not exist, skipping
-- MAXVALUE in subpartiton
CREATE TABLE range_011
(
co1 SMALLINT
,co2 INTEGER
,co3 BIGINT
)
PARTITION BY range COLUMNS(co1) PARTITIONS 3 SUBPARTITION BY range (co2)
(
PARTITION p_range_1 values less than (10)
(
SUBPARTITION p_range_1_1 values less than ( 20 ),
SUBPARTITION p_range_1_2 values less than ( 100 ),
SUBPARTITION p_range_1_5 values less than (MAXVALUE)
),
PARTITION p_range_2 values less than (20)
(
SUBPARTITION p_range_2_1 values less than ( 20 ),
SUBPARTITION p_range_2_2 values less than ( 100 ),
SUBPARTITION p_range_2_5 values less than (MAXVALUE)
),
PARTITION p_range_3 values less than MAXVALUE
(
SUBPARTITION p_range_3_1 values less than ( 20 ),
SUBPARTITION p_range_3_2 values less than ( 100 ),
SUBPARTITION p_range_3_5 values less than (MAXVALUE)
)) ENABLE ROW MOVEMENT;
DROP TABLE range_011;
CREATE TABLE range_011
(
co1 SMALLINT
,co2 INTEGER
,co3 BIGINT
)
PARTITION BY range COLUMNS(co1) PARTITIONS 3 SUBPARTITION BY range (co2)
(
PARTITION p_range_1 values less than (10)
(
SUBPARTITION p_range_1_1 values less than ( 20 ),
SUBPARTITION p_range_1_2 values less than ( 100 ),
SUBPARTITION p_range_1_5 values less than (MAXVALUE)
),
PARTITION p_range_2 values less than (20)
(
SUBPARTITION p_range_2_1 values less than ( 20 ),
SUBPARTITION p_range_2_2 values less than ( 100 ),
SUBPARTITION p_range_2_5 values less than (MAXVALUE)
),
PARTITION p_range_3 values less than MAXVALUE
(
SUBPARTITION p_range_3_1 values less than ( 20 ),
SUBPARTITION p_range_3_2 values less than ( 100 ),
SUBPARTITION p_range_3_5 values less than MAXVALUE
)) ENABLE ROW MOVEMENT; -- ERROR
ERROR:  syntax error at or near "MAXVALUE"
LINE 25: SUBPARTITION p_range_3_5 values less than MAXVALUE
                                                   ^
-- END
DROP SCHEMA partition_b_db_schema CASCADE;
\c regression
drop database part_bdb;
