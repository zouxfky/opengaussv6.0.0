--
--- ALTER TABLE related tickets or bugs fixed
--
-- ATLER TABLE SYNTAX
\h alter table
Command:     ALTER TABLE
Description: change the definition of a table
Syntax:
ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}
    action [, ... ];
ALTER TABLE [ IF EXISTS ] table_name
    ADD ( { column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ]} [, ...] );
ALTER TABLE [ IF EXISTS ] table_name
    MODIFY ( { column_name data_type | column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ] | column_name [ CONSTRAINT constraint_name ] NULL } [, ...] );
ALTER TABLE [ IF EXISTS ] table_name
    RENAME TO new_table_name;
ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}
    RENAME [ COLUMN ] column_name TO new_column_name;
ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}
    RENAME CONSTRAINT constraint_name TO new_constraint_name;
ALTER TABLE [ IF EXISTS ] table_name
    SET SCHEMA new_schema;

where action can be:
column_clause 
    | ADD table_constraint [ NOT VALID ]
    | ADD table_constraint_using_index
    | VALIDATE CONSTRAINT constraint_name
    | DROP CONSTRAINT [ IF EXISTS ]  constraint_name [ RESTRICT | CASCADE ]
    | CLUSTER ON index_name
    | SET WITHOUT CLUSTER
    | SET ( {storage_parameter = value} [, ... ] )
    | RESET ( storage_parameter [, ... ] )
    | OWNER TO new_owner
    | SET TABLESPACE new_tablespace
    | SET {COMPRESS|NOCOMPRESS}
    | TO { GROUP groupname | NODE ( nodename [, ... ] ) }
    | ADD NODE ( nodename [, ... ] )
    | DELETE NODE ( nodename [, ... ] )
    | UPDATE SLICE LIKE table_name
    | DISABLE TRIGGER [ trigger_name | ALL | USER ]
    | ENABLE TRIGGER [ trigger_name | ALL | USER ]
    | ENABLE REPLICA TRIGGER trigger_name
    | ENABLE ALWAYS TRIGGER trigger_name
    | ENABLE ROW LEVEL SECURITY
    | DISABLE ROW LEVEL SECURITY
    | FORCE ROW LEVEL SECURITY
    | NO FORCE ROW LEVEL SECURITY
    | ENCRYPTION KEY ROTATION
    | AUTO_INCREMENT [ = ] value
    | ALTER INDEX index_name [ VISBLE | INVISIBLE ]
    | [ [ DEFAULT ] CHARACTER SET | CHARSET [ = ] default_charset ] [ [ DEFAULT ] COLLATE [ = ] default_collation ]
    | CONVERT TO CHARACTER SET | CHARSET charset [ COLLATE collation ]
NOTICE: '[ CHARACTER SET | CHARSET ]' is only available in CENTRALIZED mode and B-format database!
NOTICE: '[ COLLATE ]' is only available in CENTRALIZED mode and B-format database!
where column_clause can be:
ADD [ COLUMN ] column_name data_type [ CHARACTER SET | CHARSET charset ] [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ] [ FIRST | AFTER column_name ]
    | MODIFY column_name data_type
    | MODIFY column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ]
    | MODIFY column_name [ CONSTRAINT constraint_name ] NULL
    | MODIFY [ COLUMN ] column_name data_type [ CHARACTER SET | CHARSET charset ] [ COLLATE collation ] [ column_constraint [ ... ] ] [COMMENT 'string'] [FIRST | AFTER column_name]
    | CHANGE [ COLUMN ] column_name new_column_name data_type [ CHARACTER SET | CHARSET charset ] [ COLLATE collation ] [ column_constraint [ ... ] ] [COMMENT 'string'] [FIRST | AFTER column_name]
    | DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
    | ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
    | ALTER [ COLUMN ] column_name { SET DEFAULT expression | DROP DEFAULT }
    | ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL
    | ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer
    | ADD STATISTICS (( column_1_name, column_2_name [, ...] ))
    | DELETE STATISTICS (( column_1_name, column_2_name [, ...] ))
    | ALTER [ COLUMN ] column_name SET ( {attribute_option = value} [, ... ] )
    | ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )
    | ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
NOTICE: 'MODIFY [ COLUMN ] ...' action is only available in CENTRALIZED mode and B-format database!
NOTICE: 'CHANGE [ COLUMN ] ...' action is only available in CENTRALIZED mode and B-format database!
where column_constraint can be:
[ CONSTRAINT constraint_name ]
    { NOT NULL |
      NULL |
      CHECK ( expression ) |
      DEFAULT default_expr |
      GENERATED ALWAYS AS ( generation_expr ) [STORED] |
      AUTO_INCREMENT |
      UNIQUE [KEY] index_parameters |
      PRIMARY KEY index_parameters |
      ENCRYPTED WITH ( COLUMN_ENCRYPTION_KEY = column_encryption_key, ENCRYPTION_TYPE = encryption_type_value ) |
      REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
        [ ON DELETE action ] [ ON UPDATE action ] }
    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
NOTICE: 'UNIQUE KEY' in table_constraint is only available in CENTRALIZED mode and B-format database!
where compress_mode can be:
{ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS }
where table_constraint can be:
[ CONSTRAINT [ constraint_name ] ]
    { CHECK ( expression ) |
      UNIQUE [ idx_name ] [ USING method ] ( { { column_name [ ( length ) ] | ( expression ) } [ ASC | DESC ] } [, ... ] ) index_parameters [ VISIBLE | INVISIBLE ] |
      PRIMARY KEY [ USING method ] ( { column_name [ ASC | DESC ] }[, ... ] ) index_parameters [ VISIBLE | INVISIBLE ] |
      PARTIAL CLUSTER KEY ( column_name [, ... ] ) |
      FOREIGN KEY [ idx_name ] ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]
        [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }
    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
where index_parameters can be:
[ WITH ( {storage_parameter = value} [, ... ] ) ]
    [ USING INDEX TABLESPACE tablespace_name ]
where table_constraint_using_index can be:
[ CONSTRAINT constraint_name ]
    { UNIQUE | PRIMARY KEY } USING INDEX index_name
    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

NOTICE: '[ constraint_name ]' in table_constraint is optional in CENTRALIZED mode and B-format database, it is mandatory in other scenarios.
NOTICE: '[ index_name ]' in table_constraint is only available in CENTRALIZED mode and B-format database!
NOTICE: '[ USING method ]' in table_constraint is only available in CENTRALIZED mode and B-format database!
NOTICE: '[ ASC | DESC ]' in table_constraint is only available in CENTRALIZED mode and B-format database!
NOTICE: 'column_name ( length )' in 'UNIQUE' clause of table_constraint is only available in CENTRALIZED mode and B-format database!
NOTICE: '( expression )' in 'UNIQUE' clause of table_constraint is only available in CENTRALIZED mode and B-format database!
NOTICE: 'AUTO_INCREMENT' is only available in CENTRALIZED mode and B-format database!
NOTICE: '[ FIRST | AFTER column_name ]' clause is only available in CENTRALIZED mode!
NOTICE: '[ FIRST | AFTER column_name ]' in 'MODIFY | CHANGE [ COLUMN ] ...' clause is only available in B-format database!
NOTICE: '[ CHARACTER SET | CHARSET charset ]' is only available in CENTRALIZED mode and B-format database!
NOTICE: '[ VISIBLE | INVISIBLE ]' is only avaliable in CENTRALIZED mode and B-format database!

--custom script
--create table
CREATE TABLE TBL_DOMAIN
(
  IDOMAINID   NUMBER(10) NOT NULL,
  SDOMAINNAME VARCHAR2(30) NOT NULL
);
--create/recreate primary, unique and foreign key constraints 
ALTER TABLE TBL_DOMAIN
  ADD CONSTRAINT PK_TBL_DOMAIN PRIMARY KEY (IDOMAINID)
  USING INDEX ;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "pk_tbl_domain" for table "tbl_domain"
  
ALTER TABLE TBL_DOMAIN
  ADD CONSTRAINT IX_TBL_DOMAIN UNIQUE (SDOMAINNAME)
  USING INDEX ;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "ix_tbl_domain" for table "tbl_domain"
\d+ TBL_DOMAIN
                                Table "public.tbl_domain"
   Column    |         Type          | Modifiers | Storage  | Stats target | Description 
-------------+-----------------------+-----------+----------+--------------+-------------
 idomainid   | numeric(10,0)         | not null  | main     |              | 
 sdomainname | character varying(30) | not null  | extended |              | 
Indexes:
    "pk_tbl_domain" PRIMARY KEY, btree (idomainid) TABLESPACE pg_default
    "ix_tbl_domain" UNIQUE CONSTRAINT, btree (sdomainname) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE TBL_DOMAIN;
--create table
CREATE TABLE TBL_CM_MAXTSENDTOHOST
(
  I_MODULETYPE  NUMBER(38) NOT NULL,
  I_MODULENO    NUMBER(38) NOT NULL,
  I_PLAMODULENO NUMBER(38) NOT NULL,
  I_TABLEID     NUMBER(38) NOT NULL,
  I_OLDMAXTUPLE NUMBER(38) NOT NULL,
  I_NEWMAXTUPLE NUMBER(38) NOT NULL,
  I_RESERVED1   NUMBER(38) DEFAULT 0,
  I_RESERVED2   NUMBER(38) DEFAULT 0,
  I_RESERVED3   NUMBER(38) DEFAULT 0,
  I_RESERVED4   NUMBER(38) DEFAULT 0,
  I_RESERVED5   NUMBER(38) DEFAULT 0,
  I_RESERVED6   NUMBER(38) DEFAULT 0,
  I_RESERVED7   NUMBER(38) DEFAULT 0,
  SV_RESERVED8  VARCHAR2(32) DEFAULT '',
  SV_RESERVED9  VARCHAR2(32) DEFAULT '',
  SV_RESERVED10 VARCHAR2(32) DEFAULT ''
)
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
--add primary key
ALTER TABLE TBL_CM_MAXTSENDTOHOST
  ADD PRIMARY KEY (I_PLAMODULENO, I_TABLEID)
  USING INDEX 
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tbl_cm_maxtsendtohost_pkey" for table "tbl_cm_maxtsendtohost"
 \d+ TBL_CM_MAXTSENDTOHOST
                                      Table "public.tbl_cm_maxtsendtohost"
    Column     |         Type          |            Modifiers            | Storage  | Stats target | Description 
---------------+-----------------------+---------------------------------+----------+--------------+-------------
 i_moduletype  | numeric(38,0)         | not null                        | main     |              | 
 i_moduleno    | numeric(38,0)         | not null                        | main     |              | 
 i_plamoduleno | numeric(38,0)         | not null                        | main     |              | 
 i_tableid     | numeric(38,0)         | not null                        | main     |              | 
 i_oldmaxtuple | numeric(38,0)         | not null                        | main     |              | 
 i_newmaxtuple | numeric(38,0)         | not null                        | main     |              | 
 i_reserved1   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved2   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved3   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved4   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved5   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved6   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved7   | numeric(38,0)         | default 0                       | main     |              | 
 sv_reserved8  | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved9  | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved10 | character varying(32) | default NULL::character varying | extended |              | 
Indexes:
    "tbl_cm_maxtsendtohost_pkey" PRIMARY KEY, btree (i_plamoduleno, i_tableid) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

 DROP TABLE TBL_CM_MAXTSENDTOHOST;
--create table
CREATE TABLE TBL_LICCTRLDESC_DEFAULT
(
  I_INDEX        NUMBER(38) NOT NULL,
  SV_FEATURENAME VARCHAR2(64) NOT NULL,
  SV_ITEMNAME    VARCHAR2(64) NOT NULL,
  I_ITEMTYPE     NUMBER(38) NOT NULL,
  I_ITEMVALUEMIN NUMBER(38) NOT NULL,
  I_ITEMVALUEMAX NUMBER(38) NOT NULL,
  I_RESERVED1    NUMBER(38) DEFAULT 0,
  I_RESERVED2    NUMBER(38) DEFAULT 0,
  I_RESERVED3    NUMBER(38) DEFAULT 0,
  I_RESERVED4    NUMBER(38) DEFAULT 0,
  I_RESERVED5    NUMBER(38) DEFAULT 0,
  I_RESERVED6    NUMBER(38) DEFAULT 0,
  I_RESERVED7    NUMBER(38) DEFAULT 0,
  SV_RESERVED8   VARCHAR2(32) DEFAULT '',
  SV_RESERVED9   VARCHAR2(32) DEFAULT '',
  SV_RESERVED10  VARCHAR2(32) DEFAULT '',
  I_STATUS       NUMBER(38) NOT NULL
)
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
--add primary key
ALTER TABLE TBL_LICCTRLDESC_DEFAULT
  ADD PRIMARY KEY (I_INDEX)
  USING INDEX 
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tbl_licctrldesc_default_pkey" for table "tbl_licctrldesc_default"
--add unique index
CREATE UNIQUE INDEX IDX_TBL_LICCTRL_DEF ON TBL_LICCTRLDESC_DEFAULT (I_INDEX DESC, I_STATUS)
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
\d+ TBL_LICCTRLDESC_DEFAULT
                                      Table "public.tbl_licctrldesc_default"
     Column     |         Type          |            Modifiers            | Storage  | Stats target | Description 
----------------+-----------------------+---------------------------------+----------+--------------+-------------
 i_index        | numeric(38,0)         | not null                        | main     |              | 
 sv_featurename | character varying(64) | not null                        | extended |              | 
 sv_itemname    | character varying(64) | not null                        | extended |              | 
 i_itemtype     | numeric(38,0)         | not null                        | main     |              | 
 i_itemvaluemin | numeric(38,0)         | not null                        | main     |              | 
 i_itemvaluemax | numeric(38,0)         | not null                        | main     |              | 
 i_reserved1    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved2    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved3    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved4    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved5    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved6    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved7    | numeric(38,0)         | default 0                       | main     |              | 
 sv_reserved8   | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved9   | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved10  | character varying(32) | default NULL::character varying | extended |              | 
 i_status       | numeric(38,0)         | not null                        | main     |              | 
Indexes:
    "tbl_licctrldesc_default_pkey" PRIMARY KEY, btree (i_index) TABLESPACE pg_default
    "idx_tbl_licctrl_def" UNIQUE, btree (i_index DESC, i_status) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

 DROP TABLE TBL_LICCTRLDESC_DEFAULT;
--using index clause
CREATE TABLE STUDENTS
(
	ID INT,
	NAME VARCHAR2(20),
	AGE INT,
	ADDRESS VARCHAR(30)
);
 --alter table to add unique index or primary key 
ALTER TABLE STUDENTS ADD UNIQUE (ID)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "students_id_key" for table "students"
ALTER TABLE STUDENTS ADD CONSTRAINT ZHANGYG UNIQUE (AGE, ADDRESS)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "zhangyg" for table "students"
ALTER TABLE STUDENTS ADD PRIMARY KEY (AGE)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "students_pkey" for table "students"
\d+ STUDENTS
                               Table "public.students"
 Column  |         Type          | Modifiers | Storage  | Stats target | Description 
---------+-----------------------+-----------+----------+--------------+-------------
 id      | integer               |           | plain    |              | 
 name    | character varying(20) |           | extended |              | 
 age     | integer               | not null  | plain    |              | 
 address | character varying(30) |           | extended |              | 
Indexes:
    "students_pkey" PRIMARY KEY, btree (age) TABLESPACE pg_default
    "students_id_key" UNIQUE CONSTRAINT, btree (id) TABLESPACE pg_default
    "zhangyg" UNIQUE CONSTRAINT, btree (age, address) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE STUDENTS;
--simulate A db's ALTER TABLE gram
CREATE TABLE MODIFY_TABLE_A(I INTEGER);
ALTER TABLE MODIFY_TABLE_A ADD (mychar CHAR); 
ALTER TABLE MODIFY_TABLE_A ADD (myint1 INT, mychar1 CHAR);
ALTER TABLE MODIFY_TABLE_A ADD (myint2 INT, mychar2 CHAR, mychar3 CHAR);
ALTER TABLE MODIFY_TABLE_A ADD a CHAR, ADD b CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | integer      | 
 mychar  | character(1) | 
 myint1  | integer      | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 

ALTER TABLE MODIFY_TABLE_A ADD mychar4 CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | integer      | 
 mychar  | character(1) | 
 myint1  | integer      | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 
 mychar4 | character(1) | 

ALTER TABLE MODIFY_TABLE_A MODIFY I VARCHAR2(64);
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character varying(64) | 
 mychar  | character(1)          | 
 myint1  | integer               | 
 mychar1 | character(1)          | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY I CHAR, MODIFY myint1 CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | character(1) | 
 mychar  | character(1) | 
 myint1  | character(1) | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 
 mychar4 | character(1) | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(12));
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character(1)          | 
 mychar  | character(1)          | 
 myint1  | character varying(12) | 
 mychar1 | character(1)          | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(13), mychar1 INT);
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character(1)          | 
 mychar  | character(1)          | 
 myint1  | character varying(13) | 
 mychar1 | integer               | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

DROP TABLE MODIFY_TABLE_A;
create table test_alter_type(a int,b text);
alter table test_alter_type alter column a type regclass;
DROP TABLE test_alter_type;
create table test_mod(a int,b text);
alter table test_mod alter column a type regclass;
alter table test_mod alter column a set default "d";
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
alter table test_mod alter column a set default "d"::int;
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
alter table test_mod alter column a set default "d"::int + 1;
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
drop table test_mod;
--simulate A db and postgresql, ALTER TABLE IF EXISTS table_name ADD( { element_list_clause } [, ...] )
--simulate A db and postgresql, ALTER TABLE IF EXISTS table_name MODIFY( { element_list_clause } [, ...] )
create schema  columnar_storage;
create table columnar_storage.create_columnar_add_common_008 (c_tinyint  tinyint,c_smallint smallint,c_int integer,c_bigint   bigint,c_money    money,c_numeric   numeric,c_real      real,c_double    double precision,c_decimal   decimal,c_varchar   varchar,c_char   char(30),c_nvarchar2  nvarchar2,c_text text,c_timestamp   timestamp with time zone,c_timestamptz timestamp without time zone,c_date     date,c_time     time without time zone,c_timetz   time with time zone,c_interval  interval,c_tinterval   tinterval,c_smalldatetime   smalldatetime,c_bytea   bytea,c_boolean  boolean,c_inet inet,c_cidr cidr,c_bit bit(10),c_varbit varbit(10),c_oid oid) with (orientation=column);
alter table if exists columnar_storage.create_columnar_add_common_007 modify (c_int varchar(20));
NOTICE:  relation "create_columnar_add_common_007" does not exist, skipping
alter table if exists columnar_storage.create_columnar_add_common_008 modify (c_int varchar(20), c_double  varchar(20));
select * from columnar_storage.create_columnar_add_common_008;
 c_tinyint | c_smallint | c_int | c_bigint | c_money | c_numeric | c_real | c_double | c_decimal | c_varchar | c_char | c_nvarchar2 | c_text | c_timestamp | c_timestamptz | c_date | c_time | c_timetz | c_interval | c_tinterval | c_smalldatetime | c_bytea | c_boolean | c_inet | c_cidr | c_bit | c_varbit | c_oid 
-----------+------------+-------+----------+---------+-----------+--------+----------+-----------+-----------+--------+-------------+--------+-------------+---------------+--------+--------+----------+------------+-------------+-----------------+---------+-----------+--------+--------+-------+----------+-------
(0 rows)

drop table columnar_storage.create_columnar_add_common_008;
create table columnar_storage.create_columnar_add_common_008 (c_tinyint  tinyint,c_smallint smallint,c_int integer,c_bigint   bigint,c_money    money,c_numeric   numeric,c_real      real,c_double    double precision,c_decimal   decimal,c_varchar   varchar,c_char   char(30),c_nvarchar2  nvarchar2,c_text text,c_timestamp   timestamp with time zone,c_timestamptz timestamp without time zone,c_date     date,c_time     time without time zone,c_timetz   time with time zone,c_interval  interval,c_tinterval   tinterval,c_smalldatetime   smalldatetime,c_bytea   bytea,c_boolean  boolean,c_inet inet,c_cidr cidr,c_bit bit(10),c_varbit varbit(10),c_oid oid) with (orientation=column);
alter table if exists columnar_storage.create_columnar_add_common_007 add (c_time_008 time without time zone,c_timetz_008  time with time zone);
NOTICE:  relation "create_columnar_add_common_007" does not exist, skipping
alter table if exists columnar_storage.create_columnar_add_common_008 add (c_time_008 time without time zone,c_timetz_008  time with time zone);
select * from columnar_storage.create_columnar_add_common_008;
 c_tinyint | c_smallint | c_int | c_bigint | c_money | c_numeric | c_real | c_double | c_decimal | c_varchar | c_char | c_nvarchar2 | c_text | c_timestamp | c_timestamptz | c_date | c_time | c_timetz | c_interval | c_tinterval | c_smalldatetime | c_bytea | c_boolean | c_inet | c_cidr | c_bit | c_varbit | c_oid | c_time_008 | c_timetz_008 
-----------+------------+-------+----------+---------+-----------+--------+----------+-----------+-----------+--------+-------------+--------+-------------+---------------+--------+--------+----------+------------+-------------+-----------------+---------+-----------+--------+--------+-------+----------+-------+------------+--------------
(0 rows)

drop table columnar_storage.create_columnar_add_common_008;
drop schema columnar_storage;
create table test_drop_column_1 (a int, b int, c int);
create table test_drop_column_2 (a int, b int);
create table test_drop_column_3 (a int, b int);
alter table test_drop_column_1 drop column c;
explain (verbose true, costs false) insert into test_drop_column_1 select * from test_drop_column_2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 [Bypass]
 Insert on public.test_drop_column_1
   ->  Seq Scan on public.test_drop_column_2
         Output: test_drop_column_2.a, test_drop_column_2.b, NULL::integer
(4 rows)

insert into test_drop_column_1 select * from test_drop_column_2;
explain (verbose true, costs false) insert into test_drop_column_1 select * from test_drop_column_2 order by 2;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Subquery Scan on "*SELECT*"
         Output: "*SELECT*".a, "*SELECT*".b, NULL::integer
         ->  Sort
               Output: test_drop_column_2.a, test_drop_column_2.b
               Sort Key: test_drop_column_2.b
               ->  Seq Scan on public.test_drop_column_2
                     Output: test_drop_column_2.a, test_drop_column_2.b
(8 rows)

insert into test_drop_column_1 select * from test_drop_column_2 order by 2;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.a;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Hash Join
         Output: test_drop_column_2.a, test_drop_column_3.a, NULL::integer
         Hash Cond: (test_drop_column_2.a = test_drop_column_3.a)
         ->  Seq Scan on public.test_drop_column_2
               Output: test_drop_column_2.a, test_drop_column_2.b
         ->  Hash
               Output: test_drop_column_3.a
               ->  Seq Scan on public.test_drop_column_3
                     Output: test_drop_column_3.a
(10 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.a;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Hash Join
         Output: test_drop_column_2.a, test_drop_column_3.a, NULL::integer
         Hash Cond: (test_drop_column_2.a = test_drop_column_3.b)
         ->  Seq Scan on public.test_drop_column_2
               Output: test_drop_column_2.a, test_drop_column_2.b
         ->  Hash
               Output: test_drop_column_3.a, test_drop_column_3.b
               ->  Seq Scan on public.test_drop_column_3
                     Output: test_drop_column_3.a, test_drop_column_3.b
(10 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b order by 1, 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Subquery Scan on "*SELECT*"
         Output: "*SELECT*".a, "*SELECT*".a, NULL::integer
         ->  Sort
               Output: test_drop_column_2.a, test_drop_column_3.a
               Sort Key: test_drop_column_2.a, test_drop_column_3.a
               ->  Hash Join
                     Output: test_drop_column_2.a, test_drop_column_3.a
                     Hash Cond: (test_drop_column_2.a = test_drop_column_3.b)
                     ->  Seq Scan on public.test_drop_column_2
                           Output: test_drop_column_2.a, test_drop_column_2.b
                     ->  Hash
                           Output: test_drop_column_3.a, test_drop_column_3.b
                           ->  Seq Scan on public.test_drop_column_3
                                 Output: test_drop_column_3.a, test_drop_column_3.b
(15 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b order by 1, 2;
explain (verbose true, costs false) update test_drop_column_1 set a=test_drop_column_2.a from test_drop_column_2;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Update on public.test_drop_column_1
   ->  Nested Loop
         Output: test_drop_column_2.a, test_drop_column_1.b, NULL::integer, test_drop_column_1.ctid, test_drop_column_2.ctid
         ->  Seq Scan on public.test_drop_column_1
               Output: test_drop_column_1.b, test_drop_column_1.ctid
         ->  Materialize
               Output: test_drop_column_2.a, test_drop_column_2.ctid
               ->  Seq Scan on public.test_drop_column_2
                     Output: test_drop_column_2.a, test_drop_column_2.ctid
(9 rows)

update test_drop_column_1 set a=test_drop_column_2.a from test_drop_column_2;
explain (verbose true, costs false) delete from test_drop_column_1 where a in (select a from test_drop_column_2);
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Delete on public.test_drop_column_1
   ->  Hash Join
         Output: test_drop_column_1.ctid, test_drop_column_2.ctid
         Hash Cond: (test_drop_column_1.a = test_drop_column_2.a)
         ->  Seq Scan on public.test_drop_column_1
               Output: test_drop_column_1.ctid, test_drop_column_1.a
         ->  Hash
               Output: test_drop_column_2.ctid, test_drop_column_2.a
               ->  HashAggregate
                     Output: test_drop_column_2.ctid, test_drop_column_2.a
                     Group By Key: test_drop_column_2.a
                     ->  Seq Scan on public.test_drop_column_2
                           Output: test_drop_column_2.ctid, test_drop_column_2.a
(13 rows)

delete from test_drop_column_1 where a in (select a from test_drop_column_2);
create table test_drop_column_cstore_1 (a int, b int, c int) with (orientation = column);
create table test_drop_column_cstore_2 (a int, b int) with (orientation = column);
create table test_drop_column_cstore_3 (a int) with (orientation = column);
alter table test_drop_column_cstore_1 drop column c;
insert into test_drop_column_cstore_1 select * from test_drop_column_cstore_2;
insert into test_drop_column_cstore_1 select * from test_drop_column_cstore_2 order by 2;
insert into test_drop_column_cstore_1 select test_drop_column_cstore_2.a, test_drop_column_cstore_3.a from test_drop_column_cstore_2, test_drop_column_cstore_3 where test_drop_column_cstore_2.a = test_drop_column_cstore_3.a;
drop table test_drop_column_1;
drop table test_drop_column_2;
drop table test_drop_column_3;
drop table test_drop_column_cstore_1;
drop table test_drop_column_cstore_2;
drop table test_drop_column_cstore_3;
create table test_hash (a int, b int);
create sequence test_seq1;
alter table test_hash alter column a type serial; --fail 
ERROR:  cannot alter column type to "serial"
alter table test_hash alter column a set default nextval('test_seq1'); 
insert into test_hash(b) values(generate_series(1,10));
alter table test_hash add column c serial; --not supported
ERROR:  It's not supported to alter table add serial column
alter table test_hash add column d int default nextval('test_seq1'); --not supported
ERROR:  It's not supported to alter table add column default with nextval expression.
alter table test_hash add column e int default nextval('test_seq1')*10; --not supported
ERROR:  It's not supported to alter table add column default with nextval expression.
drop table test_hash;
drop sequence test_seq1;
-- check column addition within a view (bug #14876)
create table at_base_table(id int, stuff text);
insert into at_base_table values (23, 'skidoo');
create view at_view_1 as select * from at_base_table bt;
create view at_view_2 as select *, v1 as j from at_view_1 v1;
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
View definition:
 SELECT  *
   FROM at_base_table bt;

\d+ at_view_2
                 View "public.at_view_2"
 Column |   Type    | Modifiers | Storage  | Description 
--------+-----------+-----------+----------+-------------
 id     | integer   |           | plain    | 
 stuff  | text      |           | extended | 
 j      | at_view_1 |           | extended | 
View definition:
 SELECT  *, v1.*::at_view_1 AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
                   QUERY PLAN                    
-------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, ROW(bt.id, bt.stuff)
(2 rows)

select * from at_view_2;
 id | stuff  |      j      
----+--------+-------------
 23 | skidoo | (23,skidoo)
(1 row)

create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
 more   | integer |           | plain    | 
View definition:
 SELECT  *, 2 + 2 AS more
   FROM at_base_table bt;

\d+ at_view_2
                 View "public.at_view_2"
 Column |   Type    | Modifiers | Storage  | Description 
--------+-----------+-----------+----------+-------------
 id     | integer   |           | plain    | 
 stuff  | text      |           | extended | 
 j      | at_view_1 |           | extended | 
View definition:
 SELECT  *, v1.*::at_view_1 AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, ROW(bt.id, bt.stuff, NULL)
(2 rows)

select * from at_view_2;
 id | stuff  |      j       
----+--------+--------------
 23 | skidoo | (23,skidoo,)
(1 row)

drop view at_view_2;
drop view at_view_1;
drop table at_base_table;
create table tt_row_rep_1(a int);
alter table tt_row_rep_1 drop column a;
ERROR:  must have at least one column
create table tt_row_rep_2(a int, b int);
alter table tt_row_rep_2 drop column b;
alter table tt_row_rep_2 drop column a;
ERROR:  must have at least one column
create table tt_col_rep_1(a int) with(orientation=column);
alter table tt_col_rep_1 drop column a;
ERROR:  must have at least one column
create table tt_col_rep_2(a int, b int) with(orientation=column);
alter table tt_col_rep_2 drop column b;
alter table tt_col_rep_2 drop column a;
ERROR:  must have at least one column
drop table tt_row_rep_1;
drop table tt_row_rep_2;
drop table tt_col_rep_1;
drop table tt_col_rep_2;
select pg_catalog.ledger_hist_repair('0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 65536);
ERROR:  The schema name exceeds the maximum length.
CONTEXT:  referenced column: ledger_hist_repair
-- test primary key is only supported in B mode
-- alter table
create table test_primary(f11 int, f12 varchar(20), f13 bool);
-- error
alter table test_primary add constraint con_t_pri primary key using btree(f11, f12);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: alter table test_primary add constraint con_t_pri primary ke...
                                                          ^
alter table test_primary add constraint primary key using btree(f11, f12);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: alter table test_primary add constraint primary key using bt...
                                                ^
alter table test_primary add primary key using btree(f11, f12);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: alter table test_primary add primary key using btree(f11, f1...
                                     ^
alter table test_primary add primary key((abs(f11)));
ERROR:  expression is supported only in B-format database.
LINE 1: alter table test_primary add primary key((abs(f11)));
                                                 ^
alter table test_primary add primary key((f11 * 2 + 1));
ERROR:  expression is supported only in B-format database.
LINE 1: alter table test_primary add primary key((f11 * 2 + 1));
                                                 ^
alter table test_primary add primary key(f11 desc, f12 asc);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: alter table test_primary add primary key(f11 desc, f12 asc);
                                                 ^
-- success
alter table test_primary add primary key(f11, f12);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- alter table using index
-- success
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11, f12);
alter table test_primary add constraint con_t_pri primary key using index idx_pri;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "idx_pri" to "con_t_pri"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11);
alter table test_primary add primary key using index idx_pri;
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri" PRIMARY KEY, btree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- error
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11, f12);
alter table test_primary add constraint primary key using index idx_pri;
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 1: alter table test_primary add constraint primary key using in...
                                     ^
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri" UNIQUE, btree (f11, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11 desc, f12 asc);
alter table test_primary add constraint con_t_pri primary key using index idx_pri;
ERROR:  index "idx_pri" does not have default sorting behavior
LINE 1: alter table test_primary add constraint con_t_pri primary ke...
                                     ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri" UNIQUE, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri1 on test_primary using btree((abs(f11)));
-- error
alter table test_primary add primary key using index idx_pri1;
ERROR:  index "idx_pri1" contains expressions
LINE 1: alter table test_primary add primary key using index idx_pri...
                                     ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri1" UNIQUE, btree (abs(f11)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

create unique index idx_pri2 on test_primary using btree((f11 * 2 + 1));
-- error
alter table test_primary add primary key using index idx_pri2;
ERROR:  index "idx_pri2" contains expressions
LINE 1: alter table test_primary add primary key using index idx_pri...
                                     ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri1" UNIQUE, btree (abs(f11)) TABLESPACE pg_default
    "idx_pri2" UNIQUE, btree ((f11 * 2 + 1)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- test foreign key is only supported in B mode
-- alter table 
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
create table test_foreign(f21 int, f22 timestamp);
-- error
alter table test_foreign add constraint con_t_foreign foreign key f_t_foreign (f21) references test_primary(f11);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: ...r table test_foreign add constraint con_t_foreign foreign ke...
                                                             ^
alter table test_foreign add constraint foreign key f_t_foreign (f21) references test_primary(f11);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: alter table test_foreign add constraint foreign key f_t_fore...
                                                ^
alter table test_foreign add foreign key f_t_foreign (f21) references test_primary(f11);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: alter table test_foreign add foreign key f_t_foreign (f21) r...
                                     ^
-- success
alter table test_foreign add constraint con_t_foreign foreign key (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp);
alter table test_foreign add foreign key (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "test_foreign_f21_fkey" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
drop table test_primary;
-- test unique key is only supported in B mode
-- alter table
create table test_unique(f31 int, f32 varchar(20));
-- error
alter table test_unique add constraint con_t_unique unique u_t_unique using btree(f31);
ERROR:  UNIQUE name is supported only in B-format database.
LINE 1: ...ter table test_unique add constraint con_t_unique unique u_t...
                                                             ^
alter table test_unique add constraint con_t_unique unique using btree(f31);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: ...ter table test_unique add constraint con_t_unique unique usi...
                                                             ^
alter table test_unique add constraint unique u_t_unique using btree(f31);
ERROR:  UNIQUE name is supported only in B-format database.
LINE 1: alter table test_unique add constraint unique u_t_unique usi...
                                               ^
alter table test_unique add unique using btree(f31);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: alter table test_unique add unique using btree(f31);
                                    ^
alter table test_unique add constraint con_t_unique unique u_t_unique using btree((abs(f31)) desc);
ERROR:  expression is supported only in B-format database.
LINE 1: ...traint con_t_unique unique u_t_unique using btree((abs(f31))...
                                                             ^
alter table test_unique add constraint con_t_unique unique u_t_unique using btree((f31 * 2 + 1) desc);
ERROR:  expression is supported only in B-format database.
LINE 1: ...traint con_t_unique unique u_t_unique using btree((f31 * 2 +...
                                                             ^
alter table test_unique add unique using btree(f31 desc);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: alter table test_unique add unique using btree(f31 desc);
                                                       ^
-- success
alter table test_unique add constraint con_t_unique unique(f31);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- alter table using index
-- error
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree(f31 desc, f32 asc);
alter table test_unique add constraint con_t_unique unique using index idx_unique;
ERROR:  index "idx_unique" does not have default sorting behavior
LINE 1: alter table test_unique add constraint con_t_unique unique u...
                                    ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE, btree (f31 DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree(f31 desc, f32 asc);
alter table test_unique add unique using index idx_unique;
ERROR:  index "idx_unique" does not have default sorting behavior
LINE 1: alter table test_unique add unique using index idx_unique;
                                    ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE, btree (f31 DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree(f31, f32);
alter table test_unique add constraint unique using index idx_unique;
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 1: alter table test_unique add constraint unique using index id...
                                    ^
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree((abs(f31)) desc, f32 asc);
alter table test_unique add unique using index idx_unique;
ERROR:  index "idx_unique" contains expressions
LINE 1: alter table test_unique add unique using index idx_unique;
                                    ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE, btree (abs(f31) DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree((f31 * 2 + 1) desc, f32 asc);
alter table test_unique add unique using index idx_unique;
ERROR:  index "idx_unique" contains expressions
LINE 1: alter table test_unique add unique using index idx_unique;
                                    ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE, btree ((f31 * 2 + 1) DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- success
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree(f31, f32);
alter table test_unique add constraint con_t_unique unique using index idx_unique;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "idx_unique" to "con_t_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- partition table
-- test primary key is only supported in B mode
-- alter table
-- error
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_primary add constraint con_t_pri primary key using btree(f1, f2, f3);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: ...ter table test_p_primary add constraint con_t_pri primary ke...
                                                             ^
alter table test_p_primary add constraint primary key using btree(f1 desc, f2 asc, f3);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: ..._p_primary add constraint primary key using btree(f1 desc, f...
                                                             ^
alter table test_p_primary add primary key using btree(f1 desc, f2 asc, f3);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: ... table test_p_primary add primary key using btree(f1 desc, f...
                                                             ^
alter table test_p_primary add primary key using btree(f1 desc, f2 asc, f3);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: ... table test_p_primary add primary key using btree(f1 desc, f...
                                                             ^
alter table test_p_primary add primary key using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  expression is supported only in B-format database.
LINE 1: ... table test_p_primary add primary key using btree((abs(f1)) ...
                                                             ^
-- success
alter table test_p_primary add constraint con_t_pri primary key(f1, f2, f3);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
-- alter table using index
-- error
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree(f1 desc, f2 asc, f3);
alter table test_p_primary add constraint con_t_pri primary key using index idx_pri;
ERROR:  index "idx_pri" does not have default sorting behavior
LINE 1: alter table test_p_primary add constraint con_t_pri primary ...
                                       ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_pri" UNIQUE, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree(f1, f2, f3);
alter table test_p_primary add constraint primary key using index idx_pri;
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 1: alter table test_p_primary add constraint primary key using ...
                                       ^
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_pri" UNIQUE, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree(f1 desc, f2 asc, f3);
alter table test_p_primary add primary key using index idx_pri;
ERROR:  index "idx_pri" does not have default sorting behavior
LINE 1: alter table test_p_primary add primary key using index idx_p...
                                       ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_pri" UNIQUE, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  Global partition index does not support EXPRESSION index
alter table test_p_primary add primary key using index idx_pri1;
ERROR:  index "idx_pri1" does not exist
LINE 1: alter table test_p_primary add primary key using index idx_p...
                                       ^
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
-- test foreign key in M mode
-- alter table 
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    primary key (f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
-- error
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add constraint con_t_foreign foreign key f_t_foreign (f1) references test_p_primary(f1);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: ...table test_p_foreign add constraint con_t_foreign foreign ke...
                                                             ^
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add constraint foreign key f_t_foreign(f1) references test_p_primary(f1);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: alter table test_p_foreign add constraint foreign key f_t_fo...
                                                  ^
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add foreign key f_t_foreign(f1) references test_p_primary(f1);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: alter table test_p_foreign add foreign key f_t_foreign(f1) r...
                                       ^
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
-- success
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add constraint con_t_foreign foreign key(f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add foreign key(f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "test_p_foreign_f1_fkey" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
drop table test_p_primary;
-- test unique key in M mode
-- alter table
-- error
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add constraint con_t_unique unique u_t_unique using btree(f1);
ERROR:  UNIQUE name is supported only in B-format database.
LINE 1: ...r table test_p_unique add constraint con_t_unique unique u_t...
                                                             ^
alter table test_p_unique add constraint con_t_unique unique using btree(f1);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: ...r table test_p_unique add constraint con_t_unique unique usi...
                                                             ^
alter table test_p_unique add constraint unique u_t_unique using btree(f1);
ERROR:  UNIQUE name is supported only in B-format database.
LINE 1: alter table test_p_unique add constraint unique u_t_unique u...
                                                 ^
alter table test_p_unique add unique using btree(f1);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: alter table test_p_unique add unique using btree(f1);
                                      ^
alter table test_p_unique add unique(f1 desc, f2 asc, f3);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: alter table test_p_unique add unique(f1 desc, f2 asc, f3);
                                             ^
alter table test_p_unique add constraint con_t_unique unique ((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  expression is supported only in B-format database.
LINE 1: ...test_p_unique add constraint con_t_unique unique ((abs(f1)) ...
                                                             ^
-- success
alter table test_p_unique add constraint con_t_unique unique(f1, f2, f3);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "con_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- alter table using index
-- error
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree(f1 desc, f2 asc);
alter table test_p_unique add constraint con_t_unique unique using index idx_unique;
ERROR:  index "idx_unique" does not have default sorting behavior
LINE 1: alter table test_p_unique add constraint con_t_unique unique...
                                      ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_unique" UNIQUE, btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree(f1, f2);
alter table test_p_unique add constraint unique using index idx_unique;
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 1: alter table test_p_unique add constraint unique using index ...
                                      ^
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_unique" UNIQUE, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree(f1 desc, f2 asc);
alter table test_p_unique add unique using index idx_unique;
ERROR:  index "idx_unique" does not have default sorting behavior
LINE 1: alter table test_p_unique add unique using index idx_unique;
                                      ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_unique" UNIQUE, btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  Global partition index does not support EXPRESSION index
alter table test_p_unique add unique using index idx_unique;
ERROR:  index "idx_unique" does not exist
LINE 1: alter table test_p_unique add unique using index idx_unique;
                                      ^
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- b compatibility case
drop database if exists b;
create database b dbcompatibility 'b';
\c b
-- test primary key is only supported in B mode
-- alter table
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add constraint con_t_pri primary key using btree(f11 desc, f12 asc);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add constraint primary key(f11 desc, f12 asc);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key using btree(f11 desc, f12 asc);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- error
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key((abs(f11)));
ERROR:  primary keys cannot be expressions
alter table test_primary add primary key((f11 * 2 + 1));
ERROR:  primary keys cannot be expressions
drop table test_primary;
-- alter table using index
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11 desc, f12 asc);
alter table test_primary add constraint con_t_pri primary key using index idx_pri;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "idx_pri" to "con_t_pri"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11 desc, f12 asc);
alter table test_primary add constraint primary key using index idx_pri;
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri on test_primary using btree(f11 desc);
alter table test_primary add primary key using index idx_pri;
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri" PRIMARY KEY, btree (f11 DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
create unique index idx_pri1 on test_primary using btree((abs(f11)));
-- error
alter table test_primary add primary key using index idx_pri1;
ERROR:  primary keys cannot be expressions
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri1" UNIQUE, btree (abs(f11)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

create unique index idx_pri2 on test_primary using btree((f11 * 2 + 1));
-- error
alter table test_primary add primary key using index idx_pri2;
ERROR:  primary keys cannot be expressions
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "idx_pri1" UNIQUE, btree (abs(f11)) TABLESPACE pg_default
    "idx_pri2" UNIQUE, btree ((f11 * 2 + 1)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
-- test foreign key in M mode
-- alter table 
create table test_foreign(f21 int, f22 timestamp);
alter table test_foreign add constraint con_t_foreign foreign key f_t_foreign (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp);
alter table test_foreign add constraint con_t_foreign foreign key (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp);
alter table test_foreign add constraint foreign key f_t_foreign (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp);
alter table test_foreign add foreign key f_t_foreign (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp);
alter table test_foreign add foreign key (f21) references test_primary(f11);
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "test_foreign_f21_fkey" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
drop table test_primary;
-- test unique key in M mode
-- alter table
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add constraint con_t_unique unique u_t_unique using btree(f31);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "u_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add constraint con_t_unique unique using btree(f31);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add constraint unique u_t_unique using btree(f31);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "u_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique using btree(f31);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add constraint con_t_unique unique u_t_unique using btree((abs(f31)) desc);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "u_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (abs(f31) DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add constraint con_t_unique unique u_t_unique using btree((f31 * 2 + 1) desc);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "u_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree ((f31 * 2 + 1) DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- alter table using index
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree(f31 desc, f32 asc);
alter table test_unique add constraint con_t_unique unique using index idx_unique;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "idx_unique" to "con_t_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31 DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree(f31 desc, f32 asc);
alter table test_unique add unique using index idx_unique;
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE CONSTRAINT, btree (f31 DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree((abs(f31)) desc, f32 asc);
alter table test_unique add unique using index idx_unique;
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE CONSTRAINT, btree (abs(f31) DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
create unique index idx_unique on test_unique using btree((f31 * 2 + 1) desc, f32 asc);
alter table test_unique add unique using index idx_unique;
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "idx_unique" UNIQUE CONSTRAINT, btree ((f31 * 2 + 1) DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- test unreserved_keyword index and key
create table test_unique(f31 int, f32 varchar(20));
-- error
alter table test_unique add constraint con_t_unique unique key using btree(f31);
ERROR:  index/key cannot be used as unique name.
LINE 1: ...ter table test_unique add constraint con_t_unique unique key...
                                                             ^
alter table test_unique add constraint con_t_unique unique index using btree(f31);
ERROR:  index/key cannot be used as unique name.
LINE 1: ...ter table test_unique add constraint con_t_unique unique ind...
                                                             ^
drop table test_unique;
-- test primary key is only supported in B mode
-- alter table
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_primary add constraint con_t_pri primary key using btree(f1 desc, f2 asc, f3);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_primary add constraint primary key using btree(f1 desc, f2 asc, f3);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "test_p_primary_pkey" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_primary add primary key using btree(f1 desc, f2 asc, f3);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "test_p_primary_pkey" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
-- error
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_primary add primary key using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  Global partition index does not support EXPRESSION index
drop table test_p_primary;
-- alter table using index
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree(f1 desc, f2 asc, f3);
alter table test_p_primary add constraint con_t_pri primary key using index idx_pri;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "idx_pri" to "con_t_pri"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree(f1 desc, f2 asc, f3);
alter table test_p_primary add constraint primary key using index idx_pri;
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "idx_pri" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree(f1 desc, f2 asc, f3);
alter table test_p_primary add primary key using index idx_pri;
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "idx_pri" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_pri on test_p_primary using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  Global partition index does not support EXPRESSION index
-- error
alter table test_p_primary add primary key using index idx_pri1;
ERROR:  index "idx_pri1" does not exist
LINE 1: alter table test_p_primary add primary key using index idx_p...
                                       ^
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    primary key (f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
-- test foreign key in M mode
-- alter table 
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add constraint con_t_foreign foreign key f_t_foreign (f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add constraint con_t_foreign foreign key(f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add constraint foreign key f_t_foreign(f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add foreign key f_t_foreign(f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_foreign add foreign key(f1) references test_p_primary(f1);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "test_p_foreign_f1_fkey" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
-- test unique key in M mode
-- alter table
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add constraint con_t_unique unique u_t_unique using btree(f1);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "u_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add constraint con_t_unique unique using btree(f1);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "con_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add constraint unique u_t_unique using btree(f1);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "u_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add unique using btree(f1);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_p_unique_f1_key" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_p_unique_f1_key" UNIQUE CONSTRAINT, btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add unique using btree(f1 desc, f2 asc, f3);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_p_unique_f1_f2_f3_key" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_p_unique_f1_f2_f3_key" UNIQUE CONSTRAINT, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_p_unique add constraint con_t_unique unique u_t_unique using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  Global partition index does not support EXPRESSION index
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- alter table using index
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree(f1 desc, f2 asc);
alter table test_p_unique add constraint con_t_unique unique using index idx_unique;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "idx_unique" to "con_t_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree(f1 desc, f2 asc);
alter table test_p_unique add constraint unique using index idx_unique;
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_unique" UNIQUE CONSTRAINT, btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree(f1 desc, f2 asc);
alter table test_p_unique add unique using index idx_unique;
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_unique" UNIQUE CONSTRAINT, btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
create unique index idx_unique on test_p_unique using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
ERROR:  Global partition index does not support EXPRESSION index
alter table test_p_unique add unique using index idx_unique;
ERROR:  index "idx_unique" does not exist
LINE 1: alter table test_p_unique add unique using index idx_unique;
                                      ^
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- test unreserved_keyword index and key
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
-- error
alter table test_p_unique add constraint con_t_unique unique key using btree(f1);
ERROR:  index/key cannot be used as unique name.
LINE 1: ...r table test_p_unique add constraint con_t_unique unique key...
                                                             ^
alter table test_p_unique add constraint con_t_unique unique index using btree(f1);
ERROR:  index/key cannot be used as unique name.
LINE 1: ...r table test_p_unique add constraint con_t_unique unique ind...
                                                             ^
drop table test_p_unique;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key (f11 desc, f12 asc) comment 'primary key' using btree;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree using btree;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique using btree(f31) comment 'unique index' using btree;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique (f31) comment 'unique index' using btree;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique using btree(f31) comment 'unique index' using btree using btree;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
\c postgres
create table t_alter_type(c0 int4range Unique, foreign key(c0) references t_alter_type(c0));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_alter_type_c0_key" for table "t_alter_type"
alter table t_alter_type alter c0 set data type int4range;
ERROR:  could not find cast from int4range to anyrange
drop table t_alter_type;
CREATE TABLE astore_test(id int, name text);
alter table astore_test rename id to tid;
CREATE TABLE cstore_test(id int, name text) with(orientation=column);
alter table cstore_test rename id to tid;
ERROR:  column name "tid" conflicts with a system column name
DROP TABLE astore_test;
DROP TABLE cstore_test;
