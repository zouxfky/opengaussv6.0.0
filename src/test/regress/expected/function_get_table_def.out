create schema test_get_table_def;
set current_schema=test_get_table_def;
create table table_function_export_def_base (
    id integer primary key,
    name varchar(100)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "table_function_export_def_base_pkey" for table "table_function_export_def_base"
create table table_function_export_def (
    id integer primary key,
    fid integer,
    constraint table_export_base_fkey foreign key (fid) references table_function_export_def_base(id)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "table_function_export_def_pkey" for table "table_function_export_def"
select * from pg_get_tabledef('table_function_export_def');
                                            pg_get_tabledef                                            
-------------------------------------------------------------------------------------------------------
 SET search_path = test_get_table_def;                                                                +
 CREATE TABLE table_function_export_def (                                                             +
     id integer NOT NULL,                                                                             +
     fid integer,                                                                                     +
     CONSTRAINT table_export_base_fkey FOREIGN KEY (fid) REFERENCES table_function_export_def_base(id)+
 )                                                                                                    +
 WITH (orientation=row, compression=no);                                                              +
 ALTER TABLE table_function_export_def ADD CONSTRAINT table_function_export_def_pkey PRIMARY KEY (id);
(1 row)

drop table table_function_export_def;
drop table table_function_export_def_base;
--
---- test for partition table
--
--range table
create table table_range1 (id int, a date, b varchar)
partition by range (id)
(
    partition table_range1_p1 values less than(10),
    partition table_range1_p2 values less than(50),
    partition table_range1_p3 values less than(100),
    partition table_range1_p4 values less than(maxvalue)
);
select * from pg_get_tabledef('table_range1');
                      pg_get_tabledef                      
-----------------------------------------------------------
 SET search_path = test_get_table_def;                    +
 CREATE TABLE table_range1 (                              +
     id integer,                                          +
     a timestamp(0) without time zone,                    +
     b character varying                                  +
 )                                                        +
 WITH (orientation=row, compression=no)                   +
 PARTITION BY RANGE (id)                                  +
 (                                                        +
     PARTITION table_range1_p1 VALUES LESS THAN (10),     +
     PARTITION table_range1_p2 VALUES LESS THAN (50),     +
     PARTITION table_range1_p3 VALUES LESS THAN (100),    +
     PARTITION table_range1_p4 VALUES LESS THAN (MAXVALUE)+
 )                                                        +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_range1;
create table table_range2 (id int, a date, b varchar)
partition by range (a)
(
    partition table_range2_p1 values less than('2020-03-01'),
    partition table_range2_p2 values less than('2020-05-01'),
    partition table_range2_p3 values less than('2020-07-01'),
    partition table_range2_p4 values less than(maxvalue)
);
select * from pg_get_tabledef('table_range2');
                        pg_get_tabledef                         
----------------------------------------------------------------
 SET search_path = test_get_table_def;                         +
 CREATE TABLE table_range2 (                                   +
     id integer,                                               +
     a timestamp(0) without time zone,                         +
     b character varying                                       +
 )                                                             +
 WITH (orientation=row, compression=no)                        +
 PARTITION BY RANGE (a)                                        +
 (                                                             +
     PARTITION table_range2_p1 VALUES LESS THAN ('2020-03-01'),+
     PARTITION table_range2_p2 VALUES LESS THAN ('2020-05-01'),+
     PARTITION table_range2_p3 VALUES LESS THAN ('2020-07-01'),+
     PARTITION table_range2_p4 VALUES LESS THAN (MAXVALUE)     +
 )                                                             +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_range2;
create table table_range3 (id int, a date, b varchar)
partition by range (id, a)
(
    partition table_range3_p1 values less than(10, '2020-03-01'),
    partition table_range3_p2 values less than(50, '2020-05-01'),
    partition table_range3_p3 values less than(100, '2020-07-01'),
    partition table_range3_p4 values less than(maxvalue, maxvalue)
);
select * from pg_get_tabledef('table_range3');
                           pg_get_tabledef                           
---------------------------------------------------------------------
 SET search_path = test_get_table_def;                              +
 CREATE TABLE table_range3 (                                        +
     id integer,                                                    +
     a timestamp(0) without time zone,                              +
     b character varying                                            +
 )                                                                  +
 WITH (orientation=row, compression=no)                             +
 PARTITION BY RANGE (id, a)                                         +
 (                                                                  +
     PARTITION table_range3_p1 VALUES LESS THAN (10, '2020-03-01'), +
     PARTITION table_range3_p2 VALUES LESS THAN (50, '2020-05-01'), +
     PARTITION table_range3_p3 VALUES LESS THAN (100, '2020-07-01'),+
     PARTITION table_range3_p4 VALUES LESS THAN (MAXVALUE, MAXVALUE)+
 )                                                                  +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_range3;
create table table_range4 (id int primary key, a date, b varchar)
partition by range (id)
(
    partition table_range4_p1 start (10) end (40) every (10),
    partition table_range4_p2 end (70),
    partition table_range4_p3 start (70),
    partition table_range4_p4 start (100) end (150) every (20)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "table_range4_pkey" for table "table_range4"
select * from pg_get_tabledef('table_range4');
                               pg_get_tabledef                               
-----------------------------------------------------------------------------
 SET search_path = test_get_table_def;                                      +
 CREATE TABLE table_range4 (                                                +
     id integer NOT NULL,                                                   +
     a timestamp(0) without time zone,                                      +
     b character varying                                                    +
 )                                                                          +
 WITH (orientation=row, compression=no)                                     +
 PARTITION BY RANGE (id)                                                    +
 (                                                                          +
     PARTITION table_range4_p1_0 VALUES LESS THAN (10),                     +
     PARTITION table_range4_p1_1 VALUES LESS THAN (20),                     +
     PARTITION table_range4_p1_2 VALUES LESS THAN (30),                     +
     PARTITION table_range4_p1_3 VALUES LESS THAN (40),                     +
     PARTITION table_range4_p2 VALUES LESS THAN (70),                       +
     PARTITION table_range4_p3 VALUES LESS THAN (100),                      +
     PARTITION table_range4_p4_1 VALUES LESS THAN (120),                    +
     PARTITION table_range4_p4_2 VALUES LESS THAN (140),                    +
     PARTITION table_range4_p4_3 VALUES LESS THAN (150)                     +
 )                                                                          +
 ENABLE ROW MOVEMENT;                                                       +
 ALTER TABLE table_range4 ADD CONSTRAINT table_range4_pkey PRIMARY KEY (id);
(1 row)

drop table table_range4;
--interval table
create table table_interval1 (id int, a date, b varchar)
partition by range (a)
interval ('1 day')
(
    partition table_interval1_p1 values less than('2020-03-01'),
    partition table_interval1_p2 values less than('2020-05-01'),
    partition table_interval1_p3 values less than('2020-07-01'),
    partition table_interval1_p4 values less than(maxvalue)
);
select * from pg_get_tabledef('table_interval1');
                          pg_get_tabledef                          
-------------------------------------------------------------------
 SET search_path = test_get_table_def;                            +
 CREATE TABLE table_interval1 (                                   +
     id integer,                                                  +
     a timestamp(0) without time zone,                            +
     b character varying                                          +
 )                                                                +
 WITH (orientation=row, compression=no)                           +
 PARTITION BY RANGE (a)                                           +
 INTERVAL ('1 day')                                               +
 (                                                                +
     PARTITION table_interval1_p1 VALUES LESS THAN ('2020-03-01'),+
     PARTITION table_interval1_p2 VALUES LESS THAN ('2020-05-01'),+
     PARTITION table_interval1_p3 VALUES LESS THAN ('2020-07-01'),+
     PARTITION table_interval1_p4 VALUES LESS THAN (MAXVALUE)     +
 )                                                                +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_interval1;
--list table
create table table_list1 (id int, a date, b varchar)
partition by list (id)
(
    partition table_list1_p1 values (1, 2, 3, 4),
    partition table_list1_p2 values (5, 6, 7, 8),
    partition table_list1_p3 values (9, 10, 11, 12)
);
select * from pg_get_tabledef('table_list1');
                 pg_get_tabledef                  
--------------------------------------------------
 SET search_path = test_get_table_def;           +
 CREATE TABLE table_list1 (                      +
     id integer,                                 +
     a timestamp(0) without time zone,           +
     b character varying                         +
 )                                               +
 WITH (orientation=row, compression=no)          +
 PARTITION BY LIST (id)                          +
 (                                               +
     PARTITION table_list1_p1 VALUES (1,2,3,4),  +
     PARTITION table_list1_p2 VALUES (5,6,7,8),  +
     PARTITION table_list1_p3 VALUES (9,10,11,12)+
 )                                               +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_list1;
create table table_list2 (id int, a date, b varchar)
partition by list (b)
(
    partition table_list2_p1 values ('1', '2', '3', '4'),
    partition table_list2_p2 values ('5', '6', '7', '8'),
    partition table_list2_p3 values ('9', '10', '11', '12')
);
select * from pg_get_tabledef('table_list2');
                     pg_get_tabledef                      
----------------------------------------------------------
 SET search_path = test_get_table_def;                   +
 CREATE TABLE table_list2 (                              +
     id integer,                                         +
     a timestamp(0) without time zone,                   +
     b character varying                                 +
 )                                                       +
 WITH (orientation=row, compression=no)                  +
 PARTITION BY LIST (b)                                   +
 (                                                       +
     PARTITION table_list2_p1 VALUES ('1','2','3','4'),  +
     PARTITION table_list2_p2 VALUES ('5','6','7','8'),  +
     PARTITION table_list2_p3 VALUES ('9','10','11','12')+
 )                                                       +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_list2;
create table table_list3 (id int primary key, a date, b varchar)
partition by list (b)
(
    partition table_list3_p1 values ('1', '2', '3', '4'),
    partition table_list3_p2 values ('5', '6', '7', '8'),
    partition table_list3_p3 values (default)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "table_list3_pkey" for table "table_list3"
select * from pg_get_tabledef('table_list3');
                              pg_get_tabledef                              
---------------------------------------------------------------------------
 SET search_path = test_get_table_def;                                    +
 CREATE TABLE table_list3 (                                               +
     id integer NOT NULL,                                                 +
     a timestamp(0) without time zone,                                    +
     b character varying                                                  +
 )                                                                        +
 WITH (orientation=row, compression=no)                                   +
 PARTITION BY LIST (b)                                                    +
 (                                                                        +
     PARTITION table_list3_p1 VALUES ('1','2','3','4'),                   +
     PARTITION table_list3_p2 VALUES ('5','6','7','8'),                   +
     PARTITION table_list3_p3 VALUES (DEFAULT)                            +
 )                                                                        +
 ENABLE ROW MOVEMENT;                                                     +
 ALTER TABLE table_list3 ADD CONSTRAINT table_list3_pkey PRIMARY KEY (id);
(1 row)

drop table table_list3;
--hash table
create table table_hash1 (id int, a date, b varchar)
partition by hash (id)
(
    partition table_hash1_p1,
    partition table_hash1_p2,
    partition table_hash1_p3
);
select * from pg_get_tabledef('table_hash1');
            pg_get_tabledef             
----------------------------------------
 SET search_path = test_get_table_def; +
 CREATE TABLE table_hash1 (            +
     id integer,                       +
     a timestamp(0) without time zone, +
     b character varying               +
 )                                     +
 WITH (orientation=row, compression=no)+
 PARTITION BY HASH (id)                +
 (                                     +
     PARTITION table_hash1_p1,         +
     PARTITION table_hash1_p2,         +
     PARTITION table_hash1_p3          +
 )                                     +
 ENABLE ROW MOVEMENT;
(1 row)

drop table table_hash1;
--subpartition table
CREATE TABLE list_range_1 (
    col_1 integer primary key,
    col_2 integer,
    col_3 character varying(30) unique,
    col_4 integer
)
WITH (orientation=row, compression=no)
PARTITION BY LIST (col_1) SUBPARTITION BY RANGE (col_2)
(
    PARTITION p_list_1 VALUES (-1,-2,-3,-4,-5,-6,-7,-8,-9,-10)
    (
        SUBPARTITION p_range_1_1 VALUES LESS THAN (-10),
        SUBPARTITION p_range_1_2 VALUES LESS THAN (0),
        SUBPARTITION p_range_1_3 VALUES LESS THAN (10),
        SUBPARTITION p_range_1_4 VALUES LESS THAN (20),
        SUBPARTITION p_range_1_5 VALUES LESS THAN (50)
    ),
    PARTITION p_list_2 VALUES (1,2,3,4,5,6,7,8,9,10),
    PARTITION p_list_3 VALUES (11,12,13,14,15,16,17,18,19,20)
    (
        SUBPARTITION p_range_3_1 VALUES LESS THAN (15),
        SUBPARTITION p_range_3_2 VALUES LESS THAN (MAXVALUE)
    ),
    PARTITION p_list_4 VALUES (21,22,23,24,25,26,27,28,29,30)
    (
        SUBPARTITION p_range_4_1 VALUES LESS THAN (-10),
        SUBPARTITION p_range_4_2 VALUES LESS THAN (0),
        SUBPARTITION p_range_4_3 VALUES LESS THAN (10),
        SUBPARTITION p_range_4_4 VALUES LESS THAN (20),
        SUBPARTITION p_range_4_5 VALUES LESS THAN (50)
    ),
    PARTITION p_list_5 VALUES (31,32,33,34,35,36,37,38,39,40),
    PARTITION p_list_6 VALUES (41,42,43,44,45,46,47,48,49,50)
    (
        SUBPARTITION p_range_6_1 VALUES LESS THAN (-10),
        SUBPARTITION p_range_6_2 VALUES LESS THAN (0),
        SUBPARTITION p_range_6_3 VALUES LESS THAN (10),
        SUBPARTITION p_range_6_4 VALUES LESS THAN (20),
        SUBPARTITION p_range_6_5 VALUES LESS THAN (50)
    ),
    PARTITION p_list_7 VALUES (DEFAULT)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "list_range_1_pkey" for table "list_range_1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "list_range_1_col_3_tableoid_key" for table "list_range_1"
select * from pg_get_tabledef('list_range_1');
                                     pg_get_tabledef                                     
-----------------------------------------------------------------------------------------
 SET search_path = test_get_table_def;                                                  +
 CREATE TABLE list_range_1 (                                                            +
     col_1 integer NOT NULL,                                                            +
     col_2 integer,                                                                     +
     col_3 character varying(30),                                                       +
     col_4 integer                                                                      +
 )                                                                                      +
 WITH (orientation=row, compression=no)                                                 +
 PARTITION BY LIST (col_1) SUBPARTITION BY RANGE (col_2)                                +
 (                                                                                      +
     PARTITION p_list_1 VALUES (-1,-2,-3,-4,-5,-6,-7,-8,-9,-10)                         +
     (                                                                                  +
         SUBPARTITION p_range_1_1 VALUES LESS THAN (-10),                               +
         SUBPARTITION p_range_1_2 VALUES LESS THAN (0),                                 +
         SUBPARTITION p_range_1_3 VALUES LESS THAN (10),                                +
         SUBPARTITION p_range_1_4 VALUES LESS THAN (20),                                +
         SUBPARTITION p_range_1_5 VALUES LESS THAN (50)                                 +
     ),                                                                                 +
     PARTITION p_list_2 VALUES (1,2,3,4,5,6,7,8,9,10)                                   +
     (                                                                                  +
         SUBPARTITION p_list_2_subpartdefault1 VALUES LESS THAN (MAXVALUE)              +
     ),                                                                                 +
     PARTITION p_list_3 VALUES (11,12,13,14,15,16,17,18,19,20)                          +
     (                                                                                  +
         SUBPARTITION p_range_3_1 VALUES LESS THAN (15),                                +
         SUBPARTITION p_range_3_2 VALUES LESS THAN (MAXVALUE)                           +
     ),                                                                                 +
     PARTITION p_list_4 VALUES (21,22,23,24,25,26,27,28,29,30)                          +
     (                                                                                  +
         SUBPARTITION p_range_4_1 VALUES LESS THAN (-10),                               +
         SUBPARTITION p_range_4_2 VALUES LESS THAN (0),                                 +
         SUBPARTITION p_range_4_3 VALUES LESS THAN (10),                                +
         SUBPARTITION p_range_4_4 VALUES LESS THAN (20),                                +
         SUBPARTITION p_range_4_5 VALUES LESS THAN (50)                                 +
     ),                                                                                 +
     PARTITION p_list_5 VALUES (31,32,33,34,35,36,37,38,39,40)                          +
     (                                                                                  +
         SUBPARTITION p_list_5_subpartdefault1 VALUES LESS THAN (MAXVALUE)              +
     ),                                                                                 +
     PARTITION p_list_6 VALUES (41,42,43,44,45,46,47,48,49,50)                          +
     (                                                                                  +
         SUBPARTITION p_range_6_1 VALUES LESS THAN (-10),                               +
         SUBPARTITION p_range_6_2 VALUES LESS THAN (0),                                 +
         SUBPARTITION p_range_6_3 VALUES LESS THAN (10),                                +
         SUBPARTITION p_range_6_4 VALUES LESS THAN (20),                                +
         SUBPARTITION p_range_6_5 VALUES LESS THAN (50)                                 +
     ),                                                                                 +
     PARTITION p_list_7 VALUES (DEFAULT)                                                +
     (                                                                                  +
         SUBPARTITION p_list_7_subpartdefault1 VALUES LESS THAN (MAXVALUE)              +
     )                                                                                  +
 )                                                                                      +
 ENABLE ROW MOVEMENT;                                                                   +
 ALTER TABLE list_range_1 ADD CONSTRAINT list_range_1_col_3_tableoid_key UNIQUE (col_3);+
 ALTER TABLE list_range_1 ADD CONSTRAINT list_range_1_pkey PRIMARY KEY (col_1);
(1 row)

drop table list_range_1;
CREATE TABLE list_hash_2 (
    col_1 integer primary key,
    col_2 integer,
    col_3 character varying(30) unique,
    col_4 integer
)
WITH (orientation=row, compression=no)
PARTITION BY LIST (col_2) SUBPARTITION BY HASH (col_3)
(
    PARTITION p_list_1 VALUES (-1,-2,-3,-4,-5,-6,-7,-8,-9,-10)
    (
        SUBPARTITION p_hash_1_1,
        SUBPARTITION p_hash_1_2,
        SUBPARTITION p_hash_1_3
    ),
    PARTITION p_list_2 VALUES (1,2,3,4,5,6,7,8,9,10),
    PARTITION p_list_3 VALUES (11,12,13,14,15,16,17,18,19,20)
    (
        SUBPARTITION p_hash_3_1,
        SUBPARTITION p_hash_3_2
    ),
    PARTITION p_list_4 VALUES (21,22,23,24,25,26,27,28,29,30)
    (
        SUBPARTITION p_hash_4_1,
        SUBPARTITION p_hash_4_2,
        SUBPARTITION p_hash_4_3,
        SUBPARTITION p_hash_4_4,
        SUBPARTITION p_hash_4_5
    ),
    PARTITION p_list_5 VALUES (31,32,33,34,35,36,37,38,39,40),
    PARTITION p_list_6 VALUES (41,42,43,44,45,46,47,48,49,50)
    (
        SUBPARTITION p_hash_6_1,
        SUBPARTITION p_hash_6_2,
        SUBPARTITION p_hash_6_3,
        SUBPARTITION p_hash_6_4,
        SUBPARTITION p_hash_6_5
    ),
    PARTITION p_list_7 VALUES (DEFAULT)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "list_hash_2_pkey" for table "list_hash_2"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "list_hash_2_col_3_tableoid_key" for table "list_hash_2"
create unique index list_hash_2_idx1 on list_hash_2(col_2, col_3, col_4) local;
create index list_hash_2_idx2 on list_hash_2(col_3, col_1) local;
create index list_hash_2_idx3 on list_hash_2(col_4) global;
select * from pg_get_tabledef('list_hash_2');
                                       pg_get_tabledef                                        
----------------------------------------------------------------------------------------------
 SET search_path = test_get_table_def;                                                       +
 CREATE TABLE list_hash_2 (                                                                  +
     col_1 integer NOT NULL,                                                                 +
     col_2 integer,                                                                          +
     col_3 character varying(30),                                                            +
     col_4 integer                                                                           +
 )                                                                                           +
 WITH (orientation=row, compression=no)                                                      +
 PARTITION BY LIST (col_2) SUBPARTITION BY HASH (col_3)                                      +
 (                                                                                           +
     PARTITION p_list_1 VALUES (-1,-2,-3,-4,-5,-6,-7,-8,-9,-10)                              +
     (                                                                                       +
         SUBPARTITION p_hash_1_1,                                                            +
         SUBPARTITION p_hash_1_2,                                                            +
         SUBPARTITION p_hash_1_3                                                             +
     ),                                                                                      +
     PARTITION p_list_2 VALUES (1,2,3,4,5,6,7,8,9,10)                                        +
     (                                                                                       +
         SUBPARTITION p_list_2_subpartdefault1                                               +
     ),                                                                                      +
     PARTITION p_list_3 VALUES (11,12,13,14,15,16,17,18,19,20)                               +
     (                                                                                       +
         SUBPARTITION p_hash_3_1,                                                            +
         SUBPARTITION p_hash_3_2                                                             +
     ),                                                                                      +
     PARTITION p_list_4 VALUES (21,22,23,24,25,26,27,28,29,30)                               +
     (                                                                                       +
         SUBPARTITION p_hash_4_1,                                                            +
         SUBPARTITION p_hash_4_2,                                                            +
         SUBPARTITION p_hash_4_3,                                                            +
         SUBPARTITION p_hash_4_4,                                                            +
         SUBPARTITION p_hash_4_5                                                             +
     ),                                                                                      +
     PARTITION p_list_5 VALUES (31,32,33,34,35,36,37,38,39,40)                               +
     (                                                                                       +
         SUBPARTITION p_list_5_subpartdefault1                                               +
     ),                                                                                      +
     PARTITION p_list_6 VALUES (41,42,43,44,45,46,47,48,49,50)                               +
     (                                                                                       +
         SUBPARTITION p_hash_6_1,                                                            +
         SUBPARTITION p_hash_6_2,                                                            +
         SUBPARTITION p_hash_6_3,                                                            +
         SUBPARTITION p_hash_6_4,                                                            +
         SUBPARTITION p_hash_6_5                                                             +
     ),                                                                                      +
     PARTITION p_list_7 VALUES (DEFAULT)                                                     +
     (                                                                                       +
         SUBPARTITION p_list_7_subpartdefault1                                               +
     )                                                                                       +
 )                                                                                           +
 ENABLE ROW MOVEMENT;                                                                        +
 CREATE INDEX list_hash_2_idx3 ON list_hash_2 USING btree (col_4) TABLESPACE pg_default;     +
 CREATE INDEX list_hash_2_idx2 ON list_hash_2 USING btree (col_3, col_1) LOCAL(              +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_1_1_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_1_2_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_1_3_col_3_col_1_idx                                             +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_list_2_subpartdefault1_col_3_col_1_idx                               +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_3_1_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_3_2_col_3_col_1_idx                                             +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_4_1_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_4_2_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_4_3_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_4_4_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_4_5_col_3_col_1_idx                                             +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_list_5_subpartdefault1_col_3_col_1_idx                               +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_6_1_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_6_2_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_6_3_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_6_4_col_3_col_1_idx,                                            +
         SUBPARTITION p_hash_6_5_col_3_col_1_idx                                             +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_list_7_subpartdefault1_col_3_col_1_idx                               +
     )                                                                                       +
 )  TABLESPACE pg_default;                                                                   +
 CREATE UNIQUE INDEX list_hash_2_idx1 ON list_hash_2 USING btree (col_2, col_3, col_4) LOCAL(+
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_1_1_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_1_2_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_1_3_col_2_col_3_col_4_idx                                       +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_list_2_subpartdefault1_col_2_col_3_col_4_idx                         +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_3_1_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_3_2_col_2_col_3_col_4_idx                                       +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_4_1_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_4_2_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_4_3_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_4_4_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_4_5_col_2_col_3_col_4_idx                                       +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_list_5_subpartdefault1_col_2_col_3_col_4_idx                         +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_hash_6_1_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_6_2_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_6_3_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_6_4_col_2_col_3_col_4_idx,                                      +
         SUBPARTITION p_hash_6_5_col_2_col_3_col_4_idx                                       +
     ),                                                                                      +
     PARTITION partition_name(                                                               +
         SUBPARTITION p_list_7_subpartdefault1_col_2_col_3_col_4_idx                         +
     )                                                                                       +
 )  TABLESPACE pg_default;                                                                   +
 ALTER TABLE list_hash_2 ADD CONSTRAINT list_hash_2_col_3_tableoid_key UNIQUE (col_3);       +
 ALTER TABLE list_hash_2 ADD CONSTRAINT list_hash_2_pkey PRIMARY KEY (col_1);
(1 row)

drop table list_hash_2;
create table generated_test(a int, b int generated always as (length((a)::text)) stored);
select * from pg_get_tabledef('generated_test');
                       pg_get_tabledef                        
--------------------------------------------------------------
 SET search_path = test_get_table_def;                       +
 CREATE TABLE generated_test (                               +
     a integer,                                              +
     b integer GENERATED ALWAYS AS (length((a)::text)) STORED+
 )                                                           +
 WITH (orientation=row, compression=no);
(1 row)

drop table generated_test;
--type table
create type test_type_table is(a varchar2, b int);
create table test_type_table_t of test_type_table;
select pg_get_tabledef('test_type_table_t');
                  pg_get_tabledef                  
---------------------------------------------------
 SET search_path = test_get_table_def;            +
 CREATE TABLE test_type_table_t of test_type_table+
 WITH (orientation=row, compression=no);
(1 row)

drop table test_type_table_t;
drop type test_type_table;
reset current_schema;
drop schema test_get_table_def cascade;
drop database if exists b1;
NOTICE:  database "b1" does not exist, skipping
create database b1 dbcompatibility 'b';
 
\c b1
CREATE TABLE range_list
(
    month_code VARCHAR2 ( 30 ) NOT NULL ,
    dept_code  VARCHAR2 ( 30 ) NOT NULL ,
    user_no    VARCHAR2 ( 30 ) NOT NULL ,
    c  int,
    unique u_range (c desc)
) 
PARTITION BY RANGE (month_code) SUBPARTITION BY LIST (dept_code)
(
  PARTITION p_201901 VALUES LESS THAN( '201903' )
  (
    SUBPARTITION p_201901_a values ('1'),
    SUBPARTITION p_201901_b values ('2')
  ),
  PARTITION p_201902 VALUES LESS THAN( '201910' )
  (
    SUBPARTITION p_201902_a values ('1'),
    SUBPARTITION p_201902_b values ('2')
  )
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_range" for table "range_list"
select pg_get_tabledef('range_list');
                                        pg_get_tabledef                                        
-----------------------------------------------------------------------------------------------
 SET search_path = public;                                                                    +
 CREATE TABLE range_list (                                                                    +
     month_code character varying(30) NOT NULL,                                               +
     dept_code character varying(30) NOT NULL,                                                +
     user_no character varying(30) NOT NULL,                                                  +
     c integer                                                                                +
 )                                                                                            +
 WITH (orientation=row, compression=no)                                                       +
 PARTITION BY RANGE (month_code) SUBPARTITION BY LIST (dept_code)                             +
 (                                                                                            +
     PARTITION p_201901 VALUES LESS THAN ('201903')                                           +
     (                                                                                        +
         SUBPARTITION p_201901_a VALUES ('1'),                                                +
         SUBPARTITION p_201901_b VALUES ('2')                                                 +
     ),                                                                                       +
     PARTITION p_201902 VALUES LESS THAN ('201910')                                           +
     (                                                                                        +
         SUBPARTITION p_201902_a VALUES ('1'),                                                +
         SUBPARTITION p_201902_b VALUES ('2')                                                 +
     )                                                                                        +
 )                                                                                            +
 ENABLE ROW MOVEMENT;                                                                         +
 ALTER TABLE range_list ADD CONSTRAINT u_range UNIQUE USING btree (c DESC) INCLUDE (tableoid);
(1 row)

create table test_unique
(
    u1 int,
    u2 int,
    constraint con_test2 unique u_t1 using btree ((abs((u1+u2)*2)) desc)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_t1" for table "test_unique"
select pg_get_tabledef('test_unique');
                                       pg_get_tabledef                                       
---------------------------------------------------------------------------------------------
 SET search_path = public;                                                                  +
 CREATE TABLE test_unique (                                                                 +
     u1 integer,                                                                            +
     u2 integer                                                                             +
 )                                                                                          +
 WITH (orientation=row, compression=no);                                                    +
 ALTER TABLE test_unique ADD CONSTRAINT u_t1 UNIQUE USING btree ((abs((u1 + u2) * 2)) DESC);
(1 row)

 
create table test_primary
(
    p1 int,
    p2 int,
    constraint con_test1 primary key using btree (p1 desc)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_test1" for table "test_primary"
select pg_get_tabledef('test_primary');
                                    pg_get_tabledef                                    
---------------------------------------------------------------------------------------
 SET search_path = public;                                                            +
 CREATE TABLE test_primary (                                                          +
     p1 integer NOT NULL,                                                             +
     p2 integer                                                                       +
 )                                                                                    +
 WITH (orientation=row, compression=no);                                              +
 ALTER TABLE test_primary ADD CONSTRAINT con_test1 PRIMARY KEY USING btree  (p1 DESC);
(1 row)

 
create table test_primary1
(
    p11 int,
    p21 int,
    constraint primary key using btree (p11 asc)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary1_pkey" for table "test_primary1"
select pg_get_tabledef('test_primary1');
                                       pg_get_tabledef                                       
---------------------------------------------------------------------------------------------
 SET search_path = public;                                                                  +
 CREATE TABLE test_primary1 (                                                               +
     p11 integer NOT NULL,                                                                  +
     p21 integer                                                                            +
 )                                                                                          +
 WITH (orientation=row, compression=no);                                                    +
 ALTER TABLE test_primary1 ADD CONSTRAINT test_primary1_pkey PRIMARY KEY USING btree  (p11);
(1 row)

 
 
create table test_unique12
(
    u12 int,
    u22 int,
    constraint unique u_t12 using btree (u22 desc)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_t12" for table "test_unique12"
select pg_get_tabledef('test_unique12');
                                pg_get_tabledef                                
-------------------------------------------------------------------------------
 SET search_path = public;                                                    +
 CREATE TABLE test_unique12 (                                                 +
     u12 integer,                                                             +
     u22 integer                                                              +
 )                                                                            +
 WITH (orientation=row, compression=no);                                      +
 ALTER TABLE test_unique12 ADD CONSTRAINT u_t12 UNIQUE USING btree (u22 DESC);
(1 row)

 
create table test_fk
(
    f1 int,
    f2 int,
    constraint con_test3 foreign key fk_t3 (f1) references test_primary(p1)
);
select pg_get_tabledef('test_fk');
                            pg_get_tabledef                            
-----------------------------------------------------------------------
 SET search_path = public;                                            +
 CREATE TABLE test_fk (                                               +
     f1 integer,                                                      +
     f2 integer,                                                      +
     CONSTRAINT con_test3 FOREIGN KEY (f1) REFERENCES test_primary(p1)+
 )                                                                    +
 WITH (orientation=row, compression=no);
(1 row)

 
CREATE TABLE test_us
(
    us1 int,
    us2 varchar(20),
    constraint u1 primary key (us2)
)with (storage_type=USTORE);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "u1" for table "test_us"
select pg_get_tabledef('test_us');
                                          pg_get_tabledef                                          
---------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                        +
 CREATE TABLE test_us (                                                                           +
     us1 integer,                                                                                 +
     us2 character varying(20) NOT NULL                                                           +
 )                                                                                                +
 WITH (orientation=row, storage_type=ustore, compression=no);                                     +
 ALTER TABLE test_us ADD CONSTRAINT u1 PRIMARY KEY USING ubtree  (us2) WITH (storage_type=ustore);
(1 row)

 
drop table test_unique;
drop table range_list;
drop table test_unique12;
drop table test_fk;
drop table test_primary;
drop table test_primary1;
drop table test_us; 
drop database if exists mysql;
NOTICE:  database "mysql" does not exist, skipping
create database mysql dbcompatibility 'B';
\c mysql
create table if not exists test(
    a int,
    b timestamp default now() on update current_timestamp,
    c timestamptz on update current_timestamp(5));
select * from pg_get_tabledef('test');
                               pg_get_tabledef                                
------------------------------------------------------------------------------
 SET search_path = public;                                                   +
 CREATE TABLE test (                                                         +
     a integer,                                                              +
     b timestamp without time zone DEFAULT now() ON UPDATE CURRENT_TIMESTAMP,+
     c timestamp with time zone ON UPDATE CURRENT_TIMESTAMP(5)               +
 )                                                                           +
 WITH (orientation=row, compression=no);
(1 row)

\c regression
DROP database mysql;
