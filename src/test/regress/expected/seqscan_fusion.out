create schema lazyagg;
set current_schema=lazyagg;
set rewrite_rule=lazyagg;
------------------------------------------------------------------------------------
-- create table
------------------------------------------------------------------------------------
create table t (a int, b int, c int, d int);
create table t1 (a int, b int, c int, d int);
create table t2 (a int, b int, c int, d int);
create table t3 (a int, b int, c int, d int);
insert into t values 
 (1, 1, 1, 1)
,(1, 1, 1, 2)
,(1, 1, 2, 1)
,(1, 1, 2, 2)
,(1, 2, 1, 1)
,(1, 2, 1, 2)
,(1, 2, 2, 1)
,(1, 2, 2, 2)
,(1, 3, 3, 3)
,(2, 5, 5, 5)
,(2, NULL, 6, 6)
,(2, 6, NULL, 6)
,(2, 6, 6, NULL)
,(2, NULL, NULL, 7)
,(2, NULL, 7, NULL)
,(2, 7, NULL, NULL)
,(3, NULL, NULL, NULL)
;
insert into t1 select * from t;
insert into t2 select * from t;
insert into t3 select * from t;
------------------------------------------------------------------------------------
-- basic single sub-query
------------------------------------------------------------------------------------
-- valid for lazy agg
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |  24
 2 |  24
 3 |   3
 5 |   5
 6 |  12
 7 |    
(6 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |  16
 2 |  16
 3 |   1
 5 |   1
 6 |   2
 7 |   0
(6 rows)

explain verbose select t.b, sum(cc) from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=12)
   Output: t.b, ((count(1::bigint))::numeric)
   Sort Key: t.b, ((count(1::bigint))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=12)
         Output: t.b, count(1::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

select t.b, sum(cc) from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |  16
 2 |  16
 3 |   1
 5 |   1
 6 |   4
 7 |   1
(6 rows)

-- invalid for lazy agg
explain verbose select t.b, sum(cc) from (select b, min(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=16)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=16)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, min(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

select t.b, sum(cc) from (select b, min(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |   4
 2 |   4
 3 |   3
 5 |   5
 6 |  12
 7 |    
(6 rows)

explain verbose select t.b, avg(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=114.34..114.84 rows=200 width=44)
   Output: t.b, (avg(s1.cc))
   Sort Key: t.b, (avg(s1.cc))
   ->  HashAggregate  (cost=104.20..106.70 rows=200 width=44)
         Output: t.b, avg(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

select t.b, avg(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b |        avg         
---+--------------------
 1 | 6.0000000000000000
 2 | 6.0000000000000000
 3 | 3.0000000000000000
 5 | 5.0000000000000000
 6 | 6.0000000000000000
 7 |                   
(6 rows)

------------------------------------------------------------------------------------
-- basic setop
------------------------------------------------------------------------------------
-- same functions
explain verbose select t.b, min(cc) from (select b, min(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=637.09..637.59 rows=200 width=12)
   Output: t.b, (min(t1.c))
   Sort Key: t.b, (min(t1.c))
   ->  HashAggregate  (cost=627.45..629.45 rows=200 width=12)
         Output: t.b, min(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..469.74 rows=31542 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..55.52 rows=3552 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(18 rows)

-- different functions: f(f union all g) or f(g union all f)
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=460.34..460.84 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=450.70..452.70 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..362.96 rows=17547 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..90.60 rows=1976 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t1.b, t1.c
                     ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 2".b, "*SELECT* 2".cc
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t2.b, min(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, count(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=418.38..418.88 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=408.74..410.74 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..321.00 rows=17547 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..68.40 rows=1976 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 2".cc, "*SELECT* 2".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t2.b, count(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, min(cc) from (select b, sum(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=455.90..456.40 rows=200 width=20)
   Output: t.b, (min((sum(t1.c))))
   Sort Key: t.b, (min((sum(t1.c))))
   ->  HashAggregate  (cost=446.26..448.26 rows=200 width=20)
         Output: t.b, min((sum(t1.c)))
         Group By Key: t.b
         ->  Hash Join  (cost=86.60..358.52 rows=17547 distinct=[200, 200] width=12)
               Output: (sum(t1.c)), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=36.64..86.16 rows=1976 width=9)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t1.b, sum(t1.c)
                           Group By Key: t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t1.b, t1.c
                     ->  Subquery Scan on "*SELECT* 2"  (cost=0.00..45.52 rows=1776 width=8)
                           Output: "*SELECT* 2".b, "*SELECT* 2".cc
                           ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

-- different functions: f(g union all g)
explain verbose select t.b, sum(cc) from (select b, max(c) as cc from t1 group by b union all select b, max(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=185.84..186.34 rows=200 width=16)
   Output: t.b, (sum("*SELECT* 1".cc))
   Sort Key: t.b, (sum("*SELECT* 1".cc))
   ->  HashAggregate  (cost=176.20..178.20 rows=200 width=16)
         Output: t.b, sum("*SELECT* 1".cc)
         Group By Key: t.b
         ->  Hash Join  (cost=86.28..158.44 rows=3552 distinct=[200, 200] width=8)
               Output: "*SELECT* 1".cc, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=81.28..81.28 rows=400 width=8)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".b
                     ->  Append  (cost=36.64..81.28 rows=400 width=8)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t1.b, max(t1.c)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t1.b, t1.c
                           ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t2.b, max(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
(28 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b union all select b, count(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=637.59..638.09 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=627.45..629.95 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..469.74 rows=31542 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..55.52 rows=3552 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(18 rows)

-- different functions: f(g union all h)
explain verbose select t.b, sum(cc) from (select b, min(c) as cc from t1 group by b union all select b, max(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=185.84..186.34 rows=200 width=16)
   Output: t.b, (sum("*SELECT* 1".cc))
   Sort Key: t.b, (sum("*SELECT* 1".cc))
   ->  HashAggregate  (cost=176.20..178.20 rows=200 width=16)
         Output: t.b, sum("*SELECT* 1".cc)
         Group By Key: t.b
         ->  Hash Join  (cost=86.28..158.44 rows=3552 distinct=[200, 200] width=8)
               Output: "*SELECT* 1".cc, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=81.28..81.28 rows=400 width=8)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".b
                     ->  Append  (cost=36.64..81.28 rows=400 width=8)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t1.b, min(t1.c)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t1.b, t1.c
                           ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t2.b, max(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
(28 rows)

-- other set op
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union select b, sum(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Sort  (cost=195.84..196.34 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=186.20..188.20 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=96.28..168.44 rows=3552 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=91.28..91.28 rows=400 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=83.28..91.28 rows=400 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=83.28..87.28 rows=400 width=16)
                                 Output: t1.b, (sum(t1.c))
                                 Group By Key: t1.b, (sum(t1.c))
                                 ->  Append  (cost=36.64..81.28 rows=400 width=16)
                                       ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                             Output: t1.b, sum(t1.c)
                                             Group By Key: t1.b
                                             ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                                   Output: t1.b, t1.c
                                       ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                             Output: t2.b, sum(t2.c)
                                             Group By Key: t2.b
                                             ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                   Output: t2.b, t2.c
(29 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b intersect all select b, sum(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=158.48..158.98 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=148.84..150.84 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=87.78..139.96 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=85.28..85.28 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..85.28 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashSetOp Intersect All  (cost=36.64..83.28 rows=200 width=16)
                                 Output: "*SELECT* 1".b, "*SELECT* 1".cc, (0)
                                 ->  Append  (cost=36.64..81.28 rows=400 width=16)
                                       ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=16)
                                             Output: "*SELECT* 1".b, "*SELECT* 1".cc, 0
                                             ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                                   Output: t1.b, sum(t1.c)
                                                   Group By Key: t1.b
                                                   ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                                         Output: t1.b, t1.c
                                       ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=16)
                                             Output: "*SELECT* 2".b, "*SELECT* 2".cc, 1
                                             ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                                   Output: t2.b, sum(t2.c)
                                                   Group By Key: t2.b
                                                   ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                         Output: t2.b, t2.c
(32 rows)

------------------------------------------------------------------------------------
-- complex setop (single super agg)
------------------------------------------------------------------------------------
-- uncomplete agg in setop branch
explain verbose select t.b, sum(cc) from (select b, c as cc from t1 union all select b, sum(c) as cc from t2 group by b union all select b, sum(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=1041.28..1041.78 rows=200 width=44)
   Output: t.b, (sum((("*SELECT* 1".cc)::bigint)))
   Sort Key: t.b, (sum((("*SELECT* 1".cc)::bigint)))
   ->  HashAggregate  (cost=1031.63..1033.63 rows=200 width=44)
         Output: t.b, sum((("*SELECT* 1".cc)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..795.07 rows=47313 distinct=[200, 200] width=12)
               Output: (("*SELECT* 1".cc)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=0.00..145.44 rows=5328 width=8)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..45.52 rows=1776 width=8)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t1.b, t1.c
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t2.b, t2.c
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(22 rows)

-- over-complete agg in setop branch, agg number not match
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc, sum(d) as dd from t1 group by b union all select b, sum(c) as cc, count(d) as dd from t2 group by b union all select b, sum(c) as cc, count(*) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort  (cost=925.84..926.34 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=916.20..918.20 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

-- three items, all setop are union all, item(s) have same function
explain verbose select t.b, min(cc) from (select b, min(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b union all select b, min(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=925.84..926.34 rows=200 width=12)
   Output: t.b, (min(t1.c))
   Sort Key: t.b, (min(t1.c))
   ->  HashAggregate  (cost=916.20..918.20 rows=200 width=12)
         Output: t.b, min(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b union all select b, count(c) as cc from t2 group by b union all select b, count(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=926.34..926.84 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=916.20..918.70 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

-- three items, all setop are union all, item(s) have different function, non-delay rewrite
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b union all select b, max(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=789.04..789.54 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=779.40..781.40 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..612.81 rows=33318 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..140.56 rows=3752 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t1.b, t1.c
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t2.b, t2.c
                     ->  Subquery Scan on "*SELECT* 3"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 3".b, "*SELECT* 3".cc
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t3.b, max(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(25 rows)

-- three items, all setop are union all, item(s) have different function, delay rewrite
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b union all select b, count(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=707.12..707.62 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=697.48..699.48 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..530.89 rows=33318 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..96.16 rows=3752 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.b
                     ->  Subquery Scan on "*SELECT* 3"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 3".cc, "*SELECT* 3".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, count(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(25 rows)

explain verbose select t.b, sum(cc) from (select b, count(*) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b union all select b, sum(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=707.12..707.62 rows=200 width=44)
   Output: t.b, (sum("*SELECT* 1".cc))
   Sort Key: t.b, (sum("*SELECT* 1".cc))
   ->  HashAggregate  (cost=697.48..699.48 rows=200 width=44)
         Output: t.b, sum("*SELECT* 1".cc)
         Group By Key: t.b
         ->  Hash Join  (cost=86.60..530.89 rows=33318 distinct=[200, 200] width=12)
               Output: "*SELECT* 1".cc, t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=36.64..96.16 rows=3752 width=12)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 1".cc, "*SELECT* 1".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, count(*)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(25 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, count(*) as cc from t2 group by b union all select b, count(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=488.41..488.91 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=478.77..480.77 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..382.15 rows=19323 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..109.04 rows=2176 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 2".cc, "*SELECT* 2".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t2.b, count(*)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: t2.b
                     ->  Subquery Scan on "*SELECT* 3"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 3".cc, "*SELECT* 3".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, count(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(30 rows)

-- three items, not all setop(s) are union all, item(s) have same function
explain verbose select t.b, min(cc) from (select b, min(c) as cc from t1 group by b intersect (select b, min(c) as cc from t2 group by b union all select b, min(c) as cc from t3 group by b)) s1, t where s1.b=t.b group by t.b order by 1,2;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=200.12..200.62 rows=200 width=12)
   Output: t.b, (min(s1.cc))
   Sort Key: t.b, (min(s1.cc))
   ->  HashAggregate  (cost=190.48..192.48 rows=200 width=12)
         Output: t.b, min(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=129.42..181.60 rows=1776 distinct=[200, 200] width=8)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=126.92..126.92 rows=200 width=8)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..126.92 rows=200 width=8)
                           Output: s1.cc, s1.b
                           ->  HashSetOp Intersect  (cost=36.64..124.92 rows=200 width=12)
                                 Output: "*SELECT* 1".b, "*SELECT* 1".cc, (0)
                                 ->  Append  (cost=36.64..121.92 rows=600 width=12)
                                       ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=12)
                                             Output: "*SELECT* 1".b, "*SELECT* 1".cc, 0
                                             ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                                   Output: t1.b, min(t1.c)
                                                   Group By Key: t1.b
                                                   ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                                         Output: t1.b, t1.c
                                       ->  Result  (cost=36.64..81.28 rows=400 width=12)
                                             Output: t2.b, (min(t2.c)), 1
                                             ->  Append  (cost=36.64..81.28 rows=400 width=12)
                                                   ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                                         Output: t2.b, min(t2.c)
                                                         Group By Key: t2.b
                                                         ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                               Output: t2.b, t2.c
                                                   ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                                         Output: t3.b, min(t3.c)
                                                         Group By Key: t3.b
                                                         ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                                               Output: t3.b, t3.c
(38 rows)

------------------------------------------------------------------------------------
-- parent-query check
------------------------------------------------------------------------------------
-- no agg func OR no group by
explain verbose select t.b from (select b, max(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b from (select b, sum(c) as cc from t1 group by b) s1, (select b, count(c) as cc from t1 group by b) s2, t where s1.b=t.b and s2.b=t.b group by t.b order by 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=2286.88..2287.38 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=2277.24..2279.24 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=99.92..1927.12 rows=140046 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (lazyagg.t1.b = t.b)
               ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
                     Output: lazyagg.t1.b, lazyagg.t1.b
                     Hash Cond: (lazyagg.t1.b = lazyagg.t1.b)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                           Output: lazyagg.t1.a, lazyagg.t1.b, lazyagg.t1.c, lazyagg.t1.d
                     ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                           Output: lazyagg.t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: lazyagg.t1.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(22 rows)

explain verbose select b from (select b from t1 group by b) group by b;
                             QUERY PLAN                             
--------------------------------------------------------------------
 HashAggregate  (cost=32.20..34.20 rows=200 width=4)
   Output: t1.b
   Group By Key: t1.b
   ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
         Output: t1.b
(5 rows)

explain verbose select sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=338.73..338.73 rows=1 width=36)
   Output: (sum((t1.c)::bigint))
   Sort Key: (sum((t1.c)::bigint))
   ->  Aggregate  (cost=338.71..338.72 rows=1 width=36)
         Output: sum((t1.c)::bigint)
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t1.c
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(14 rows)

explain verbose select sum(cc) from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=99.78..99.79 rows=1 width=40)
   Output: (sum(s1.cc))
   Sort Key: (sum(s1.cc))
   ->  Aggregate  (cost=99.76..99.77 rows=1 width=40)
         Output: sum(s1.cc)
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: s1.cc
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, count(*)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: t1.b
(19 rows)

explain verbose select sum(b) from (select b from t1 group by b);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate  (cost=36.70..36.71 rows=1 width=12)
   Output: sum(t1.b)
   ->  HashAggregate  (cost=32.20..34.20 rows=200 width=4)
         Output: t1.b
         Group By Key: t1.b
         ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
               Output: t1.b
(7 rows)

-- agg param is not in subquery, in subquery and super table, OR in multiple subquery
explain verbose select t.b, sum(t.d) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=16)
   Output: t.b, (sum(t.d))
   Sort Key: t.b, (sum(t.d))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=16)
         Output: t.b, sum(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc), sum(t.d) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=56)
   Output: t.b, (sum(s1.cc)), (sum(t.d))
   Sort Key: t.b, (sum(s1.cc)), (sum(t.d))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=56)
         Output: t.b, sum(s1.cc), sum(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=16)
               Output: s1.cc, t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc), sum(t.d) from (select b, sum(c) as cc, a, sum(d) as dd from t1 group by b,a) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=127.16..127.66 rows=200 width=56)
   Output: t.b, (sum(s1.cc)), (sum(t.d))
   Sort Key: t.b, (sum(s1.cc)), (sum(t.d))
   ->  HashAggregate  (cost=117.52..119.52 rows=200 width=56)
         Output: t.b, sum(s1.cc), sum(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=52.02..104.20 rows=1776 distinct=[200, 200] width=16)
               Output: s1.cc, t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=49.52..49.52 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=45.52..49.52 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=45.52..47.52 rows=200 width=32)
                                 Output: t1.b, sum(t1.c), t1.a, sum(t1.d)
                                 Group By Key: t1.b, t1.a
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=16)
                                       Output: t1.b, t1.a, t1.c, t1.d
(20 rows)

explain verbose select t.b, sum(s1.cc) from (select b, sum(c) as cc from t1 group by b) s1, (select b, sum(c) as cc from t2 group by b) s2, t where s1.b=t.b and s2.b=t.b group by t.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=455.34..455.84 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=445.69..447.69 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=93.10..327.41 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
                     Output: t1.c, t1.b, s2.b
                     Hash Cond: (t1.b = s2.b)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.a, t1.b, t1.c, t1.d
                     ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                           Output: s2.b
                           ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=4)
                                 Output: s2.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t2.b, sum(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(27 rows)

explain verbose select t.b, max(s1.cc), max(s2.cc) from (select b, max(c) as cc from t1 group by b) s1, (select b, max(c) as cc from t2 group by b) s2, t where s1.b=t.b and s2.b=t.b group by t.b order by 1,2,3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Sort  (cost=164.17..164.67 rows=200 width=20)
   Output: t.b, (max((max(t1.c)))), (max(s2.cc))
   Sort Key: t.b, (max((max(t1.c)))), (max(s2.cc))
   ->  HashAggregate  (cost=154.53..156.53 rows=200 width=20)
         Output: t.b, max((max(t1.c))), max(s2.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=89.03..141.21 rows=1776 distinct=[200, 200] width=12)
               Output: (max(t1.c)), s2.cc, t.b
               Hash Cond: (t.b = t1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=86.53..86.53 rows=200 width=16)
                     Output: (max(t1.c)), t1.b, s2.cc, s2.b
                     ->  Hash Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=16)
                           Output: (max(t1.c)), t1.b, s2.cc, s2.b
                           Hash Cond: (t1.b = s2.b)
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, max(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
                           ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                                 Output: s2.cc, s2.b
                                 ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=8)
                                       Output: s2.cc, s2.b
                                       ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                             Output: t2.b, max(t2.c)
                                             Group By Key: t2.b
                                             ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                   Output: t2.b, t2.c
(30 rows)

explain verbose select t.b, min(cc), min(t.d) from (select b, min(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=20)
   Output: t.b, (min(s1.cc)), (min(t.d))
   Sort Key: t.b, (min(s1.cc)), (min(t.d))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=20)
         Output: t.b, min(s1.cc), min(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, min(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- expr on agg param
explain verbose select t.b, sum(cc+cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=44)
   Output: t.b, (sum((s1.cc + s1.cc)))
   Sort Key: t.b, (sum((s1.cc + s1.cc)))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=44)
         Output: t.b, sum((s1.cc + s1.cc))
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc*random()) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=127.16..127.66 rows=200 width=20)
   Output: t.b, (sum(((s1.cc)::double precision * random())))
   Sort Key: t.b, (sum(((s1.cc)::double precision * random())))
   ->  HashAggregate  (cost=117.52..119.52 rows=200 width=20)
         Output: t.b, sum(((s1.cc)::double precision * random()))
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc)*2.3 from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.28..388.78 rows=200 width=40)
   Output: t.b, ((sum((t1.c)::bigint) * 2.3))
   Sort Key: t.b, ((sum((t1.c)::bigint) * 2.3))
   ->  HashAggregate  (cost=378.13..380.63 rows=200 width=40)
         Output: t.b, (sum((t1.c)::bigint) * 2.3)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- volatile
explain verbose select t.b, sum(cc)*random() from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=389.28..389.78 rows=200 width=40)
   Output: t.b, (((sum((t1.c)::bigint))::double precision * random()))
   Sort Key: t.b, (((sum((t1.c)::bigint))::double precision * random()))
   ->  HashAggregate  (cost=378.13..381.63 rows=200 width=40)
         Output: t.b, ((sum((t1.c)::bigint))::double precision * random())
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- no subquery
explain verbose select t.b, sum(t1.c) from t1, t where t1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.35..348.85 rows=200 width=16)
   Output: t.b, (sum(t1.c))
   Sort Key: t.b, (sum(t1.c))
   ->  HashAggregate  (cost=338.71..340.71 rows=200 width=16)
         Output: t.b, sum(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

------------------------------------------------------------------------------------
-- child-query check
------------------------------------------------------------------------------------
-- no setop no agg
explain verbose select t.b, sum(cc) from (select b, c as cc from t1) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.35..348.85 rows=200 width=16)
   Output: t.b, (sum(t1.c))
   Sort Key: t.b, (sum(t1.c))
   ->  HashAggregate  (cost=338.71..340.71 rows=200 width=16)
         Output: t.b, sum(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- has agg, but no group by
explain verbose select t.b from (select max(b) as b, max(c) as cc from t1) s1, t where s1.b=t.b group by t.b order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Group  (cost=69.12..69.16 rows=9 width=4)
   Output: t.b
   Group By Key: t.b
   ->  Sort  (cost=69.12..69.14 rows=9 width=4)
         Output: t.b
         Sort Key: t.b
         ->  Hash Join  (cost=36.67..68.97 rows=9 distinct=[200, 1] width=4)
               Output: t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=36.66..36.66 rows=1 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..36.66 rows=1 width=4)
                           Output: s1.b
                           ->  Aggregate  (cost=36.64..36.65 rows=1 width=16)
                                 Output: max(t1.b), max(t1.c)
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.a, t1.b, t1.c, t1.d
(19 rows)

-- no agg function, but have group by
explain verbose select count(*) from (select b,c from t1 group by b,c) s1, t where s1.b=t.b group by s1.c order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=12)
   Output: (count(*)), s1.c
   Sort Key: (count(*))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=12)
         Output: count(*), s1.c
         Group By Key: s1.c
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=4)
               Output: s1.c
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                     Output: s1.c, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.c, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=8)
                                 Output: t1.b, t1.c
                                 Group By Key: t1.b, t1.c
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- expr out of agg function
explain verbose select t.b, sum(cc) from (select b, sum(c)*2 as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=114.34..114.84 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=104.70..106.70 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=43.64..95.82 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=41.14..41.14 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..41.14 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..39.14 rows=200 width=16)
                                 Output: t1.b, (sum(t1.c) * 2)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c)+sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.78..119.28 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=109.14..111.14 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=48.08..100.26 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=45.58..45.58 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=41.08..45.58 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=41.08..43.58 rows=200 width=24)
                                 Output: t1.b, (sum(t1.c) + sum(t1.c))
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc) from (select b, cast(sum(c) as int8) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c+d) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.20..427.70 rows=200 width=44)
   Output: t.b, (sum(((t1.c + t1.d))::bigint))
   Sort Key: t.b, (sum(((t1.c + t1.d))::bigint))
   ->  HashAggregate  (cost=417.56..419.56 rows=200 width=44)
         Output: t.b, sum(((t1.c + t1.d))::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- normal function in child-query's target list
explain verbose select aa from (select a, PG_CLIENT_ENCODING() aa from t group by 1) group by 1 order by 1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Group  (cost=0.00..32.20 rows=1 width=0)
   Output: ('UTF8'::name)
   Group By Key: 'UTF8'::name
   ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=0)
         Output: 'UTF8'::name
(5 rows)

------------------------------------------------------------------------------------
-- joint check
------------------------------------------------------------------------------------
-- agg func column in super query join/group by/where
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.cc>t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=5998.54..5999.04 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=5988.90..5990.90 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Nested Loop  (cost=36.64..5396.90 rows=118400 width=12)
               Output: s1.cc, t.b
               Join Filter: (s1.cc > t.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Materialize  (cost=36.64..41.64 rows=200 width=8)
                     Output: s1.cc
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.cc
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b and s1.cc>9000 group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.78..119.28 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=109.14..111.14 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=48.08..100.26 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=45.58..45.58 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=41.08..45.58 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=41.08..43.58 rows=200 width=24)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 Filter: (sum(t1.c) > 9000)
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(21 rows)

explain verbose select t.b, cc, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b, s1.cc order by 1,2,3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=222.25..226.69 rows=1776 width=44)
   Output: t.b, s1.cc, (sum(s1.cc))
   Sort Key: t.b, s1.cc, (sum(s1.cc))
   ->  HashAggregate  (cost=108.64..126.40 rows=1776 width=44)
         Output: t.b, s1.cc, sum(s1.cc)
         Group By Key: t.b, s1.cc
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- join type, normal
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1 left join t on s1.b=t.b group by t.b order by 1,2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select s1.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1 where s1.b not in (select t.b from t) group by s1.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=24390.50..24391.00 rows=200 width=40)
   Output: t1.b, (sum((t1.c)::bigint))
   Sort Key: t1.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=24380.86..24382.86 rows=200 width=40)
         Output: t1.b, sum((t1.c)::bigint)
         Group By Key: t1.b
         ->  Nested Loop Anti Join  (cost=0.00..24374.26 rows=879 width=8)
               Output: t1.b, t1.c
               Join Filter: ((t1.b = t.b) OR (t1.b IS NULL) OR (t.b IS NULL))
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Materialize  (cost=0.00..36.64 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- join type, delay rewrite
explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b) s1 left join t on s1.b=t.b group by t.b order by 1,2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from t right join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Full Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: t.b, s1.cc
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, count(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- join type, multiple join, with SUM(COUNT)
explain verbose select s1.b, sum(cc2) from (select b, sum(c) as cc1 from t1 group by b) s1 left join (select b, sum(c) as cc2 from t2 group by b) s2 on s1.b=s2.b left join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=40)
   Output: s1.b, (sum((t2.c)::bigint))
   Sort Key: s1.b, (sum((t2.c)::bigint))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=40)
         Output: s1.b, sum((t2.c)::bigint)
         Group By Key: s1.b
         ->  Hash Right Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: s1.b, t2.c
               Hash Cond: (t2.b = s1.b)
               ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t2.a, t2.b, t2.c, t2.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select s1.b, sum(cc2) from (select b, sum(c) as cc1 from t1 group by b) s1 left join (select b, count(c) as cc2 from t2 group by b) s2 on s1.b=s2.b left join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=97.17..97.67 rows=200 width=44)
   Output: t1.b, (sum(s2.cc2))
   Sort Key: t1.b, (sum(s2.cc2))
   ->  HashAggregate  (cost=87.53..89.53 rows=200 width=44)
         Output: t1.b, sum(s2.cc2)
         Group By Key: t1.b
         ->  Hash Left Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=12)
               Output: t1.b, s2.cc2
               Hash Cond: (t1.b = s2.b)
               ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                     Output: t1.b, sum(t1.c)
                     Group By Key: t1.b
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.b, t1.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s2.cc2, s2.b
                     ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=12)
                           Output: s2.cc2, s2.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t2.b, count(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
(23 rows)

explain verbose select s1.b, sum(cc3) from (select b, sum(c) as cc1 from t1 group by b) s1 left join ((select b, sum(c) as cc2 from t2 group by b) s2 right join (select b, count(c) as cc3 from t3 group by b) s3 on s2.b=s3.b) on s1.b=s2.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: s1.b, (sum(s3.cc3))
   Sort Key: s1.b, (sum(s3.cc3))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: s1.b, sum(s3.cc3)
         Group By Key: s1.b
         ->  Hash Right Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: s1.b, s3.cc3
               Hash Cond: (t2.b = s1.b)
               ->  Hash Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=12)
                     Output: t2.b, s3.cc3
                     Hash Cond: (t2.b = s3.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t2.b, sum(t2.c)
                           Group By Key: t2.b
                           ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t2.b, t2.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                           Output: s3.cc3, s3.b
                           ->  Subquery Scan on s3  (cost=36.64..40.64 rows=200 width=12)
                                 Output: s3.cc3, s3.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t3.b, count(t3.c)
                                       Group By Key: t3.b
                                       ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t3.b, t3.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(35 rows)

explain verbose select s1.b, sum(cc1) from ((select b, count(c) as cc1 from t1 group by b) s1 left join (select b, sum(c) as cc2 from t2 group by b) s2 on s1.b=s2.b) right join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: t1.b, (sum((count(t1.c))))
   Sort Key: t1.b, (sum((count(t1.c))))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: t1.b, sum((count(t1.c)))
         Group By Key: t1.b
         ->  Hash Right Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: t1.b, (count(t1.c))
               Hash Cond: (s2.b = s3.b)
               ->  Hash Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=16)
                     Output: t1.b, (count(t1.c)), s2.b
                     Hash Cond: (t1.b = s2.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t1.b, count(t1.c)
                           Group By Key: t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t1.b, t1.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                           Output: s2.b
                           ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=4)
                                 Output: s2.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t2.b, sum(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s3.b
                     ->  Subquery Scan on s3  (cost=36.64..40.64 rows=200 width=4)
                           Output: s3.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, sum(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
(35 rows)

explain verbose select s1.b, sum(cc3) from (select b, sum(c) as cc1 from t1 group by b) s1 right join (select b, sum(c) as cc2 from t2 group by b) s2 on s1.b=s2.b left join (select b, count(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: s1.b, (sum(s3.cc3))
   Sort Key: s1.b, (sum(s3.cc3))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: s1.b, sum(s3.cc3)
         Group By Key: s1.b
         ->  Hash Left Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: s1.b, s3.cc3
               Hash Cond: (t2.b = s3.b)
               ->  Hash Left Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=8)
                     Output: t2.b, s1.b
                     Hash Cond: (t2.b = s1.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t2.b, sum(t2.c)
                           Group By Key: t2.b
                           ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t2.b, t2.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                                 Output: s1.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t1.b, sum(t1.c)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t1.b, t1.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s3.cc3, s3.b
                     ->  Subquery Scan on s3  (cost=36.64..40.64 rows=200 width=12)
                           Output: s3.cc3, s3.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, count(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
(35 rows)

explain verbose select s1.b, sum(cc2) from (select b, sum(c) as cc1 from t1 group by b) s1 right join (select b, count(c) as cc2 from t2 group by b) s2 on s1.b=s2.b right join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: s1.b, (sum(s2.cc2))
   Sort Key: s1.b, (sum(s2.cc2))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: s1.b, sum(s2.cc2)
         Group By Key: s1.b
         ->  Hash Left Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: s2.cc2, s1.b
               Hash Cond: (s2.b = s1.b)
               ->  Hash Left Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=12)
                     Output: s2.cc2, s2.b
                     Hash Cond: (t3.b = s2.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t3.b, sum(t3.c)
                           Group By Key: t3.b
                           ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t3.b, t3.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                           Output: s2.cc2, s2.b
                           ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=12)
                                 Output: s2.cc2, s2.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t2.b, count(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(35 rows)

-- super agg func param come from non-agg func column of sub-query
explain verbose select t.b, sum(s1.d) from (select b, d, sum(c) as cc from t1 group by b, d) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=16)
   Output: t.b, (sum(s1.d))
   Sort Key: t.b, (sum(s1.d))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=16)
         Output: t.b, sum(s1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=47.58..99.76 rows=1776 distinct=[200, 200] width=8)
               Output: s1.d, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=45.08..45.08 rows=200 width=8)
                     Output: s1.d, s1.b
                     ->  Subquery Scan on s1  (cost=41.08..45.08 rows=200 width=8)
                           Output: s1.d, s1.b
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t1.b, t1.d, sum(t1.c)
                                 Group By Key: t1.b, t1.d
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t1.b, t1.d, t1.c
(20 rows)

------------------------------------------------------------------------------------
-- multi-agg functions
------------------------------------------------------------------------------------
-- single subquery, different order of super-agg and sub-agg
explain verbose select t.b, sum(cc), max(dd) from (select b, sum(c) as cc, max(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.20..427.70 rows=200 width=48)
   Output: t.b, (sum((t1.c)::bigint)), (max(t1.d))
   Sort Key: t.b, (sum((t1.c)::bigint)), (max(t1.d))
   ->  HashAggregate  (cost=417.56..419.56 rows=200 width=48)
         Output: t.b, sum((t1.c)::bigint), max(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(dd), sum(cc) from (select b, sum(c) as cc, count(*) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.70..428.20 rows=200 width=48)
   Output: t.b, ((count(1::bigint))::numeric), (sum((t1.c)::bigint))
   Sort Key: t.b, ((count(1::bigint))::numeric), (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=417.56..420.06 rows=200 width=48)
         Output: t.b, count(1::bigint), sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select max(dd), t.b, sum(cc) from (select b, sum(c) as cc, max(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.20..427.70 rows=200 width=48)
   Output: (max(t1.d)), t.b, (sum((t1.c)::bigint))
   Sort Key: (max(t1.d)), t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=417.56..419.56 rows=200 width=48)
         Output: max(t1.d), t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.d, t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, min(cc), sum(dd) from (select b, min(c) as cc, count(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.28..388.78 rows=200 width=24)
   Output: t.b, (min(t1.c)), ((count(t1.d))::numeric)
   Sort Key: t.b, (min(t1.c)), ((count(t1.d))::numeric)
   ->  HashAggregate  (cost=378.13..380.63 rows=200 width=24)
         Output: t.b, min(t1.c), count(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, count(c) as cc, count(*) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.78..389.28 rows=200 width=24)
   Output: t.b, ((count(t1.c))::numeric), ((count(1::bigint))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric), ((count(1::bigint))::numeric)
   ->  HashAggregate  (cost=378.13..381.13 rows=200 width=24)
         Output: t.b, count(t1.c), count(1::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- simple setop
explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, sum(d) as dd from t1 group by b union all select b, sum(c) as cc, sum(d) as dd from t2 group by b union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort  (cost=1044.12..1044.62 rows=200 width=84)
   Output: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   ->  HashAggregate  (cost=1034.48..1036.48 rows=200 width=84)
         Output: t.b, sum(((t1.c)::bigint)), sum(((t1.d)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=20)
               Output: ((t1.c)::bigint), ((t1.d)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=20)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t1.c, t1.d, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t2.c, t2.d, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t3.c, t3.d, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

explain verbose select t.b, sum(cc), max(dd) from (select b, count(c) as cc, max(d) as dd from t1 group by b union all select b, count(c) as cc, max(d) as dd from t2 group by b union all select b, count(c) as cc, max(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort  (cost=1044.62..1045.12 rows=200 width=24)
   Output: t.b, ((count(t1.c))::numeric), (max(t1.d))
   Sort Key: t.b, ((count(t1.c))::numeric), (max(t1.d))
   ->  HashAggregate  (cost=1034.48..1036.98 rows=200 width=24)
         Output: t.b, count(t1.c), max(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.d, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.d, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t3.c, t3.d, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

-- complex setop, one is valid and another is invalid
explain verbose select t.b, sum(cc), min(dd) from (select b, sum(c) as cc, min(d) as dd from t1 group by b union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort  (cost=508.65..509.15 rows=200 width=60)
   Output: t.b, (sum("*SELECT* 1".cc)), (min((("*SELECT* 1".dd)::bigint)))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (min((("*SELECT* 1".dd)::bigint)))
   ->  HashAggregate  (cost=499.00..501.00 rows=200 width=60)
         Output: t.b, sum("*SELECT* 1".cc), min((("*SELECT* 1".dd)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..367.40 rows=17547 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, (("*SELECT* 1".dd)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=0.00..95.04 rows=1976 width=14)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..49.96 rows=1776 width=12)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc, "*SELECT* 1".dd
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=1776 width=12)
                                 Output: t1.b, t1.c, t1.d
                     ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                           Output: t3.b, sum(t3.c), sum(t3.d)
                           Group By Key: t3.b
                           ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                                 Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, sum(d) as dd from t1 group by b union all select b, sum(c) as cc, count(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=466.69..467.19 rows=200 width=84)
   Output: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   ->  HashAggregate  (cost=457.04..459.04 rows=200 width=84)
         Output: t.b, sum(((t1.c)::bigint)), sum(((t1.d)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..325.44 rows=17547 distinct=[200, 200] width=20)
               Output: ((t1.c)::bigint), ((t1.d)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..72.84 rows=1976 width=20)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t1.c, t1.d, t1.b
                     ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 2".cc, "*SELECT* 2".dd, "*SELECT* 2".b
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                 Output: t3.b, sum(t3.c), count(t3.d)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, count(c) as cc, sum(d) as dd from t1 group by b union all select b, count(c) as cc, count(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=203.60..204.10 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   ->  HashAggregate  (cost=193.96..195.96 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum("*SELECT* 1".dd)
         Group By Key: t.b
         ->  Hash Join  (cost=95.16..167.32 rows=3552 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, "*SELECT* 1".dd, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=90.16..90.16 rows=400 width=20)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                     ->  Append  (cost=41.08..90.16 rows=400 width=20)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                       Output: t1.b, count(t1.c), sum(t1.d)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                             Output: t1.b, t1.c, t1.d
                           ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".dd, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                       Output: t3.b, count(t3.c), count(t3.d)
                                       Group By Key: t3.b
                                       ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                                             Output: t3.b, t3.c, t3.d
(28 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, count(c) as cc, count(d) as dd from t1 group by b union all select b, count(c) as cc, count(*) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=203.60..204.10 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   ->  HashAggregate  (cost=193.96..195.96 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum("*SELECT* 1".dd)
         Group By Key: t.b
         ->  Hash Join  (cost=95.16..167.32 rows=3552 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, "*SELECT* 1".dd, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=90.16..90.16 rows=400 width=20)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                     ->  Append  (cost=41.08..90.16 rows=400 width=20)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                       Output: t1.b, count(t1.c), count(t1.d)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                             Output: t1.b, t1.c, t1.d
                           ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".dd, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=24)
                                       Output: t3.b, count(t3.c), count(*)
                                       Group By Key: t3.b
                                       ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t3.b, t3.c
(28 rows)

-- complex setop: agg func number not match in setop branch
explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, d as dd from t1 group by b,d union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=513.09..513.59 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   ->  HashAggregate  (cost=503.44..505.44 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum((("*SELECT* 1".dd)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=91.04..371.84 rows=17547 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, (("*SELECT* 1".dd)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=41.08..99.48 rows=1976 width=13)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc, "*SELECT* 1".dd
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t1.b, sum(t1.c), t1.d
                                 Group By Key: t1.b, t1.d
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t1.b, t1.d, t1.c
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..36.64 rows=1776 width=12)
                           Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, d as dd from t1 group by b,d union all select b, c as cc, sum(d) as dd from t2 group by b,c union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=594.00..594.50 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   ->  HashAggregate  (cost=584.35..586.35 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum((("*SELECT* 1".dd)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=91.04..439.43 rows=19323 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, (("*SELECT* 1".dd)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=41.08..144.56 rows=2176 width=13)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc, "*SELECT* 1".dd
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t1.b, sum(t1.c), t1.d
                                 Group By Key: t1.b, t1.d
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t1.b, t1.d, t1.c
                     ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 2".b, "*SELECT* 2".cc, "*SELECT* 2".dd
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t2.b, t2.c, sum(t2.d)
                                 Group By Key: t2.b, t2.c
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t2.b, t2.c, t2.d
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..36.64 rows=1776 width=12)
                           Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(30 rows)

-- 1--n
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc, min(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc, avg(d)+1 as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc, sum(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc, avg(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- n--1
explain verbose select t.b, sum(cc), sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=466.63..467.13 rows=200 width=72)
   Output: t.b, (sum((t1.c)::bigint)), (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=456.99..458.99 rows=200 width=72)
         Output: t.b, sum((t1.c)::bigint), sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc), sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.78..389.28 rows=200 width=24)
   Output: t.b, ((count(t1.c))::numeric), ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=378.13..381.13 rows=200 width=24)
         Output: t.b, count(t1.c), count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc), sum(cc), sum(cc), sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3,4,5;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=468.63..469.13 rows=200 width=40)
   Output: t.b, ((count(t1.c))::numeric), ((count(t1.c))::numeric), ((count(t1.c))::numeric), ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=456.99..460.99 rows=200 width=40)
         Output: t.b, count(t1.c), count(t1.c), count(t1.c), count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- n--1, expr
explain verbose select t.b, sum(cc) + sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=467.13..467.63 rows=200 width=72)
   Output: t.b, ((sum((t1.c)::bigint) + sum((t1.c)::bigint)))
   Sort Key: t.b, ((sum((t1.c)::bigint) + sum((t1.c)::bigint)))
   ->  HashAggregate  (cost=456.99..459.49 rows=200 width=72)
         Output: t.b, (sum((t1.c)::bigint) + sum((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) + sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=389.28..389.78 rows=200 width=24)
   Output: t.b, (((count(t1.c))::numeric + (count(t1.c))::numeric))
   Sort Key: t.b, (((count(t1.c))::numeric + (count(t1.c))::numeric))
   ->  HashAggregate  (cost=378.13..381.63 rows=200 width=24)
         Output: t.b, ((count(t1.c))::numeric + (count(t1.c))::numeric)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

------------------------------------------------------------------------------------
-- CTE
------------------------------------------------------------------------------------
-- basic with as
explain verbose with s as (select b, sum(c) as cc from t1 group by b) select t.b, sum(cc) from s, t where s.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- multi-usage
explain verbose with s1(b, cc) as (select b, sum(c) from t1 group by b) select count(*) from s1 where cc > (select sum(cc)/100 from s1) order by 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=48.34..48.35 rows=1 width=8)
   Output: (count(*))
   Sort Key: (count(*))
   CTE s1
     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                 Output: t1.b, t1.c
   InitPlan 2 (returns $1)
     ->  Aggregate  (cost=4.50..4.51 rows=1 width=40)
           Output: (sum(s1.cc) / 100::numeric)
           ->  CTE Scan on s1  (cost=0.00..4.00 rows=200 width=8)
                 Output: s1.b, s1.cc
   ->  Aggregate  (cost=5.17..5.18 rows=1 width=8)
         Output: count(*)
         ->  CTE Scan on s1  (cost=0.00..5.00 rows=67 width=0)
               Output: s1.b, s1.cc
               Filter: ((s1.cc)::numeric > $1)
(19 rows)

-- pull up
explain verbose with s as (select b, sum(c) as cc from t1 group by b) select a, b, c, d from t where b not in (select sum(cc) from s group by b) order by 1,2,3,4;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=4673.57..4675.77 rows=879 width=16)
   Output: t.a, t.b, t.c, t.d
   Sort Key: t.a, t.b, t.c, t.d
   CTE s
     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                 Output: t1.b, t1.c
   ->  Nested Loop Anti Join  (cost=5.00..4591.95 rows=879 width=16)
         Output: t.a, t.b, t.c, t.d
         Join Filter: (((t.b)::numeric = "ANY_subquery".sum) OR ((t.b)::numeric IS NULL) OR ("ANY_subquery".sum IS NULL))
         ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=16)
               Output: t.a, t.b, t.c, t.d
         ->  Materialize  (cost=5.00..10.00 rows=200 width=32)
               Output: "ANY_subquery".sum
               ->  Subquery Scan on "ANY_subquery"  (cost=5.00..9.00 rows=200 width=32)
                     Output: "ANY_subquery".sum
                     ->  HashAggregate  (cost=5.00..7.00 rows=200 width=44)
                           Output: sum(s.cc), s.b
                           Group By Key: s.b
                           ->  CTE Scan on s  (cost=0.00..4.00 rows=200 width=12)
                                 Output: s.b, s.cc
(23 rows)

-- not pull up
explain verbose with s as (select b, sum(c) as cc from t1 group by b) select 1 from t where exists (select b, sum(cc) from s where s.b=t.b group by b);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Seq Scan on lazyagg.t  (cost=38.64..8085.04 rows=888 width=0)
   Output: 1
   Filter: (SubPlan 2)
   CTE s
     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                 Output: t1.b, t1.c
   SubPlan 2
     ->  GroupAggregate  (cost=0.00..4.52 rows=1 width=44)
           Output: s.b, sum(s.cc)
           Group By Key: s.b
           ->  CTE Scan on s  (cost=0.00..4.50 rows=1 width=12)
                 Output: s.b, s.cc
                 Filter: (s.b = t.b)
(16 rows)

-- multi-cte
explain verbose 
with s as
(select a,b from t1 group by a,b)
select max(b) from
(
	select b from
	(
		select max(b) b from
		(
			with s as
			(select a+b a, a-b b from t2 group by 1,2)
			select max(b) b from
			(select a*b b from t where a in (select b from s group by b))
		)
	)
) order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=106.33..106.33 rows=1 width=8)
   Output: (max((max((max((t.a * t.b)))))))
   Sort Key: (max((max((max((t.a * t.b)))))))
   ->  Aggregate  (cost=106.31..106.32 rows=1 width=8)
         Output: max((max((max((t.a * t.b))))))
         ->  Aggregate  (cost=106.28..106.29 rows=1 width=8)
               Output: max((max((t.a * t.b))))
               ->  Aggregate  (cost=106.26..106.27 rows=1 width=12)
                     Output: max((t.a * t.b))
                     CTE s
                       ->  HashAggregate  (cost=45.52..48.52 rows=200 width=8)
                             Output: ((t2.a + t2.b)), ((t2.a - t2.b))
                             Group By Key: (t2.a + t2.b), (t2.a - t2.b)
                             ->  Seq Scan on lazyagg.t2  (cost=0.00..36.64 rows=1776 width=8)
                                   Output: (t2.a + t2.b), (t2.a - t2.b)
                     ->  Hash Semi Join  (cost=11.00..53.30 rows=888 distinct=[200, 200] width=8)
                           Output: t.a, t.b
                           Hash Cond: (t.a = s.b)
                           ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t.a, t.b, t.c, t.d
                           ->  Hash  (cost=8.50..8.50 rows=200 width=4)
                                 Output: s.b
                                 ->  HashAggregate  (cost=4.50..6.50 rows=200 width=4)
                                       Output: s.b
                                       Group By Key: s.b
                                       ->  CTE Scan on s  (cost=0.00..4.00 rows=200 width=4)
                                             Output: s.b
(27 rows)

------------------------------------------------------------------------------------
-- In, Exists
------------------------------------------------------------------------------------
explain verbose select t.b from t where exists (select b, sum(c) as cc from t1 where b > 100 group by b) group by t.b order by 1;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Sort  (cost=77.01..77.51 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   InitPlan 1 (returns $0)
     ->  HashAggregate  (cost=35.16..35.83 rows=67 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=592 width=8)
                 Output: t1.b, t1.c
                 Filter: (t1.b > 100)
   ->  HashAggregate  (cost=32.20..34.20 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Result  (cost=0.00..27.76 rows=1776 width=4)
               Output: t.b
               One-Time Filter: $0
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
(18 rows)

explain verbose select b from t where b in (select b from t1 group by b) group by b order by 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=98.53..99.03 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=88.88..90.88 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=36.70..86.66 rows=888 distinct=[1, 1] width=4)
               Output: t.b
               Hash Cond: (t.b = t1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=34.20..34.20 rows=200 width=4)
                     Output: t1.b
                     ->  HashAggregate  (cost=32.20..34.20 rows=200 width=4)
                           Output: t1.b
                           Group By Key: t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: t1.b
(18 rows)

explain verbose 
select a,b,c,d from t2 where exists
(select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2) order by 1,2,3,4;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=511.39..515.83 rows=1776 width=16)
   Output: t2.a, t2.b, t2.c, t2.d
   Sort Key: t2.a, t2.b, t2.c, t2.d
   InitPlan 1 (returns $0)
     ->  Sort  (cost=387.78..388.28 rows=200 width=40)
           Output: t.b, (sum((t1.c)::bigint))
           Sort Key: t.b, (sum((t1.c)::bigint))
           ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
                 Output: t.b, sum((t1.c)::bigint)
                 Group By Key: t.b
                 ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
                       Output: t1.c, t.b
                       Hash Cond: (t1.b = t.b)
                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                             Output: t1.a, t1.b, t1.c, t1.d
                       ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                             Output: t.b
                             ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                                   Output: t.b
   ->  Result  (cost=0.00..27.76 rows=1776 width=16)
         Output: t2.a, t2.b, t2.c, t2.d
         One-Time Filter: $0
         ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=16)
               Output: t2.a, t2.b, t2.c, t2.d
(24 rows)

------------------------------------------------------------------------------------
-- multi-layer lazy agg
------------------------------------------------------------------------------------
-- a chain
explain verbose select * from (select s1.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1 group by s1.b) order by 1,2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort  (cost=52.72..53.22 rows=200 width=36)
   Output: t1.b, (sum((t1.c)::bigint))
   Sort Key: t1.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=41.08..43.08 rows=200 width=40)
         Output: t1.b, sum((t1.c)::bigint)
         Group By Key: t1.b
         ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
               Output: t1.b, t1.c
(8 rows)

select * from (select s1.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1 group by s1.b) order by 1,2;
 b | sum 
---+-----
 1 |   6
 2 |   6
 3 |   3
 5 |   5
 6 |   6
 7 |    
   |  13
(7 rows)

explain verbose 
select b, sum(ccc) as cccc from(
select b, sum(cc) as ccc from (
select b, sum(c) as cc from t1 group by b
) s1 group by b
) s2 group by b order by 1,2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort  (cost=55.16..55.66 rows=200 width=40)
   Output: t1.b, (sum((t1.c)::numeric))
   Sort Key: t1.b, (sum((t1.c)::numeric))
   ->  HashAggregate  (cost=45.52..47.52 rows=200 width=40)
         Output: t1.b, sum((t1.c)::numeric)
         Group By Key: t1.b
         ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
               Output: t1.b, t1.c
(8 rows)

-- with setop
explain verbose 
select b, sum(ccc) as cccc from(
select b, sum(cc) as ccc from (
select b, sum(c) as cc from t1 group by b
) s11 group by b
union all
select b, count(cc) as ccc from (
select b, sum(c) as cc from t2 group by b
) s12 group by b
) s2 group by b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=139.32..139.82 rows=200 width=68)
   Output: t1.b, (sum(((t1.c)::numeric)))
   Sort Key: t1.b, (sum(((t1.c)::numeric)))
   ->  HashAggregate  (cost=129.68..131.68 rows=200 width=68)
         Output: t1.b, sum(((t1.c)::numeric))
         Group By Key: t1.b
         ->  Append  (cost=0.00..100.04 rows=1976 width=9)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..36.64 rows=1776 width=8)
                     Output: t1.b, t1.c
               ->  Subquery Scan on "*SELECT* 2"  (cost=41.64..45.64 rows=200 width=20)
                     Output: "*SELECT* 2".b, "*SELECT* 2".ccc
                     ->  HashAggregate  (cost=41.64..43.64 rows=200 width=20)
                           Output: t2.b, count((sum(t2.c)))
                           Group By Key: t2.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t2.b, sum(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
(19 rows)

explain verbose 
select b, sum(ccc) as cccc from(
select b, sum(cc) as ccc from (
select b, count(c) as cc from t1 group by b
) s11 group by b
union all
select b, count(cc) as ccc from (
select b, sum(c) as cc from t2 group by b
) s12 group by b
) s2 group by b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=88.42..88.92 rows=200 width=20)
   Output: t1.b, ((count(((t1.c)::bigint)))::numeric)
   Sort Key: t1.b, ((count(((t1.c)::bigint)))::numeric)
   ->  HashAggregate  (cost=78.28..80.78 rows=200 width=20)
         Output: t1.b, count(((t1.c)::bigint))
         Group By Key: t1.b
         ->  Append  (cost=0.00..68.40 rows=1976 width=12)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.b, t1.c
               ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                     Output: t2.b, sum(t2.c)
                     Group By Key: t2.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.b, t2.c
(14 rows)

explain verbose 
(select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2)
union all
(select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2) order by 1,2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=781.55..782.55 rows=400 width=36)
   Output: lazyagg.t.b, (sum((lazyagg.t1.c)::bigint))
   Sort Key: lazyagg.t.b, (sum((lazyagg.t1.c)::bigint))
   ->  Result  (cost=378.13..764.27 rows=400 width=36)
         Output: lazyagg.t.b, (sum((lazyagg.t1.c)::bigint))
         ->  Append  (cost=378.13..764.27 rows=400 width=36)
               ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
                     Output: lazyagg.t.b, sum((lazyagg.t1.c)::bigint)
                     Group By Key: lazyagg.t.b
                     ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
                           Output: lazyagg.t1.c, lazyagg.t.b
                           Hash Cond: (lazyagg.t1.b = lazyagg.t.b)
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: lazyagg.t1.a, lazyagg.t1.b, lazyagg.t1.c, lazyagg.t1.d
                           ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                                 Output: lazyagg.t.b
                                 ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: lazyagg.t.b
               ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
                     Output: lazyagg.t.b, sum((lazyagg.t1.c)::bigint)
                     Group By Key: lazyagg.t.b
                     ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
                           Output: lazyagg.t1.c, lazyagg.t.b
                           Hash Cond: (lazyagg.t1.b = lazyagg.t.b)
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: lazyagg.t1.a, lazyagg.t1.b, lazyagg.t1.c, lazyagg.t1.d
                           ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                                 Output: lazyagg.t.b
                                 ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: lazyagg.t.b
(30 rows)

------------------------------------------------------------------------------------
-- empty table
------------------------------------------------------------------------------------
create table t_empty (a int, b int, c int, d int);
explain verbose select t_empty.b, sum(cc) from (select b, count(c) as cc from t_empty group by b) s, t_empty where s.b=t_empty.b group by t_empty.b;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 HashAggregate  (cost=338.71..341.21 rows=200 width=16)
   Output: lazyagg.t_empty.b, count(lazyagg.t_empty.c)
   Group By Key: lazyagg.t_empty.b
   ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
         Output: lazyagg.t_empty.c, lazyagg.t_empty.b
         Hash Cond: (lazyagg.t_empty.b = lazyagg.t_empty.b)
         ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=8)
               Output: lazyagg.t_empty.a, lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
         ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.b
               ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
                     Output: lazyagg.t_empty.b
(12 rows)

explain verbose select sum(cc) from (select b, count(c) as cc from t_empty group by b) s, t_empty where s.b=t_empty.b;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Aggregate  (cost=99.76..99.77 rows=1 width=40)
   Output: sum(s.cc)
   ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
         Output: s.cc
         Hash Cond: (lazyagg.t_empty.b = s.b)
         ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.a, lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
         ->  Hash  (cost=40.64..40.64 rows=200 width=12)
               Output: s.cc, s.b
               ->  Subquery Scan on s  (cost=36.64..40.64 rows=200 width=12)
                     Output: s.cc, s.b
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: lazyagg.t_empty.b, count(lazyagg.t_empty.c)
                           Group By Key: lazyagg.t_empty.b
                           ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: lazyagg.t_empty.b, lazyagg.t_empty.c
(16 rows)

explain verbose select t_empty.b, sum(cc) from (select b, count(*) as cc from t_empty group by b) s, t_empty where s.b=t_empty.b group by t_empty.b;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 HashAggregate  (cost=338.71..341.21 rows=200 width=12)
   Output: lazyagg.t_empty.b, count(1::bigint)
   Group By Key: lazyagg.t_empty.b
   ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
         Output: lazyagg.t_empty.b
         Hash Cond: (lazyagg.t_empty.b = lazyagg.t_empty.b)
         ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.a, lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
         ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.b
               ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
                     Output: lazyagg.t_empty.b
(12 rows)

explain verbose select sum(cc) from (select b, count(*) as cc from t_empty group by b) s, t_empty where s.b=t_empty.b;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Aggregate  (cost=99.76..99.77 rows=1 width=40)
   Output: sum(s.cc)
   ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
         Output: s.cc
         Hash Cond: (lazyagg.t_empty.b = s.b)
         ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.a, lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
         ->  Hash  (cost=40.64..40.64 rows=200 width=12)
               Output: s.cc, s.b
               ->  Subquery Scan on s  (cost=36.64..40.64 rows=200 width=12)
                     Output: s.cc, s.b
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                           Output: lazyagg.t_empty.b, count(*)
                           Group By Key: lazyagg.t_empty.b
                           ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: lazyagg.t_empty.b
(16 rows)

explain verbose select t_empty.b, sum(cc), sum(dd) from (select b, count(c) as cc, sum(d) as dd from t_empty group by b) s, t_empty where s.b=t_empty.b group by t_empty.b;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 HashAggregate  (cost=417.56..420.06 rows=200 width=52)
   Output: lazyagg.t_empty.b, count(lazyagg.t_empty.c), sum((lazyagg.t_empty.d)::bigint)
   Group By Key: lazyagg.t_empty.b
   ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
         Output: lazyagg.t_empty.c, lazyagg.t_empty.d, lazyagg.t_empty.b
         Hash Cond: (lazyagg.t_empty.b = lazyagg.t_empty.b)
         ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=12)
               Output: lazyagg.t_empty.a, lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
         ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.b
               ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
                     Output: lazyagg.t_empty.b
(12 rows)

explain verbose select sum(cc), sum(dd) from (select b, count(c) as cc, sum(d) as dd from t_empty group by b) s, t_empty where s.b=t_empty.b;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate  (cost=108.64..108.65 rows=1 width=80)
   Output: sum(s.cc), sum(s.dd)
   ->  Hash Join  (cost=47.58..99.76 rows=1776 distinct=[200, 200] width=16)
         Output: s.cc, s.dd
         Hash Cond: (lazyagg.t_empty.b = s.b)
         ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=4)
               Output: lazyagg.t_empty.a, lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
         ->  Hash  (cost=45.08..45.08 rows=200 width=20)
               Output: s.cc, s.dd, s.b
               ->  Subquery Scan on s  (cost=41.08..45.08 rows=200 width=20)
                     Output: s.cc, s.dd, s.b
                     ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                           Output: lazyagg.t_empty.b, count(lazyagg.t_empty.c), sum(lazyagg.t_empty.d)
                           Group By Key: lazyagg.t_empty.b
                           ->  Seq Scan on lazyagg.t_empty  (cost=0.00..27.76 rows=1776 width=12)
                                 Output: lazyagg.t_empty.b, lazyagg.t_empty.c, lazyagg.t_empty.d
(16 rows)

------------------------------------------------------------------------------------
-- data type convert
------------------------------------------------------------------------------------
create table t_type (a int2, b int8, c varchar(10), d char(5), e text, f date, g timestamp, h interval);
insert into t_type values (1, 2, 'CCC', 'DDD', 'EEE', date '5-4-2017', '4-17-2017', interval '3' day);
explain verbose select t_type.c, sum(dd) from (select c, count(d) as dd from t_type group by c) s, t_type where s.c=t_type.c group by t_type.c;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=56.60..59.10 rows=200 width=70)
   Output: lazyagg.t_type.c, count(lazyagg.t_type.d)
   Group By Key: lazyagg.t_type.c
   ->  Hash Join  (cost=21.07..50.55 rows=1210 distinct=[200, 200] width=62)
         Output: lazyagg.t_type.d, lazyagg.t_type.c
         Hash Cond: ((lazyagg.t_type.c)::text = (lazyagg.t_type.c)::text)
         ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=62)
               Output: lazyagg.t_type.a, lazyagg.t_type.b, lazyagg.t_type.c, lazyagg.t_type.d, lazyagg.t_type.e, lazyagg.t_type.f, lazyagg.t_type.g, lazyagg.t_type.h
         ->  Hash  (cost=14.92..14.92 rows=492 width=38)
               Output: lazyagg.t_type.c
               ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=38)
                     Output: lazyagg.t_type.c
(12 rows)

explain verbose select t_type.c, sum(dd) from (select c, count(d) as dd from t_type group by c union all select c, count(d) as dd from t_type group by c) s, t_type where s.c=t_type.c group by t_type.c order by 1,2;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Sort  (cost=102.29..102.79 rows=200 width=70)
   Output: lazyagg.t_type.c, ((count(lazyagg.t_type.d))::numeric)
   Sort Key: lazyagg.t_type.c, ((count(lazyagg.t_type.d))::numeric)
   ->  HashAggregate  (cost=92.14..94.64 rows=200 width=70)
         Output: lazyagg.t_type.c, count(lazyagg.t_type.d)
         Group By Key: lazyagg.t_type.c
         ->  Hash Join  (cost=21.07..80.04 rows=2421 distinct=[200, 200] width=62)
               Output: lazyagg.t_type.d, lazyagg.t_type.c
               Hash Cond: ((lazyagg.t_type.c)::text = (lazyagg.t_type.c)::text)
               ->  Append  (cost=0.00..29.84 rows=984 width=62)
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=62)
                           Output: lazyagg.t_type.d, lazyagg.t_type.c
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=62)
                           Output: lazyagg.t_type.d, lazyagg.t_type.c
               ->  Hash  (cost=14.92..14.92 rows=492 width=38)
                     Output: lazyagg.t_type.c
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=38)
                           Output: lazyagg.t_type.c
(18 rows)

explain verbose select sum(a1), sum(a2), sum(a3) from (select a, sum(b) a1, count(c) a2, count(f) a3 from t_type group by a union all select a, sum(a), count(e), count(g) from t_type group by a) s, t_type where s.a=t_type.a group by t_type.a;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=126.39..129.39 rows=200 width=122)
   Output: sum("*SELECT* 1".a1), count((("*SELECT* 1".a2)::character varying(10))), count("*SELECT* 1".a3), lazyagg.t_type.a
   Group By Key: lazyagg.t_type.a
   ->  Hash Join  (cost=21.07..102.18 rows=2421 distinct=[200, 200] width=74)
         Output: "*SELECT* 1".a1, (("*SELECT* 1".a2)::character varying(10)), "*SELECT* 1".a3, lazyagg.t_type.a
         Hash Cond: ("*SELECT* 1".a = lazyagg.t_type.a)
         ->  Append  (cost=0.00..42.14 rows=984 width=49)
               ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..21.07 rows=492 width=56)
                     Output: "*SELECT* 1".a, "*SELECT* 1".a1, ("*SELECT* 1".a2)::character varying(10), "*SELECT* 1".a3
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..16.15 rows=492 width=56)
                           Output: lazyagg.t_type.a, lazyagg.t_type.b, lazyagg.t_type.c, lazyagg.t_type.f
               ->  Subquery Scan on "*SELECT* 2"  (cost=0.00..21.07 rows=492 width=42)
                     Output: "*SELECT* 2".a, "*SELECT* 2".sum, "*SELECT* 2".count, "*SELECT* 2".count
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..16.15 rows=492 width=42)
                           Output: lazyagg.t_type.a, lazyagg.t_type.a, lazyagg.t_type.e, lazyagg.t_type.g
         ->  Hash  (cost=14.92..14.92 rows=492 width=2)
               Output: lazyagg.t_type.a
               ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=2)
                     Output: lazyagg.t_type.a
(19 rows)

explain verbose select sum(a1), sum(a2), sum(a3) from (select a, sum(b) a1, count(c) a2, count(*) a3 from t_type group by a union all select a, sum(a), count(e), count(*) from t_type group by a) s, t_type where s.a=t_type.a group by t_type.a;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=126.39..129.39 rows=200 width=122)
   Output: sum("*SELECT* 1".a1), count((("*SELECT* 1".a2)::character varying(10))), count((1::bigint)), lazyagg.t_type.a
   Group By Key: lazyagg.t_type.a
   ->  Hash Join  (cost=21.07..102.18 rows=2421 distinct=[200, 200] width=74)
         Output: "*SELECT* 1".a1, (("*SELECT* 1".a2)::character varying(10)), (1::bigint), lazyagg.t_type.a
         Hash Cond: ("*SELECT* 1".a = lazyagg.t_type.a)
         ->  Append  (cost=0.00..42.14 rows=984 width=41)
               ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..21.07 rows=492 width=48)
                     Output: "*SELECT* 1".a, "*SELECT* 1".a1, ("*SELECT* 1".a2)::character varying(10), 1::bigint
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..16.15 rows=492 width=48)
                           Output: lazyagg.t_type.a, lazyagg.t_type.b, lazyagg.t_type.c, 1::bigint
               ->  Subquery Scan on "*SELECT* 2"  (cost=0.00..21.07 rows=492 width=34)
                     Output: "*SELECT* 2".a, "*SELECT* 2".sum, "*SELECT* 2".count, 1::bigint
                     ->  Seq Scan on lazyagg.t_type  (cost=0.00..16.15 rows=492 width=34)
                           Output: lazyagg.t_type.a, lazyagg.t_type.a, lazyagg.t_type.e, 1::bigint
         ->  Hash  (cost=14.92..14.92 rows=492 width=2)
               Output: lazyagg.t_type.a
               ->  Seq Scan on lazyagg.t_type  (cost=0.00..14.92 rows=492 width=2)
                     Output: lazyagg.t_type.a
(19 rows)

create view v as select * from t;
explain verbose  
select t1.a, sum(cc)
from t1 full join v using(a) full join (select a, sum(c) as cc from t2 group by a) using(a)
where t1.a>5
group by t1.a
order by 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Sort  (cost=1072.91..1073.08 rows=67 width=40)
   Output: t1.a, (sum((t2.c)::bigint))
   Sort Key: t1.a
   ->  HashAggregate  (cost=1070.21..1070.88 rows=67 width=40)
         Output: t1.a, sum((t2.c)::bigint)
         Group By Key: t1.a
         ->  Hash Left Join  (cost=89.56..720.09 rows=46682 distinct=[200, 200] width=8)
               Output: t1.a, t2.c
               Hash Cond: (COALESCE(t1.a, t.a) = t2.a)
               ->  Hash Right Join  (cost=39.60..131.03 rows=5257 distinct=[200, 200] width=8)
                     Output: t1.a, t.a
                     Hash Cond: (t.a = t1.a)
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.a, t.b, t.c, t.d
                     ->  Hash  (cost=32.20..32.20 rows=592 width=4)
                           Output: t1.a
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=592 width=4)
                                 Output: t1.a
                                 Filter: (t1.a > 5)
               ->  Hash  (cost=27.76..27.76 rows=1776 width=8)
                     Output: t2.c, t2.a
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.a
(23 rows)

create view v1 as select a from t1 group by a;
explain verbose 
select t2.b
from t2 full join v1 using(a) full join t3 using(a)
group by t2.b order by 1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=2286.88..2287.38 rows=200 width=4)
   Output: t2.b
   Sort Key: t2.b
   ->  HashAggregate  (cost=2277.24..2279.24 rows=200 width=4)
         Output: t2.b
         Group By Key: t2.b
         ->  Hash Full Join  (cost=99.92..1927.12 rows=140046 distinct=[200, 200] width=4)
               Output: t2.b
               Hash Cond: (COALESCE(t2.a, t1.a) = t3.a)
               ->  Hash Full Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
                     Output: t2.b, t2.a, t1.a
                     Hash Cond: (t2.a = t1.a)
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.a, t2.b, t2.c, t2.d
                     ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                           Output: t1.a
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: t1.a
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t3.a
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t3.a
(22 rows)

------------------------------------------------------------------------------------
-- Unused column
------------------------------------------------------------------------------------
explain verbose 
select t.b from (select b, max(c) as cc from t1 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(c) as cc from t1 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(c) as cc, count(d) as dd from t1 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(c) as cc from t1 group by b) s1 left join t on s1.b=t.b group by t.b order by 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(*) as cc from t1 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(*) as cc from t1 group by b) s1 left join t on s1.b=t.b group by t.b order by 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, avg(c) as cc from t1 group by b) s1 full join t on s1.b=t.b group by t.b order by 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Full Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(c) as cc from t1 group by b) s1 inner join t on s1.b=t.b inner join (select b, count(d) as dd from t2 group by b) s2 on s2.b=t.b group by t.b order by 1;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Sort  (cost=2286.88..2287.38 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=2277.24..2279.24 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=99.92..1927.12 rows=140046 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t2.b)
               ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
                     Output: t1.b, t.b
                     Hash Cond: (t1.b = t.b)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t1.a, t1.b, t1.c, t1.d
                     ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                           Output: t.b
                           ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: t.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t2.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t2.b
(22 rows)

explain verbose 
select t.b, sum(dd) from (select b, count(c) as cc, count(d) as dd from t1 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.d))::numeric)
   Sort Key: t.b, ((count(t1.d))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose 
select t.b from (select b, count(c) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=558.24..558.74 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=548.60..550.60 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..469.74 rows=31542 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..55.52 rows=3552 width=4)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t2.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(18 rows)

explain verbose 
select t.b from (select b, c as cc from t1 group by b,c union all select b, count(c) as cc from t2 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=629.28..629.78 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=619.64..621.64 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..540.78 rows=31542 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=0.00..91.04 rows=3552 width=4)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..45.52 rows=1776 width=4)
                           Output: "*SELECT* 1".b, NULL::integer
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: t1.b, NULL::integer
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t2.b, NULL::bigint
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

explain verbose 
select t.b from (select b, avg(c) as cc from t1 group by b union all select b, avg(c) as cc from t2 group by b) s1 inner join t on s1.b=t.b group by t.b order by 1;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=558.24..558.74 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=548.60..550.60 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..469.74 rows=31542 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..55.52 rows=3552 width=4)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t2.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(18 rows)

set enable_seqscan_fusion = on;
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |  24
 2 |  24
 3 |   3
 5 |   5
 6 |  12
 7 |    
(6 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |  16
 2 |  16
 3 |   1
 5 |   1
 6 |   2
 7 |   0
(6 rows)

explain verbose select t.b, sum(cc) from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=12)
   Output: t.b, ((count(1::bigint))::numeric)
   Sort Key: t.b, ((count(1::bigint))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=12)
         Output: t.b, count(1::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

select t.b, sum(cc) from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |  16
 2 |  16
 3 |   1
 5 |   1
 6 |   4
 7 |   1
(6 rows)

-- invalid for lazy agg
explain verbose select t.b, sum(cc) from (select b, min(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=16)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=16)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, min(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

select t.b, sum(cc) from (select b, min(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b | sum 
---+-----
 1 |   4
 2 |   4
 3 |   3
 5 |   5
 6 |  12
 7 |    
(6 rows)

explain verbose select t.b, avg(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=114.34..114.84 rows=200 width=44)
   Output: t.b, (avg(s1.cc))
   Sort Key: t.b, (avg(s1.cc))
   ->  HashAggregate  (cost=104.20..106.70 rows=200 width=44)
         Output: t.b, avg(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

select t.b, avg(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
 b |        avg         
---+--------------------
 1 | 6.0000000000000000
 2 | 6.0000000000000000
 3 | 3.0000000000000000
 5 | 5.0000000000000000
 6 | 6.0000000000000000
 7 |                   
(6 rows)

------------------------------------------------------------------------------------
-- basic setop
------------------------------------------------------------------------------------
-- same functions
explain verbose select t.b, min(cc) from (select b, min(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=637.09..637.59 rows=200 width=12)
   Output: t.b, (min(t1.c))
   Sort Key: t.b, (min(t1.c))
   ->  HashAggregate  (cost=627.45..629.45 rows=200 width=12)
         Output: t.b, min(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..469.74 rows=31542 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..55.52 rows=3552 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(18 rows)

-- different functions: f(f union all g) or f(g union all f)
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=460.34..460.84 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=450.70..452.70 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..362.96 rows=17547 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..90.60 rows=1976 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t1.b, t1.c
                     ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 2".b, "*SELECT* 2".cc
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t2.b, min(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, count(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=418.38..418.88 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=408.74..410.74 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..321.00 rows=17547 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..68.40 rows=1976 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 2".cc, "*SELECT* 2".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t2.b, count(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, min(cc) from (select b, sum(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=455.90..456.40 rows=200 width=20)
   Output: t.b, (min((sum(t1.c))))
   Sort Key: t.b, (min((sum(t1.c))))
   ->  HashAggregate  (cost=446.26..448.26 rows=200 width=20)
         Output: t.b, min((sum(t1.c)))
         Group By Key: t.b
         ->  Hash Join  (cost=86.60..358.52 rows=17547 distinct=[200, 200] width=12)
               Output: (sum(t1.c)), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=36.64..86.16 rows=1976 width=9)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t1.b, sum(t1.c)
                           Group By Key: t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t1.b, t1.c
                     ->  Subquery Scan on "*SELECT* 2"  (cost=0.00..45.52 rows=1776 width=8)
                           Output: "*SELECT* 2".b, "*SELECT* 2".cc
                           ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

-- different functions: f(g union all g)
explain verbose select t.b, sum(cc) from (select b, max(c) as cc from t1 group by b union all select b, max(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=185.84..186.34 rows=200 width=16)
   Output: t.b, (sum("*SELECT* 1".cc))
   Sort Key: t.b, (sum("*SELECT* 1".cc))
   ->  HashAggregate  (cost=176.20..178.20 rows=200 width=16)
         Output: t.b, sum("*SELECT* 1".cc)
         Group By Key: t.b
         ->  Hash Join  (cost=86.28..158.44 rows=3552 distinct=[200, 200] width=8)
               Output: "*SELECT* 1".cc, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=81.28..81.28 rows=400 width=8)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".b
                     ->  Append  (cost=36.64..81.28 rows=400 width=8)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t1.b, max(t1.c)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t1.b, t1.c
                           ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t2.b, max(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
(28 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b union all select b, count(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=637.59..638.09 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=627.45..629.95 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..469.74 rows=31542 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..55.52 rows=3552 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(18 rows)

-- different functions: f(g union all h)
explain verbose select t.b, sum(cc) from (select b, min(c) as cc from t1 group by b union all select b, max(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=185.84..186.34 rows=200 width=16)
   Output: t.b, (sum("*SELECT* 1".cc))
   Sort Key: t.b, (sum("*SELECT* 1".cc))
   ->  HashAggregate  (cost=176.20..178.20 rows=200 width=16)
         Output: t.b, sum("*SELECT* 1".cc)
         Group By Key: t.b
         ->  Hash Join  (cost=86.28..158.44 rows=3552 distinct=[200, 200] width=8)
               Output: "*SELECT* 1".cc, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=81.28..81.28 rows=400 width=8)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".b
                     ->  Append  (cost=36.64..81.28 rows=400 width=8)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t1.b, min(t1.c)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t1.b, t1.c
                           ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=8)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                       Output: t2.b, max(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
(28 rows)

-- other set op
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union select b, sum(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Sort  (cost=195.84..196.34 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=186.20..188.20 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=96.28..168.44 rows=3552 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=91.28..91.28 rows=400 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=83.28..91.28 rows=400 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=83.28..87.28 rows=400 width=16)
                                 Output: t1.b, (sum(t1.c))
                                 Group By Key: t1.b, (sum(t1.c))
                                 ->  Append  (cost=36.64..81.28 rows=400 width=16)
                                       ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                             Output: t1.b, sum(t1.c)
                                             Group By Key: t1.b
                                             ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                                   Output: t1.b, t1.c
                                       ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                             Output: t2.b, sum(t2.c)
                                             Group By Key: t2.b
                                             ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                   Output: t2.b, t2.c
(29 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b intersect all select b, sum(c) as cc from t2 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=158.48..158.98 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=148.84..150.84 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=87.78..139.96 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=85.28..85.28 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..85.28 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashSetOp Intersect All  (cost=36.64..83.28 rows=200 width=16)
                                 Output: "*SELECT* 1".b, "*SELECT* 1".cc, (0)
                                 ->  Append  (cost=36.64..81.28 rows=400 width=16)
                                       ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=16)
                                             Output: "*SELECT* 1".b, "*SELECT* 1".cc, 0
                                             ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                                   Output: t1.b, sum(t1.c)
                                                   Group By Key: t1.b
                                                   ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                                         Output: t1.b, t1.c
                                       ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=16)
                                             Output: "*SELECT* 2".b, "*SELECT* 2".cc, 1
                                             ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                                   Output: t2.b, sum(t2.c)
                                                   Group By Key: t2.b
                                                   ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                         Output: t2.b, t2.c
(32 rows)

------------------------------------------------------------------------------------
-- complex setop (single super agg)
------------------------------------------------------------------------------------
-- uncomplete agg in setop branch
explain verbose select t.b, sum(cc) from (select b, c as cc from t1 union all select b, sum(c) as cc from t2 group by b union all select b, sum(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=1041.28..1041.78 rows=200 width=44)
   Output: t.b, (sum((("*SELECT* 1".cc)::bigint)))
   Sort Key: t.b, (sum((("*SELECT* 1".cc)::bigint)))
   ->  HashAggregate  (cost=1031.63..1033.63 rows=200 width=44)
         Output: t.b, sum((("*SELECT* 1".cc)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..795.07 rows=47313 distinct=[200, 200] width=12)
               Output: (("*SELECT* 1".cc)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=0.00..145.44 rows=5328 width=8)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..45.52 rows=1776 width=8)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t1.b, t1.c
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t2.b, t2.c
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(22 rows)

-- over-complete agg in setop branch, agg number not match
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc, sum(d) as dd from t1 group by b union all select b, sum(c) as cc, count(d) as dd from t2 group by b union all select b, sum(c) as cc, count(*) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort  (cost=925.84..926.34 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=916.20..918.20 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

-- three items, all setop are union all, item(s) have same function
explain verbose select t.b, min(cc) from (select b, min(c) as cc from t1 group by b union all select b, min(c) as cc from t2 group by b union all select b, min(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=925.84..926.34 rows=200 width=12)
   Output: t.b, (min(t1.c))
   Sort Key: t.b, (min(t1.c))
   ->  HashAggregate  (cost=916.20..918.20 rows=200 width=12)
         Output: t.b, min(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b union all select b, count(c) as cc from t2 group by b union all select b, count(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=926.34..926.84 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=916.20..918.70 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

-- three items, all setop are union all, item(s) have different function, non-delay rewrite
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b union all select b, max(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=789.04..789.54 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=779.40..781.40 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..612.81 rows=33318 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..140.56 rows=3752 width=8)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t1.b, t1.c
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..32.20 rows=1776 width=8)
                           Output: t2.b, t2.c
                     ->  Subquery Scan on "*SELECT* 3"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 3".b, "*SELECT* 3".cc
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t3.b, max(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(25 rows)

-- three items, all setop are union all, item(s) have different function, delay rewrite
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b union all select b, count(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=707.12..707.62 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=697.48..699.48 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..530.89 rows=33318 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..96.16 rows=3752 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.b
                     ->  Subquery Scan on "*SELECT* 3"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 3".cc, "*SELECT* 3".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, count(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(25 rows)

explain verbose select t.b, sum(cc) from (select b, count(*) as cc from t1 group by b union all select b, sum(c) as cc from t2 group by b union all select b, sum(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=707.12..707.62 rows=200 width=44)
   Output: t.b, (sum("*SELECT* 1".cc))
   Sort Key: t.b, (sum("*SELECT* 1".cc))
   ->  HashAggregate  (cost=697.48..699.48 rows=200 width=44)
         Output: t.b, sum("*SELECT* 1".cc)
         Group By Key: t.b
         ->  Hash Join  (cost=86.60..530.89 rows=33318 distinct=[200, 200] width=12)
               Output: "*SELECT* 1".cc, t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=36.64..96.16 rows=3752 width=12)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 1".cc, "*SELECT* 1".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, count(*)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t3.c, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(25 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b union all select b, count(*) as cc from t2 group by b union all select b, count(c) as cc from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=488.41..488.91 rows=200 width=44)
   Output: t.b, (sum(((t1.c)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint)))
   ->  HashAggregate  (cost=478.77..480.77 rows=200 width=44)
         Output: t.b, sum(((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..382.15 rows=19323 distinct=[200, 200] width=12)
               Output: ((t1.c)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..109.04 rows=2176 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.b
                     ->  Subquery Scan on "*SELECT* 2"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 2".cc, "*SELECT* 2".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t2.b, count(*)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: t2.b
                     ->  Subquery Scan on "*SELECT* 3"  (cost=36.64..40.64 rows=200 width=12)
                           Output: "*SELECT* 3".cc, "*SELECT* 3".b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, count(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(30 rows)

-- three items, not all setop(s) are union all, item(s) have same function
explain verbose select t.b, min(cc) from (select b, min(c) as cc from t1 group by b intersect (select b, min(c) as cc from t2 group by b union all select b, min(c) as cc from t3 group by b)) s1, t where s1.b=t.b group by t.b order by 1,2;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=200.12..200.62 rows=200 width=12)
   Output: t.b, (min(s1.cc))
   Sort Key: t.b, (min(s1.cc))
   ->  HashAggregate  (cost=190.48..192.48 rows=200 width=12)
         Output: t.b, min(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=129.42..181.60 rows=1776 distinct=[200, 200] width=8)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=126.92..126.92 rows=200 width=8)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..126.92 rows=200 width=8)
                           Output: s1.cc, s1.b
                           ->  HashSetOp Intersect  (cost=36.64..124.92 rows=200 width=12)
                                 Output: "*SELECT* 1".b, "*SELECT* 1".cc, (0)
                                 ->  Append  (cost=36.64..121.92 rows=600 width=12)
                                       ->  Subquery Scan on "*SELECT* 1"  (cost=36.64..40.64 rows=200 width=12)
                                             Output: "*SELECT* 1".b, "*SELECT* 1".cc, 0
                                             ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                                   Output: t1.b, min(t1.c)
                                                   Group By Key: t1.b
                                                   ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                                         Output: t1.b, t1.c
                                       ->  Result  (cost=36.64..81.28 rows=400 width=12)
                                             Output: t2.b, (min(t2.c)), 1
                                             ->  Append  (cost=36.64..81.28 rows=400 width=12)
                                                   ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                                         Output: t2.b, min(t2.c)
                                                         Group By Key: t2.b
                                                         ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                               Output: t2.b, t2.c
                                                   ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                                         Output: t3.b, min(t3.c)
                                                         Group By Key: t3.b
                                                         ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                                               Output: t3.b, t3.c
(38 rows)

------------------------------------------------------------------------------------
-- parent-query check
------------------------------------------------------------------------------------
-- no agg func OR no group by
explain verbose select t.b from (select b, max(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=308.92..309.42 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=299.28..301.28 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b from (select b, sum(c) as cc from t1 group by b) s1, (select b, count(c) as cc from t1 group by b) s2, t where s1.b=t.b and s2.b=t.b group by t.b order by 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=2286.88..2287.38 rows=200 width=4)
   Output: t.b
   Sort Key: t.b
   ->  HashAggregate  (cost=2277.24..2279.24 rows=200 width=4)
         Output: t.b
         Group By Key: t.b
         ->  Hash Join  (cost=99.92..1927.12 rows=140046 distinct=[200, 200] width=4)
               Output: t.b
               Hash Cond: (lazyagg.t1.b = t.b)
               ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
                     Output: lazyagg.t1.b, lazyagg.t1.b
                     Hash Cond: (lazyagg.t1.b = lazyagg.t1.b)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                           Output: lazyagg.t1.a, lazyagg.t1.b, lazyagg.t1.c, lazyagg.t1.d
                     ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                           Output: lazyagg.t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                 Output: lazyagg.t1.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(22 rows)

explain verbose select b from (select b from t1 group by b) group by b;
                             QUERY PLAN                             
--------------------------------------------------------------------
 HashAggregate  (cost=32.20..34.20 rows=200 width=4)
   Output: t1.b
   Group By Key: t1.b
   ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
         Output: t1.b
(5 rows)

explain verbose select sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b order by 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=338.73..338.73 rows=1 width=36)
   Output: (sum((t1.c)::bigint))
   Sort Key: (sum((t1.c)::bigint))
   ->  Aggregate  (cost=338.71..338.72 rows=1 width=36)
         Output: sum((t1.c)::bigint)
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=4)
               Output: t1.c
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(14 rows)

explain verbose select sum(cc) from (select b, count(*) as cc from t1 group by b) s1, t where s1.b=t.b order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=99.78..99.79 rows=1 width=40)
   Output: (sum(s1.cc))
   Sort Key: (sum(s1.cc))
   ->  Aggregate  (cost=99.76..99.77 rows=1 width=40)
         Output: sum(s1.cc)
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: s1.cc
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, count(*)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
                                       Output: t1.b
(19 rows)

explain verbose select sum(b) from (select b from t1 group by b);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate  (cost=36.70..36.71 rows=1 width=12)
   Output: sum(t1.b)
   ->  HashAggregate  (cost=32.20..34.20 rows=200 width=4)
         Output: t1.b
         Group By Key: t1.b
         ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=4)
               Output: t1.b
(7 rows)

-- agg param is not in subquery, in subquery and super table, OR in multiple subquery
explain verbose select t.b, sum(t.d) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=16)
   Output: t.b, (sum(t.d))
   Sort Key: t.b, (sum(t.d))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=16)
         Output: t.b, sum(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc), sum(t.d) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=56)
   Output: t.b, (sum(s1.cc)), (sum(t.d))
   Sort Key: t.b, (sum(s1.cc)), (sum(t.d))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=56)
         Output: t.b, sum(s1.cc), sum(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=16)
               Output: s1.cc, t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc), sum(t.d) from (select b, sum(c) as cc, a, sum(d) as dd from t1 group by b,a) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=127.16..127.66 rows=200 width=56)
   Output: t.b, (sum(s1.cc)), (sum(t.d))
   Sort Key: t.b, (sum(s1.cc)), (sum(t.d))
   ->  HashAggregate  (cost=117.52..119.52 rows=200 width=56)
         Output: t.b, sum(s1.cc), sum(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=52.02..104.20 rows=1776 distinct=[200, 200] width=16)
               Output: s1.cc, t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=49.52..49.52 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=45.52..49.52 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=45.52..47.52 rows=200 width=32)
                                 Output: t1.b, sum(t1.c), t1.a, sum(t1.d)
                                 Group By Key: t1.b, t1.a
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=16)
                                       Output: t1.b, t1.a, t1.c, t1.d
(20 rows)

explain verbose select t.b, sum(s1.cc) from (select b, sum(c) as cc from t1 group by b) s1, (select b, sum(c) as cc from t2 group by b) s2, t where s1.b=t.b and s2.b=t.b group by t.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=455.34..455.84 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=445.69..447.69 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=93.10..327.41 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
                     Output: t1.c, t1.b, s2.b
                     Hash Cond: (t1.b = s2.b)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.a, t1.b, t1.c, t1.d
                     ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                           Output: s2.b
                           ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=4)
                                 Output: s2.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t2.b, sum(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(27 rows)

explain verbose select t.b, max(s1.cc), max(s2.cc) from (select b, max(c) as cc from t1 group by b) s1, (select b, max(c) as cc from t2 group by b) s2, t where s1.b=t.b and s2.b=t.b group by t.b order by 1,2,3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Sort  (cost=164.17..164.67 rows=200 width=20)
   Output: t.b, (max((max(t1.c)))), (max(s2.cc))
   Sort Key: t.b, (max((max(t1.c)))), (max(s2.cc))
   ->  HashAggregate  (cost=154.53..156.53 rows=200 width=20)
         Output: t.b, max((max(t1.c))), max(s2.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=89.03..141.21 rows=1776 distinct=[200, 200] width=12)
               Output: (max(t1.c)), s2.cc, t.b
               Hash Cond: (t.b = t1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=86.53..86.53 rows=200 width=16)
                     Output: (max(t1.c)), t1.b, s2.cc, s2.b
                     ->  Hash Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=16)
                           Output: (max(t1.c)), t1.b, s2.cc, s2.b
                           Hash Cond: (t1.b = s2.b)
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, max(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
                           ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                                 Output: s2.cc, s2.b
                                 ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=8)
                                       Output: s2.cc, s2.b
                                       ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                             Output: t2.b, max(t2.c)
                                             Group By Key: t2.b
                                             ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                                   Output: t2.b, t2.c
(30 rows)

explain verbose select t.b, min(cc), min(t.d) from (select b, min(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=20)
   Output: t.b, (min(s1.cc)), (min(t.d))
   Sort Key: t.b, (min(s1.cc)), (min(t.d))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=20)
         Output: t.b, min(s1.cc), min(t.d)
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b, t.d
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=12)
                                 Output: t1.b, min(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- expr on agg param
explain verbose select t.b, sum(cc+cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=44)
   Output: t.b, (sum((s1.cc + s1.cc)))
   Sort Key: t.b, (sum((s1.cc + s1.cc)))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=44)
         Output: t.b, sum((s1.cc + s1.cc))
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc*random()) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=127.16..127.66 rows=200 width=20)
   Output: t.b, (sum(((s1.cc)::double precision * random())))
   Sort Key: t.b, (sum(((s1.cc)::double precision * random())))
   ->  HashAggregate  (cost=117.52..119.52 rows=200 width=20)
         Output: t.b, sum(((s1.cc)::double precision * random()))
         Group By Key: t.b
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc)*2.3 from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.28..388.78 rows=200 width=40)
   Output: t.b, ((sum((t1.c)::bigint) * 2.3))
   Sort Key: t.b, ((sum((t1.c)::bigint) * 2.3))
   ->  HashAggregate  (cost=378.13..380.63 rows=200 width=40)
         Output: t.b, (sum((t1.c)::bigint) * 2.3)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- volatile
explain verbose select t.b, sum(cc)*random() from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=389.28..389.78 rows=200 width=40)
   Output: t.b, (((sum((t1.c)::bigint))::double precision * random()))
   Sort Key: t.b, (((sum((t1.c)::bigint))::double precision * random()))
   ->  HashAggregate  (cost=378.13..381.63 rows=200 width=40)
         Output: t.b, ((sum((t1.c)::bigint))::double precision * random())
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- no subquery
explain verbose select t.b, sum(t1.c) from t1, t where t1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.35..348.85 rows=200 width=16)
   Output: t.b, (sum(t1.c))
   Sort Key: t.b, (sum(t1.c))
   ->  HashAggregate  (cost=338.71..340.71 rows=200 width=16)
         Output: t.b, sum(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

------------------------------------------------------------------------------------
-- child-query check
------------------------------------------------------------------------------------
-- no setop no agg
explain verbose select t.b, sum(cc) from (select b, c as cc from t1) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.35..348.85 rows=200 width=16)
   Output: t.b, (sum(t1.c))
   Sort Key: t.b, (sum(t1.c))
   ->  HashAggregate  (cost=338.71..340.71 rows=200 width=16)
         Output: t.b, sum(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- has agg, but no group by
explain verbose select t.b from (select max(b) as b, max(c) as cc from t1) s1, t where s1.b=t.b group by t.b order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Group  (cost=69.12..69.16 rows=9 width=4)
   Output: t.b
   Group By Key: t.b
   ->  Sort  (cost=69.12..69.14 rows=9 width=4)
         Output: t.b
         Sort Key: t.b
         ->  Hash Join  (cost=36.67..68.97 rows=9 distinct=[200, 1] width=4)
               Output: t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=36.66..36.66 rows=1 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..36.66 rows=1 width=4)
                           Output: s1.b
                           ->  Aggregate  (cost=36.64..36.65 rows=1 width=16)
                                 Output: max(t1.b), max(t1.c)
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.a, t1.b, t1.c, t1.d
(19 rows)

-- no agg function, but have group by
explain verbose select count(*) from (select b,c from t1 group by b,c) s1, t where s1.b=t.b group by s1.c order by 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=12)
   Output: (count(*)), s1.c
   Sort Key: (count(*))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=12)
         Output: count(*), s1.c
         Group By Key: s1.c
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=4)
               Output: s1.c
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=8)
                     Output: s1.c, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.c, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=8)
                                 Output: t1.b, t1.c
                                 Group By Key: t1.b, t1.c
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- expr out of agg function
explain verbose select t.b, sum(cc) from (select b, sum(c)*2 as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=114.34..114.84 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=104.70..106.70 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=43.64..95.82 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=41.14..41.14 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..41.14 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..39.14 rows=200 width=16)
                                 Output: t1.b, (sum(t1.c) * 2)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c)+sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.78..119.28 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=109.14..111.14 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=48.08..100.26 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=45.58..45.58 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=41.08..45.58 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=41.08..43.58 rows=200 width=24)
                                 Output: t1.b, (sum(t1.c) + sum(t1.c))
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc) from (select b, cast(sum(c) as int8) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c+d) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.20..427.70 rows=200 width=44)
   Output: t.b, (sum(((t1.c + t1.d))::bigint))
   Sort Key: t.b, (sum(((t1.c + t1.d))::bigint))
   ->  HashAggregate  (cost=417.56..419.56 rows=200 width=44)
         Output: t.b, sum(((t1.c + t1.d))::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- normal function in child-query's target list
explain verbose select aa from (select a, PG_CLIENT_ENCODING() aa from t group by 1) group by 1 order by 1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Group  (cost=0.00..32.20 rows=1 width=0)
   Output: ('UTF8'::name)
   Group By Key: 'UTF8'::name
   ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=0)
         Output: 'UTF8'::name
(5 rows)

------------------------------------------------------------------------------------
-- joint check
------------------------------------------------------------------------------------
-- agg func column in super query join/group by/where
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.cc>t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=5998.54..5999.04 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=5988.90..5990.90 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Nested Loop  (cost=36.64..5396.90 rows=118400 width=12)
               Output: s1.cc, t.b
               Join Filter: (s1.cc > t.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Materialize  (cost=36.64..41.64 rows=200 width=8)
                     Output: s1.cc
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=8)
                           Output: s1.cc
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b and s1.cc>9000 group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.78..119.28 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=109.14..111.14 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Join  (cost=48.08..100.26 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=45.58..45.58 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=41.08..45.58 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=41.08..43.58 rows=200 width=24)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 Filter: (sum(t1.c) > 9000)
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(21 rows)

explain verbose select t.b, cc, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b, s1.cc order by 1,2,3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=222.25..226.69 rows=1776 width=44)
   Output: t.b, s1.cc, (sum(s1.cc))
   Sort Key: t.b, s1.cc, (sum(s1.cc))
   ->  HashAggregate  (cost=108.64..126.40 rows=1776 width=44)
         Output: t.b, s1.cc, sum(s1.cc)
         Group By Key: t.b, s1.cc
         ->  Hash Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: s1.cc, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- join type, normal
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1 left join t on s1.b=t.b group by t.b order by 1,2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select s1.b, sum(cc) from (select b, sum(c) as cc from t1 group by b) s1 where s1.b not in (select t.b from t) group by s1.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=24390.50..24391.00 rows=200 width=40)
   Output: t1.b, (sum((t1.c)::bigint))
   Sort Key: t1.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=24380.86..24382.86 rows=200 width=40)
         Output: t1.b, sum((t1.c)::bigint)
         Group By Key: t1.b
         ->  Nested Loop Anti Join  (cost=0.00..24374.26 rows=879 width=8)
               Output: t1.b, t1.c
               Join Filter: ((t1.b = t.b) OR (t1.b IS NULL) OR (t.b IS NULL))
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Materialize  (cost=0.00..36.64 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- join type, delay rewrite
explain verbose select t.b, sum(cc) from (select b, count(c) as cc from t1 group by b) s1 left join t on s1.b=t.b group by t.b order by 1,2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from t right join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Left Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=113.84..114.34 rows=200 width=44)
   Output: t.b, (sum(s1.cc))
   Sort Key: t.b, (sum(s1.cc))
   ->  HashAggregate  (cost=104.20..106.20 rows=200 width=44)
         Output: t.b, sum(s1.cc)
         Group By Key: t.b
         ->  Hash Full Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=12)
               Output: t.b, s1.cc
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s1.cc, s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=12)
                           Output: s1.cc, s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, count(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

-- join type, multiple join, with SUM(COUNT)
explain verbose select s1.b, sum(cc2) from (select b, sum(c) as cc1 from t1 group by b) s1 left join (select b, sum(c) as cc2 from t2 group by b) s2 on s1.b=s2.b left join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=40)
   Output: s1.b, (sum((t2.c)::bigint))
   Sort Key: s1.b, (sum((t2.c)::bigint))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=40)
         Output: s1.b, sum((t2.c)::bigint)
         Group By Key: s1.b
         ->  Hash Right Join  (cost=43.14..95.32 rows=1776 distinct=[200, 200] width=8)
               Output: s1.b, t2.c
               Hash Cond: (t2.b = s1.b)
               ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t2.a, t2.b, t2.c, t2.d
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(20 rows)

explain verbose select s1.b, sum(cc2) from (select b, sum(c) as cc1 from t1 group by b) s1 left join (select b, count(c) as cc2 from t2 group by b) s2 on s1.b=s2.b left join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=97.17..97.67 rows=200 width=44)
   Output: t1.b, (sum(s2.cc2))
   Sort Key: t1.b, (sum(s2.cc2))
   ->  HashAggregate  (cost=87.53..89.53 rows=200 width=44)
         Output: t1.b, sum(s2.cc2)
         Group By Key: t1.b
         ->  Hash Left Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=12)
               Output: t1.b, s2.cc2
               Hash Cond: (t1.b = s2.b)
               ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                     Output: t1.b, sum(t1.c)
                     Group By Key: t1.b
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                           Output: t1.b, t1.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s2.cc2, s2.b
                     ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=12)
                           Output: s2.cc2, s2.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t2.b, count(t2.c)
                                 Group By Key: t2.b
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t2.b, t2.c
(23 rows)

explain verbose select s1.b, sum(cc3) from (select b, sum(c) as cc1 from t1 group by b) s1 left join ((select b, sum(c) as cc2 from t2 group by b) s2 right join (select b, count(c) as cc3 from t3 group by b) s3 on s2.b=s3.b) on s1.b=s2.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: s1.b, (sum(s3.cc3))
   Sort Key: s1.b, (sum(s3.cc3))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: s1.b, sum(s3.cc3)
         Group By Key: s1.b
         ->  Hash Right Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: s1.b, s3.cc3
               Hash Cond: (t2.b = s1.b)
               ->  Hash Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=12)
                     Output: t2.b, s3.cc3
                     Hash Cond: (t2.b = s3.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t2.b, sum(t2.c)
                           Group By Key: t2.b
                           ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t2.b, t2.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                           Output: s3.cc3, s3.b
                           ->  Subquery Scan on s3  (cost=36.64..40.64 rows=200 width=12)
                                 Output: s3.cc3, s3.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t3.b, count(t3.c)
                                       Group By Key: t3.b
                                       ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t3.b, t3.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(35 rows)

explain verbose select s1.b, sum(cc1) from ((select b, count(c) as cc1 from t1 group by b) s1 left join (select b, sum(c) as cc2 from t2 group by b) s2 on s1.b=s2.b) right join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: t1.b, (sum((count(t1.c))))
   Sort Key: t1.b, (sum((count(t1.c))))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: t1.b, sum((count(t1.c)))
         Group By Key: t1.b
         ->  Hash Right Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: t1.b, (count(t1.c))
               Hash Cond: (s2.b = s3.b)
               ->  Hash Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=16)
                     Output: t1.b, (count(t1.c)), s2.b
                     Hash Cond: (t1.b = s2.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t1.b, count(t1.c)
                           Group By Key: t1.b
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t1.b, t1.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                           Output: s2.b
                           ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=4)
                                 Output: s2.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t2.b, sum(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s3.b
                     ->  Subquery Scan on s3  (cost=36.64..40.64 rows=200 width=4)
                           Output: s3.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, sum(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
(35 rows)

explain verbose select s1.b, sum(cc3) from (select b, sum(c) as cc1 from t1 group by b) s1 right join (select b, sum(c) as cc2 from t2 group by b) s2 on s1.b=s2.b left join (select b, count(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: s1.b, (sum(s3.cc3))
   Sort Key: s1.b, (sum(s3.cc3))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: s1.b, sum(s3.cc3)
         Group By Key: s1.b
         ->  Hash Left Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: s1.b, s3.cc3
               Hash Cond: (t2.b = s3.b)
               ->  Hash Left Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=8)
                     Output: t2.b, s1.b
                     Hash Cond: (t2.b = s1.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t2.b, sum(t2.c)
                           Group By Key: t2.b
                           ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t2.b, t2.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                                 Output: s1.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t1.b, sum(t1.c)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t1.b, t1.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                     Output: s3.cc3, s3.b
                     ->  Subquery Scan on s3  (cost=36.64..40.64 rows=200 width=12)
                           Output: s3.cc3, s3.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t3.b, count(t3.c)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t3.b, t3.c
(35 rows)

explain verbose select s1.b, sum(cc2) from (select b, sum(c) as cc1 from t1 group by b) s1 right join (select b, count(c) as cc2 from t2 group by b) s2 on s1.b=s2.b right join (select b, sum(c) as cc3 from t3 group by b) s3 on s2.b=s3.b group by s1.b order by 1,2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort  (cost=143.06..143.56 rows=200 width=44)
   Output: s1.b, (sum(s2.cc2))
   Sort Key: s1.b, (sum(s2.cc2))
   ->  HashAggregate  (cost=133.42..135.42 rows=200 width=44)
         Output: s1.b, sum(s2.cc2)
         Group By Key: s1.b
         ->  Hash Left Join  (cost=122.92..132.42 rows=200 distinct=[200, 200] width=12)
               Output: s2.cc2, s1.b
               Hash Cond: (s2.b = s1.b)
               ->  Hash Left Join  (cost=79.78..86.53 rows=200 distinct=[200, 200] width=12)
                     Output: s2.cc2, s2.b
                     Hash Cond: (t3.b = s2.b)
                     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                           Output: t3.b, sum(t3.c)
                           Group By Key: t3.b
                           ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                 Output: t3.b, t3.c
                     ->  Hash  (cost=40.64..40.64 rows=200 width=12)
                           Output: s2.cc2, s2.b
                           ->  Subquery Scan on s2  (cost=36.64..40.64 rows=200 width=12)
                                 Output: s2.cc2, s2.b
                                 ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                       Output: t2.b, count(t2.c)
                                       Group By Key: t2.b
                                       ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t2.b, t2.c
               ->  Hash  (cost=40.64..40.64 rows=200 width=4)
                     Output: s1.b
                     ->  Subquery Scan on s1  (cost=36.64..40.64 rows=200 width=4)
                           Output: s1.b
                           ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
                                 Output: t1.b, sum(t1.c)
                                 Group By Key: t1.b
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                                       Output: t1.b, t1.c
(35 rows)

-- super agg func param come from non-agg func column of sub-query
explain verbose select t.b, sum(s1.d) from (select b, d, sum(c) as cc from t1 group by b, d) s1, t where s1.b=t.b group by t.b order by 1,2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=118.28..118.78 rows=200 width=16)
   Output: t.b, (sum(s1.d))
   Sort Key: t.b, (sum(s1.d))
   ->  HashAggregate  (cost=108.64..110.64 rows=200 width=16)
         Output: t.b, sum(s1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=47.58..99.76 rows=1776 distinct=[200, 200] width=8)
               Output: s1.d, t.b
               Hash Cond: (t.b = s1.b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=45.08..45.08 rows=200 width=8)
                     Output: s1.d, s1.b
                     ->  Subquery Scan on s1  (cost=41.08..45.08 rows=200 width=8)
                           Output: s1.d, s1.b
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t1.b, t1.d, sum(t1.c)
                                 Group By Key: t1.b, t1.d
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t1.b, t1.d, t1.c
(20 rows)

------------------------------------------------------------------------------------
-- multi-agg functions
------------------------------------------------------------------------------------
-- single subquery, different order of super-agg and sub-agg
explain verbose select t.b, sum(cc), max(dd) from (select b, sum(c) as cc, max(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.20..427.70 rows=200 width=48)
   Output: t.b, (sum((t1.c)::bigint)), (max(t1.d))
   Sort Key: t.b, (sum((t1.c)::bigint)), (max(t1.d))
   ->  HashAggregate  (cost=417.56..419.56 rows=200 width=48)
         Output: t.b, sum((t1.c)::bigint), max(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(dd), sum(cc) from (select b, sum(c) as cc, count(*) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.70..428.20 rows=200 width=48)
   Output: t.b, ((count(1::bigint))::numeric), (sum((t1.c)::bigint))
   Sort Key: t.b, ((count(1::bigint))::numeric), (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=417.56..420.06 rows=200 width=48)
         Output: t.b, count(1::bigint), sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select max(dd), t.b, sum(cc) from (select b, sum(c) as cc, max(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=427.20..427.70 rows=200 width=48)
   Output: (max(t1.d)), t.b, (sum((t1.c)::bigint))
   Sort Key: (max(t1.d)), t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=417.56..419.56 rows=200 width=48)
         Output: max(t1.d), t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.d, t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, min(cc), sum(dd) from (select b, min(c) as cc, count(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.28..388.78 rows=200 width=24)
   Output: t.b, (min(t1.c)), ((count(t1.d))::numeric)
   Sort Key: t.b, (min(t1.c)), ((count(t1.d))::numeric)
   ->  HashAggregate  (cost=378.13..380.63 rows=200 width=24)
         Output: t.b, min(t1.c), count(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, count(c) as cc, count(*) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.78..389.28 rows=200 width=24)
   Output: t.b, ((count(t1.c))::numeric), ((count(1::bigint))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric), ((count(1::bigint))::numeric)
   ->  HashAggregate  (cost=378.13..381.13 rows=200 width=24)
         Output: t.b, count(t1.c), count(1::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- simple setop
explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, sum(d) as dd from t1 group by b union all select b, sum(c) as cc, sum(d) as dd from t2 group by b union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort  (cost=1044.12..1044.62 rows=200 width=84)
   Output: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   ->  HashAggregate  (cost=1034.48..1036.48 rows=200 width=84)
         Output: t.b, sum(((t1.c)::bigint)), sum(((t1.d)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=20)
               Output: ((t1.c)::bigint), ((t1.d)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=20)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t1.c, t1.d, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t2.c, t2.d, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t3.c, t3.d, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

explain verbose select t.b, sum(cc), max(dd) from (select b, count(c) as cc, max(d) as dd from t1 group by b union all select b, count(c) as cc, max(d) as dd from t2 group by b union all select b, count(c) as cc, max(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort  (cost=1044.62..1045.12 rows=200 width=24)
   Output: t.b, ((count(t1.c))::numeric), (max(t1.d))
   Sort Key: t.b, ((count(t1.c))::numeric), (max(t1.d))
   ->  HashAggregate  (cost=1034.48..1036.98 rows=200 width=24)
         Output: t.b, count(t1.c), max(t1.d)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..679.63 rows=47313 distinct=[200, 200] width=12)
               Output: t1.c, t1.d, t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..83.28 rows=5328 width=12)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t1.c, t1.d, t1.b
                     ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t2.c, t2.d, t2.b
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                           Output: t3.c, t3.d, t3.b
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(20 rows)

-- complex setop, one is valid and another is invalid
explain verbose select t.b, sum(cc), min(dd) from (select b, sum(c) as cc, min(d) as dd from t1 group by b union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort  (cost=508.65..509.15 rows=200 width=60)
   Output: t.b, (sum("*SELECT* 1".cc)), (min((("*SELECT* 1".dd)::bigint)))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (min((("*SELECT* 1".dd)::bigint)))
   ->  HashAggregate  (cost=499.00..501.00 rows=200 width=60)
         Output: t.b, sum("*SELECT* 1".cc), min((("*SELECT* 1".dd)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..367.40 rows=17547 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, (("*SELECT* 1".dd)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=0.00..95.04 rows=1976 width=14)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=0.00..49.96 rows=1776 width=12)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc, "*SELECT* 1".dd
                           ->  Seq Scan on lazyagg.t1  (cost=0.00..32.20 rows=1776 width=12)
                                 Output: t1.b, t1.c, t1.d
                     ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                           Output: t3.b, sum(t3.c), sum(t3.d)
                           Group By Key: t3.b
                           ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                                 Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, sum(d) as dd from t1 group by b union all select b, sum(c) as cc, count(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=466.69..467.19 rows=200 width=84)
   Output: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   Sort Key: t.b, (sum(((t1.c)::bigint))), (sum(((t1.d)::bigint)))
   ->  HashAggregate  (cost=457.04..459.04 rows=200 width=84)
         Output: t.b, sum(((t1.c)::bigint)), sum(((t1.d)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..325.44 rows=17547 distinct=[200, 200] width=20)
               Output: ((t1.c)::bigint), ((t1.d)::bigint), t.b
               Hash Cond: (t1.b = t.b)
               ->  Append  (cost=0.00..72.84 rows=1976 width=20)
                     ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=20)
                           Output: t1.c, t1.d, t1.b
                     ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 2".cc, "*SELECT* 2".dd, "*SELECT* 2".b
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                 Output: t3.b, sum(t3.c), count(t3.d)
                                 Group By Key: t3.b
                                 ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, count(c) as cc, sum(d) as dd from t1 group by b union all select b, count(c) as cc, count(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=203.60..204.10 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   ->  HashAggregate  (cost=193.96..195.96 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum("*SELECT* 1".dd)
         Group By Key: t.b
         ->  Hash Join  (cost=95.16..167.32 rows=3552 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, "*SELECT* 1".dd, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=90.16..90.16 rows=400 width=20)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                     ->  Append  (cost=41.08..90.16 rows=400 width=20)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                       Output: t1.b, count(t1.c), sum(t1.d)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                             Output: t1.b, t1.c, t1.d
                           ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".dd, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                       Output: t3.b, count(t3.c), count(t3.d)
                                       Group By Key: t3.b
                                       ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=12)
                                             Output: t3.b, t3.c, t3.d
(28 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, count(c) as cc, count(d) as dd from t1 group by b union all select b, count(c) as cc, count(*) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=203.60..204.10 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum("*SELECT* 1".dd))
   ->  HashAggregate  (cost=193.96..195.96 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum("*SELECT* 1".dd)
         Group By Key: t.b
         ->  Hash Join  (cost=95.16..167.32 rows=3552 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, "*SELECT* 1".dd, t.b
               Hash Cond: (t.b = "*SELECT* 1".b)
               ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                     Output: t.a, t.b, t.c, t.d
               ->  Hash  (cost=90.16..90.16 rows=400 width=20)
                     Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                     ->  Append  (cost=41.08..90.16 rows=400 width=20)
                           ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 1".cc, "*SELECT* 1".dd, "*SELECT* 1".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=28)
                                       Output: t1.b, count(t1.c), count(t1.d)
                                       Group By Key: t1.b
                                       ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                             Output: t1.b, t1.c, t1.d
                           ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                                 Output: "*SELECT* 2".cc, "*SELECT* 2".dd, "*SELECT* 2".b
                                 ->  HashAggregate  (cost=41.08..43.08 rows=200 width=24)
                                       Output: t3.b, count(t3.c), count(*)
                                       Group By Key: t3.b
                                       ->  Seq Scan on lazyagg.t3  (cost=0.00..27.76 rows=1776 width=8)
                                             Output: t3.b, t3.c
(28 rows)

-- complex setop: agg func number not match in setop branch
explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, d as dd from t1 group by b,d union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=513.09..513.59 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   ->  HashAggregate  (cost=503.44..505.44 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum((("*SELECT* 1".dd)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=91.04..371.84 rows=17547 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, (("*SELECT* 1".dd)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=41.08..99.48 rows=1976 width=13)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc, "*SELECT* 1".dd
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t1.b, sum(t1.c), t1.d
                                 Group By Key: t1.b, t1.d
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t1.b, t1.d, t1.c
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..36.64 rows=1776 width=12)
                           Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(23 rows)

explain verbose select t.b, sum(cc), sum(dd) from (select b, sum(c) as cc, d as dd from t1 group by b,d union all select b, c as cc, sum(d) as dd from t2 group by b,c union all select b, sum(c) as cc, sum(d) as dd from t3 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=594.00..594.50 rows=200 width=84)
   Output: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   Sort Key: t.b, (sum("*SELECT* 1".cc)), (sum((("*SELECT* 1".dd)::bigint)))
   ->  HashAggregate  (cost=584.35..586.35 rows=200 width=84)
         Output: t.b, sum("*SELECT* 1".cc), sum((("*SELECT* 1".dd)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=91.04..439.43 rows=19323 distinct=[200, 200] width=20)
               Output: "*SELECT* 1".cc, (("*SELECT* 1".dd)::bigint), t.b
               Hash Cond: ("*SELECT* 1".b = t.b)
               ->  Append  (cost=41.08..144.56 rows=2176 width=13)
                     ->  Subquery Scan on "*SELECT* 1"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 1".b, "*SELECT* 1".cc, "*SELECT* 1".dd
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t1.b, sum(t1.c), t1.d
                                 Group By Key: t1.b, t1.d
                                 ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t1.b, t1.d, t1.c
                     ->  Subquery Scan on "*SELECT* 2"  (cost=41.08..45.08 rows=200 width=20)
                           Output: "*SELECT* 2".b, "*SELECT* 2".cc, "*SELECT* 2".dd
                           ->  HashAggregate  (cost=41.08..43.08 rows=200 width=20)
                                 Output: t2.b, t2.c, sum(t2.d)
                                 Group By Key: t2.b, t2.c
                                 ->  Seq Scan on lazyagg.t2  (cost=0.00..27.76 rows=1776 width=12)
                                       Output: t2.b, t2.c, t2.d
                     ->  Seq Scan on lazyagg.t3  (cost=0.00..36.64 rows=1776 width=12)
                           Output: t3.b, t3.c, t3.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(30 rows)

-- 1--n
explain verbose select t.b, sum(cc) from (select b, sum(c) as cc, min(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, sum(c) as cc, avg(d)+1 as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc, sum(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) from (select b, count(c) as cc, avg(d) as dd from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=348.85..349.35 rows=200 width=16)
   Output: t.b, ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=338.71..341.21 rows=200 width=16)
         Output: t.b, count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- n--1
explain verbose select t.b, sum(cc), sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=466.63..467.13 rows=200 width=72)
   Output: t.b, (sum((t1.c)::bigint)), (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=456.99..458.99 rows=200 width=72)
         Output: t.b, sum((t1.c)::bigint), sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc), sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=388.78..389.28 rows=200 width=24)
   Output: t.b, ((count(t1.c))::numeric), ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=378.13..381.13 rows=200 width=24)
         Output: t.b, count(t1.c), count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc), sum(cc), sum(cc), sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2,3,4,5;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=468.63..469.13 rows=200 width=40)
   Output: t.b, ((count(t1.c))::numeric), ((count(t1.c))::numeric), ((count(t1.c))::numeric), ((count(t1.c))::numeric)
   Sort Key: t.b, ((count(t1.c))::numeric)
   ->  HashAggregate  (cost=456.99..460.99 rows=200 width=40)
         Output: t.b, count(t1.c), count(t1.c), count(t1.c), count(t1.c)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- n--1, expr
explain verbose select t.b, sum(cc) + sum(cc) from (select b, sum(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=467.13..467.63 rows=200 width=72)
   Output: t.b, ((sum((t1.c)::bigint) + sum((t1.c)::bigint)))
   Sort Key: t.b, ((sum((t1.c)::bigint) + sum((t1.c)::bigint)))
   ->  HashAggregate  (cost=456.99..459.49 rows=200 width=72)
         Output: t.b, (sum((t1.c)::bigint) + sum((t1.c)::bigint))
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

explain verbose select t.b, sum(cc) + sum(cc) from (select b, count(c) as cc from t1 group by b) s1, t where s1.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=389.28..389.78 rows=200 width=24)
   Output: t.b, (((count(t1.c))::numeric + (count(t1.c))::numeric))
   Sort Key: t.b, (((count(t1.c))::numeric + (count(t1.c))::numeric))
   ->  HashAggregate  (cost=378.13..381.63 rows=200 width=24)
         Output: t.b, ((count(t1.c))::numeric + (count(t1.c))::numeric)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

------------------------------------------------------------------------------------
-- CTE
------------------------------------------------------------------------------------
-- basic with as
explain verbose with s as (select b, sum(c) as cc from t1 group by b) select t.b, sum(cc) from s, t where s.b=t.b group by t.b order by 1,2;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort  (cost=387.78..388.28 rows=200 width=40)
   Output: t.b, (sum((t1.c)::bigint))
   Sort Key: t.b, (sum((t1.c)::bigint))
   ->  HashAggregate  (cost=378.13..380.13 rows=200 width=40)
         Output: t.b, sum((t1.c)::bigint)
         Group By Key: t.b
         ->  Hash Join  (cost=49.96..259.85 rows=15771 distinct=[200, 200] width=8)
               Output: t1.c, t.b
               Hash Cond: (t1.b = t.b)
               ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                     Output: t1.a, t1.b, t1.c, t1.d
               ->  Hash  (cost=27.76..27.76 rows=1776 width=4)
                     Output: t.b
                     ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=4)
                           Output: t.b
(15 rows)

-- multi-usage
explain verbose with s1(b, cc) as (select b, sum(c) from t1 group by b) select count(*) from s1 where cc > (select sum(cc)/100 from s1) order by 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=48.34..48.35 rows=1 width=8)
   Output: (count(*))
   Sort Key: (count(*))
   CTE s1
     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                 Output: t1.b, t1.c
   InitPlan 2 (returns $1)
     ->  Aggregate  (cost=4.50..4.51 rows=1 width=40)
           Output: (sum(s1.cc) / 100::numeric)
           ->  CTE Scan on s1  (cost=0.00..4.00 rows=200 width=8)
                 Output: s1.b, s1.cc
   ->  Aggregate  (cost=5.17..5.18 rows=1 width=8)
         Output: count(*)
         ->  CTE Scan on s1  (cost=0.00..5.00 rows=67 width=0)
               Output: s1.b, s1.cc
               Filter: ((s1.cc)::numeric > $1)
(19 rows)

-- pull up
explain verbose with s as (select b, sum(c) as cc from t1 group by b) select a, b, c, d from t where b not in (select sum(cc) from s group by b) order by 1,2,3,4;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=4673.57..4675.77 rows=879 width=16)
   Output: t.a, t.b, t.c, t.d
   Sort Key: t.a, t.b, t.c, t.d
   CTE s
     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                 Output: t1.b, t1.c
   ->  Nested Loop Anti Join  (cost=5.00..4591.95 rows=879 width=16)
         Output: t.a, t.b, t.c, t.d
         Join Filter: (((t.b)::numeric = "ANY_subquery".sum) OR ((t.b)::numeric IS NULL) OR ("ANY_subquery".sum IS NULL))
         ->  Seq Scan on lazyagg.t  (cost=0.00..27.76 rows=1776 width=16)
               Output: t.a, t.b, t.c, t.d
         ->  Materialize  (cost=5.00..10.00 rows=200 width=32)
               Output: "ANY_subquery".sum
               ->  Subquery Scan on "ANY_subquery"  (cost=5.00..9.00 rows=200 width=32)
                     Output: "ANY_subquery".sum
                     ->  HashAggregate  (cost=5.00..7.00 rows=200 width=44)
                           Output: sum(s.cc), s.b
                           Group By Key: s.b
                           ->  CTE Scan on s  (cost=0.00..4.00 rows=200 width=12)
                                 Output: s.b, s.cc
(23 rows)

-- not pull up
explain verbose with s as (select b, sum(c) as cc from t1 group by b) select 1 from t where exists (select b, sum(cc) from s where s.b=t.b group by b);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Seq Scan on lazyagg.t  (cost=38.64..8085.04 rows=888 width=0)
   Output: 1
   Filter: (SubPlan 2)
   CTE s
     ->  HashAggregate  (cost=36.64..38.64 rows=200 width=16)
           Output: t1.b, sum(t1.c)
           Group By Key: t1.b
           ->  Seq Scan on lazyagg.t1  (cost=0.00..27.76 rows=1776 width=8)
                 Output: t1.b, t1.c
   SubPlan 2
     ->  GroupAggregate  (cost=0.00..4.52 rows=1 width=44)
           Output: s.b, sum(s.cc)
           Group By Key: s.b
           ->  CTE Scan on s  (cost=0.00..4.50 rows=1 width=12)
                 Output: s.b, s.cc
                 Filter: (s.b = t.b)
(16 rows)

set enable_seqscan_fusion = off;
-- delete data and shema
------------------------------------------------------------------------------------
drop schema lazyagg cascade;
NOTICE:  drop cascades to 8 other objects
DETAIL:  drop cascades to table t
drop cascades to table t1
drop cascades to table t2
drop cascades to table t3
drop cascades to table t_empty
drop cascades to table t_type
drop cascades to view v
drop cascades to view v1
