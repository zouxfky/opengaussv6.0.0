DROP SCHEMA partition_minmax CASCADE;
ERROR:  schema "partition_minmax" does not exist
CREATE SCHEMA partition_minmax;
SET CURRENT_SCHEMA TO partition_minmax;
--range单列分区单列索引
drop table test_range_pt;
ERROR:  table "test_range_pt" does not exist
create table test_range_pt (a int, b int, c int)
partition by range(a)
(
	partition p1 values less than (2000),
	partition p2 values less than (3000),
	partition p3 values less than (4000),
	partition p4 values less than (5000),
	partition p5 values less than (maxvalue)
)ENABLE ROW MOVEMENT;
 
create index idx_range_a on test_range_pt(a) local;
create index idx_range_b on test_range_pt(b) local;
insert into test_range_pt values(1, 1 ,1);
insert into test_range_pt values(2001, 3 ,1);
insert into test_range_pt values(3001, 2 ,1);
insert into test_range_pt values(4001, 4 ,1);
explain(costs off, verbose on) select min(a) from test_range_pt;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.a
           ->  Partition Iterator
                 Output: partition_minmax.test_range_pt.a
                 Iterations: 5
                 ->  Partitioned Index Only Scan using idx_range_a on partition_minmax.test_range_pt
                       Output: partition_minmax.test_range_pt.a
                       Index Cond: (partition_minmax.test_range_pt.a IS NOT NULL)
                       Selected Partitions:  1..5
(12 rows)

select min(a) from test_range_pt;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(a) from test_range_pt;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.a
           ->  Partition Iterator Scan Backward
                 Output: partition_minmax.test_range_pt.a
                 Iterations: 5
                 ->  Partitioned Index Only Scan Backward using idx_range_a on partition_minmax.test_range_pt
                       Output: partition_minmax.test_range_pt.a
                       Index Cond: (partition_minmax.test_range_pt.a IS NOT NULL)
                       Selected Partitions:  1..5
(12 rows)

select max(a) from test_range_pt;
 max  
------
 4001
(1 row)

explain(costs off, verbose on) select min(b) from test_range_pt;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.b
           ->  Sort
                 Output: partition_minmax.test_range_pt.b
                 Sort Key: partition_minmax.test_range_pt.b
                 ->  Partition Iterator
                       Output: partition_minmax.test_range_pt.b
                       Iterations: 5
                       ->  Limit
                             Output: partition_minmax.test_range_pt.b
                             ->  Partitioned Index Only Scan using idx_range_b on partition_minmax.test_range_pt
                                   Output: partition_minmax.test_range_pt.b
                                   Index Cond: (partition_minmax.test_range_pt.b IS NOT NULL)
                                   Selected Partitions:  1..5
(17 rows)

select min(b) from test_range_pt;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(b) from test_range_pt;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.b
           ->  Sort
                 Output: partition_minmax.test_range_pt.b
                 Sort Key: partition_minmax.test_range_pt.b DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_range_pt.b
                       Iterations: 5
                       ->  Limit
                             Output: partition_minmax.test_range_pt.b
                             ->  Partitioned Index Only Scan Backward using idx_range_b on partition_minmax.test_range_pt
                                   Output: partition_minmax.test_range_pt.b
                                   Index Cond: (partition_minmax.test_range_pt.b IS NOT NULL)
                                   Selected Partitions:  1..5
(17 rows)

select max(b) from test_range_pt;
 max 
-----
   4
(1 row)

--range单列分区多列索引
drop index idx_range_a;
drop index idx_range_b;
create index idx_range_ab on test_range_pt(a,b) local;
explain(costs off, verbose on) select min(a) from test_range_pt;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.a
           ->  Partition Iterator
                 Output: partition_minmax.test_range_pt.a
                 Iterations: 5
                 ->  Partitioned Index Only Scan using idx_range_ab on partition_minmax.test_range_pt
                       Output: partition_minmax.test_range_pt.a
                       Index Cond: (partition_minmax.test_range_pt.a IS NOT NULL)
                       Selected Partitions:  1..5
(12 rows)

select min(a) from test_range_pt;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(a) from test_range_pt;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.a
           ->  Partition Iterator Scan Backward
                 Output: partition_minmax.test_range_pt.a
                 Iterations: 5
                 ->  Partitioned Index Only Scan Backward using idx_range_ab on partition_minmax.test_range_pt
                       Output: partition_minmax.test_range_pt.a
                       Index Cond: (partition_minmax.test_range_pt.a IS NOT NULL)
                       Selected Partitions:  1..5
(12 rows)

select max(a) from test_range_pt;
 max  
------
 4001
(1 row)

--多列索引非第一列不优化
explain(costs off, verbose on) select min(b) from test_range_pt;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Aggregate
   Output: min(b)
   ->  Partition Iterator
         Output: a, b, c
         Iterations: 5
         ->  Partitioned Seq Scan on partition_minmax.test_range_pt
               Output: a, b, c
               Selected Partitions:  1..5
(8 rows)

select min(b) from test_range_pt;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(b) from test_range_pt;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Aggregate
   Output: max(b)
   ->  Partition Iterator
         Output: a, b, c
         Iterations: 5
         ->  Partitioned Seq Scan on partition_minmax.test_range_pt
               Output: a, b, c
               Selected Partitions:  1..5
(8 rows)

select max(b) from test_range_pt;
 max 
-----
   4
(1 row)

--range多列分区
drop table test_range_pt1;
ERROR:  table "test_range_pt1" does not exist
create table test_range_pt1 (a int, b int, c int)
partition by range(a,b)
(
	partition p1 values less than (2000,10),
	partition p2 values less than (3000,20),
	partition p3 values less than (4000,30),
	partition p4 values less than (5000,40)
)ENABLE ROW MOVEMENT;
 
create index idx_range1_a on test_range_pt1(a) local;
create index idx_range1_b on test_range_pt1(b) local;
insert into test_range_pt1 values(1, 1 ,1);
insert into test_range_pt1 values(2001, 3 ,1);
insert into test_range_pt1 values(3001, 2 ,1);
insert into test_range_pt1 values(2001, 30 ,1);
insert into test_range_pt1 values(3001, 20 ,1);
explain(costs off, verbose on) select min(a) from test_range_pt1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt1.a
           ->  Partition Iterator
                 Output: partition_minmax.test_range_pt1.a
                 Iterations: 4
                 ->  Partitioned Index Only Scan using idx_range1_a on partition_minmax.test_range_pt1
                       Output: partition_minmax.test_range_pt1.a
                       Index Cond: (partition_minmax.test_range_pt1.a IS NOT NULL)
                       Selected Partitions:  1..4
(12 rows)

select min(a) from test_range_pt1;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(a) from test_range_pt1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt1.a
           ->  Partition Iterator Scan Backward
                 Output: partition_minmax.test_range_pt1.a
                 Iterations: 4
                 ->  Partitioned Index Only Scan Backward using idx_range1_a on partition_minmax.test_range_pt1
                       Output: partition_minmax.test_range_pt1.a
                       Index Cond: (partition_minmax.test_range_pt1.a IS NOT NULL)
                       Selected Partitions:  1..4
(12 rows)

select max(a) from test_range_pt1;
 max  
------
 3001
(1 row)

explain(costs off, verbose on) select min(b) from test_range_pt1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt1.b
           ->  Sort
                 Output: partition_minmax.test_range_pt1.b
                 Sort Key: partition_minmax.test_range_pt1.b
                 ->  Partition Iterator
                       Output: partition_minmax.test_range_pt1.b
                       Iterations: 4
                       ->  Limit
                             Output: partition_minmax.test_range_pt1.b
                             ->  Partitioned Index Only Scan using idx_range1_b on partition_minmax.test_range_pt1
                                   Output: partition_minmax.test_range_pt1.b
                                   Index Cond: (partition_minmax.test_range_pt1.b IS NOT NULL)
                                   Selected Partitions:  1..4
(17 rows)

select min(b) from test_range_pt1;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(b) from test_range_pt1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt1.b
           ->  Sort
                 Output: partition_minmax.test_range_pt1.b
                 Sort Key: partition_minmax.test_range_pt1.b DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_range_pt1.b
                       Iterations: 4
                       ->  Limit
                             Output: partition_minmax.test_range_pt1.b
                             ->  Partitioned Index Only Scan Backward using idx_range1_b on partition_minmax.test_range_pt1
                                   Output: partition_minmax.test_range_pt1.b
                                   Index Cond: (partition_minmax.test_range_pt1.b IS NOT NULL)
                                   Selected Partitions:  1..4
(17 rows)

select max(b) from test_range_pt1;
 max 
-----
  30
(1 row)

--range多列分区多列索引
drop index idx_range1_a;
drop index idx_range1_b;
create index idx_range1_ab on test_range_pt1(a,b) local;
explain(costs off, verbose on) select min(a) from test_range_pt1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt1.a
           ->  Partition Iterator
                 Output: partition_minmax.test_range_pt1.a
                 Iterations: 4
                 ->  Partitioned Index Only Scan using idx_range1_ab on partition_minmax.test_range_pt1
                       Output: partition_minmax.test_range_pt1.a
                       Index Cond: (partition_minmax.test_range_pt1.a IS NOT NULL)
                       Selected Partitions:  1..4
(12 rows)

select min(a) from test_range_pt1;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(a) from test_range_pt1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt1.a
           ->  Partition Iterator Scan Backward
                 Output: partition_minmax.test_range_pt1.a
                 Iterations: 4
                 ->  Partitioned Index Only Scan Backward using idx_range1_ab on partition_minmax.test_range_pt1
                       Output: partition_minmax.test_range_pt1.a
                       Index Cond: (partition_minmax.test_range_pt1.a IS NOT NULL)
                       Selected Partitions:  1..4
(12 rows)

select max(a) from test_range_pt1;
 max  
------
 3001
(1 row)

--多列索引非第一列不优化
explain(costs off, verbose on) select min(b) from test_range_pt1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Aggregate
   Output: min(b)
   ->  Partition Iterator
         Output: a, b, c
         Iterations: 4
         ->  Partitioned Seq Scan on partition_minmax.test_range_pt1
               Output: a, b, c
               Selected Partitions:  1..4
(8 rows)

select min(b) from test_range_pt1;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(b) from test_range_pt1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Aggregate
   Output: max(b)
   ->  Partition Iterator
         Output: a, b, c
         Iterations: 4
         ->  Partitioned Seq Scan on partition_minmax.test_range_pt1
               Output: a, b, c
               Selected Partitions:  1..4
(8 rows)

select max(b) from test_range_pt1;
 max 
-----
  30
(1 row)

--list分区单列索引
drop table test_list_lt;
ERROR:  table "test_list_lt" does not exist
create table test_list_lt (a int, b int )
partition by list(a)
(
	partition p1 values (2000),
	partition p2 values (3000),
	partition p3 values (4000)
) ;
create index idx_list_a on test_list_lt(a) local;
create index idx_list_b on test_list_lt(b) local;
insert into test_list_lt values(3000, 2);
insert into test_list_lt values(2000, 30);
insert into test_list_lt values(4000, 20);
explain(costs off, verbose on) select min(a) from test_list_lt;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.a
           ->  Sort
                 Output: partition_minmax.test_list_lt.a
                 Sort Key: partition_minmax.test_list_lt.a
                 ->  Partition Iterator
                       Output: partition_minmax.test_list_lt.a
                       Iterations: 3
                       ->  Limit
                             Output: partition_minmax.test_list_lt.a
                             ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt
                                   Output: partition_minmax.test_list_lt.a
                                   Index Cond: (partition_minmax.test_list_lt.a IS NOT NULL)
                                   Selected Partitions:  1..3
(17 rows)

select min(a) from test_list_lt;
 min  
------
 2000
(1 row)

explain(costs off, verbose on) select max(a) from test_list_lt;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.a
           ->  Sort
                 Output: partition_minmax.test_list_lt.a
                 Sort Key: partition_minmax.test_list_lt.a DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_list_lt.a
                       Iterations: 3
                       ->  Limit
                             Output: partition_minmax.test_list_lt.a
                             ->  Partitioned Index Only Scan Backward using idx_list_a on partition_minmax.test_list_lt
                                   Output: partition_minmax.test_list_lt.a
                                   Index Cond: (partition_minmax.test_list_lt.a IS NOT NULL)
                                   Selected Partitions:  1..3
(17 rows)

select max(a) from test_list_lt;
 max  
------
 4000
(1 row)

explain(costs off, verbose on) select min(b) from test_list_lt;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.b
           ->  Sort
                 Output: partition_minmax.test_list_lt.b
                 Sort Key: partition_minmax.test_list_lt.b
                 ->  Partition Iterator
                       Output: partition_minmax.test_list_lt.b
                       Iterations: 3
                       ->  Limit
                             Output: partition_minmax.test_list_lt.b
                             ->  Partitioned Index Only Scan using idx_list_b on partition_minmax.test_list_lt
                                   Output: partition_minmax.test_list_lt.b
                                   Index Cond: (partition_minmax.test_list_lt.b IS NOT NULL)
                                   Selected Partitions:  1..3
(17 rows)

select min(b) from test_list_lt;
 min 
-----
   2
(1 row)

explain(costs off, verbose on) select max(b) from test_list_lt;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.b
           ->  Sort
                 Output: partition_minmax.test_list_lt.b
                 Sort Key: partition_minmax.test_list_lt.b DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_list_lt.b
                       Iterations: 3
                       ->  Limit
                             Output: partition_minmax.test_list_lt.b
                             ->  Partitioned Index Only Scan Backward using idx_list_b on partition_minmax.test_list_lt
                                   Output: partition_minmax.test_list_lt.b
                                   Index Cond: (partition_minmax.test_list_lt.b IS NOT NULL)
                                   Selected Partitions:  1..3
(17 rows)

select max(b) from test_list_lt;
 max 
-----
  30
(1 row)

--list分区多列索引
drop index idx_list_a;
drop index idx_list_b;
create index idx_list_ab on test_list_lt(a,b) local;
explain(costs off, verbose on) select min(a) from test_list_lt;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.a
           ->  Sort
                 Output: partition_minmax.test_list_lt.a
                 Sort Key: partition_minmax.test_list_lt.a
                 ->  Partition Iterator
                       Output: partition_minmax.test_list_lt.a
                       Iterations: 3
                       ->  Limit
                             Output: partition_minmax.test_list_lt.a
                             ->  Partitioned Index Only Scan using idx_list_ab on partition_minmax.test_list_lt
                                   Output: partition_minmax.test_list_lt.a
                                   Index Cond: (partition_minmax.test_list_lt.a IS NOT NULL)
                                   Selected Partitions:  1..3
(17 rows)

select min(a) from test_list_lt;
 min  
------
 2000
(1 row)

explain(costs off, verbose on) select max(a) from test_list_lt;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.a
           ->  Sort
                 Output: partition_minmax.test_list_lt.a
                 Sort Key: partition_minmax.test_list_lt.a DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_list_lt.a
                       Iterations: 3
                       ->  Limit
                             Output: partition_minmax.test_list_lt.a
                             ->  Partitioned Index Only Scan Backward using idx_list_ab on partition_minmax.test_list_lt
                                   Output: partition_minmax.test_list_lt.a
                                   Index Cond: (partition_minmax.test_list_lt.a IS NOT NULL)
                                   Selected Partitions:  1..3
(17 rows)

select max(a) from test_list_lt;
 max  
------
 4000
(1 row)

--多列索引非第一列不优化
explain(costs off, verbose on) select min(b) from test_list_lt;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Aggregate
   Output: min(b)
   ->  Partition Iterator
         Output: a, b
         Iterations: 3
         ->  Partitioned Seq Scan on partition_minmax.test_list_lt
               Output: a, b
               Selected Partitions:  1..3
(8 rows)

select min(b) from test_list_lt;
 min 
-----
   2
(1 row)

explain(costs off, verbose on) select max(b) from test_list_lt;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Aggregate
   Output: max(b)
   ->  Partition Iterator
         Output: a, b
         Iterations: 3
         ->  Partitioned Seq Scan on partition_minmax.test_list_lt
               Output: a, b
               Selected Partitions:  1..3
(8 rows)

select max(b) from test_list_lt;
 max 
-----
  30
(1 row)

--hash分区单列索引
drop table test_hash_ht;
ERROR:  table "test_hash_ht" does not exist
create table test_hash_ht (a int, b int)
partition by hash(a)
(
	partition p1, 
	partition p2,  
	partition p3,
	partition p4,
	partition p5,
	partition p6,
	partition p7,
	partition p8
);
create index idx_hash_a on test_hash_ht(a) local;
create index idx_hash_b on test_hash_ht(b) local;
insert into test_hash_ht values(generate_series(1,100),generate_series(1,100));
explain(costs off, verbose on) select min(a) from test_hash_ht;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_hash_ht.a
           ->  Sort
                 Output: partition_minmax.test_hash_ht.a
                 Sort Key: partition_minmax.test_hash_ht.a
                 ->  Partition Iterator
                       Output: partition_minmax.test_hash_ht.a
                       Iterations: 8
                       ->  Limit
                             Output: partition_minmax.test_hash_ht.a
                             ->  Partitioned Index Only Scan using idx_hash_a on partition_minmax.test_hash_ht
                                   Output: partition_minmax.test_hash_ht.a
                                   Index Cond: (partition_minmax.test_hash_ht.a IS NOT NULL)
                                   Selected Partitions:  1..8
(17 rows)

select min(a) from test_hash_ht;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(a) from test_hash_ht;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_hash_ht.a
           ->  Sort
                 Output: partition_minmax.test_hash_ht.a
                 Sort Key: partition_minmax.test_hash_ht.a DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_hash_ht.a
                       Iterations: 8
                       ->  Limit
                             Output: partition_minmax.test_hash_ht.a
                             ->  Partitioned Index Only Scan Backward using idx_hash_a on partition_minmax.test_hash_ht
                                   Output: partition_minmax.test_hash_ht.a
                                   Index Cond: (partition_minmax.test_hash_ht.a IS NOT NULL)
                                   Selected Partitions:  1..8
(17 rows)

select max(a) from test_hash_ht;
 max 
-----
 100
(1 row)

explain(costs off, verbose on) select min(b) from test_hash_ht;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_hash_ht.b
           ->  Sort
                 Output: partition_minmax.test_hash_ht.b
                 Sort Key: partition_minmax.test_hash_ht.b
                 ->  Partition Iterator
                       Output: partition_minmax.test_hash_ht.b
                       Iterations: 8
                       ->  Limit
                             Output: partition_minmax.test_hash_ht.b
                             ->  Partitioned Index Only Scan using idx_hash_b on partition_minmax.test_hash_ht
                                   Output: partition_minmax.test_hash_ht.b
                                   Index Cond: (partition_minmax.test_hash_ht.b IS NOT NULL)
                                   Selected Partitions:  1..8
(17 rows)

select min(b) from test_hash_ht;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(b) from test_hash_ht;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_hash_ht.b
           ->  Sort
                 Output: partition_minmax.test_hash_ht.b
                 Sort Key: partition_minmax.test_hash_ht.b DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_hash_ht.b
                       Iterations: 8
                       ->  Limit
                             Output: partition_minmax.test_hash_ht.b
                             ->  Partitioned Index Only Scan Backward using idx_hash_b on partition_minmax.test_hash_ht
                                   Output: partition_minmax.test_hash_ht.b
                                   Index Cond: (partition_minmax.test_hash_ht.b IS NOT NULL)
                                   Selected Partitions:  1..8
(17 rows)

select max(b) from test_hash_ht;
 max 
-----
 100
(1 row)

--hash分区多列索引
drop index idx_hash_a;
drop index idx_hash_b;
create index idx_hash_ab on test_hash_ht(a,b) local;
explain(costs off, verbose on) select min(a) from test_hash_ht;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_hash_ht.a
           ->  Sort
                 Output: partition_minmax.test_hash_ht.a
                 Sort Key: partition_minmax.test_hash_ht.a
                 ->  Partition Iterator
                       Output: partition_minmax.test_hash_ht.a
                       Iterations: 8
                       ->  Limit
                             Output: partition_minmax.test_hash_ht.a
                             ->  Partitioned Index Only Scan using idx_hash_ab on partition_minmax.test_hash_ht
                                   Output: partition_minmax.test_hash_ht.a
                                   Index Cond: (partition_minmax.test_hash_ht.a IS NOT NULL)
                                   Selected Partitions:  1..8
(17 rows)

select min(a) from test_hash_ht;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(a) from test_hash_ht;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_hash_ht.a
           ->  Sort
                 Output: partition_minmax.test_hash_ht.a
                 Sort Key: partition_minmax.test_hash_ht.a DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_hash_ht.a
                       Iterations: 8
                       ->  Limit
                             Output: partition_minmax.test_hash_ht.a
                             ->  Partitioned Index Only Scan Backward using idx_hash_ab on partition_minmax.test_hash_ht
                                   Output: partition_minmax.test_hash_ht.a
                                   Index Cond: (partition_minmax.test_hash_ht.a IS NOT NULL)
                                   Selected Partitions:  1..8
(17 rows)

select max(a) from test_hash_ht;
 max 
-----
 100
(1 row)

--多列索引非第一列不优化
explain(costs off, verbose on) select min(b) from test_hash_ht;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Aggregate
   Output: min(b)
   ->  Partition Iterator
         Output: a, b
         Iterations: 8
         ->  Partitioned Seq Scan on partition_minmax.test_hash_ht
               Output: a, b
               Selected Partitions:  1..8
(8 rows)

select min(b) from test_hash_ht;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(b) from test_hash_ht;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Aggregate
   Output: max(b)
   ->  Partition Iterator
         Output: a, b
         Iterations: 8
         ->  Partitioned Seq Scan on partition_minmax.test_hash_ht
               Output: a, b
               Selected Partitions:  1..8
(8 rows)

select max(b) from test_hash_ht;
 max 
-----
 100
(1 row)

--二级分区单列索引
drop table range_list;
ERROR:  table "range_list" does not exist
CREATE TABLE range_list
(
    month_code VARCHAR2 ( 30 ) NOT NULL ,
    dept_code  VARCHAR2 ( 30 ) NOT NULL ,
    user_no    VARCHAR2 ( 30 ) NOT NULL ,
    sales_amt  int
)
PARTITION BY RANGE (month_code) SUBPARTITION BY LIST (dept_code)
(
  PARTITION p_201901 VALUES LESS THAN( '201903' )
  (
    SUBPARTITION p_201901_a values ('1'),
    SUBPARTITION p_201901_b values ('2'),
	SUBPARTITION p_201901_c values ('3')
  ),
  PARTITION p_201902 VALUES LESS THAN( '201910' )
  (
    SUBPARTITION p_201902_a values ('1'),
    SUBPARTITION p_201902_b values ('2'),
	SUBPARTITION p_201902_c values ('3')
  )
);
create index idx_month_code on range_list(month_code) local;
create index idx_dept_code on range_list(dept_code) local;
create index idx_sales_amt on range_list(sales_amt) local;
insert into range_list values('201901', '1', '1', 1);
insert into range_list values('201902', '2', '1', 5);
insert into range_list values('201902', '3', '1', 3);
insert into range_list values('201903', '1', '1', 2);
insert into range_list values('201904', '2', '1', 6);
insert into range_list values('201905', '3', '1', 4);
explain(costs off, verbose on) select min(month_code) from range_list;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: ((partition_minmax.range_list.month_code)::text)
           ->  Sort
                 Output: ((partition_minmax.range_list.month_code)::text)
                 Sort Key: ((partition_minmax.range_list.month_code)::text)
                 ->  Partition Iterator
                       Output: ((partition_minmax.range_list.month_code)::text)
                       Iterations: 2
                       ->  Limit
                             Output: ((partition_minmax.range_list.month_code)::text)
                             ->  Partitioned Index Only Scan using idx_month_code on partition_minmax.range_list
                                   Output: partition_minmax.range_list.month_code
                                   Index Cond: (partition_minmax.range_list.month_code IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select min(month_code) from range_list;
  min   
--------
 201901
(1 row)

explain(costs off, verbose on) select max(month_code) from range_list;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: ((partition_minmax.range_list.month_code)::text)
           ->  Sort
                 Output: ((partition_minmax.range_list.month_code)::text)
                 Sort Key: ((partition_minmax.range_list.month_code)::text) DESC
                 ->  Partition Iterator
                       Output: ((partition_minmax.range_list.month_code)::text)
                       Iterations: 2
                       ->  Limit
                             Output: ((partition_minmax.range_list.month_code)::text)
                             ->  Partitioned Index Only Scan Backward using idx_month_code on partition_minmax.range_list
                                   Output: partition_minmax.range_list.month_code
                                   Index Cond: (partition_minmax.range_list.month_code IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select max(month_code) from range_list;
  max   
--------
 201905
(1 row)

explain(costs off, verbose on) select min(dept_code) from range_list;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: ((partition_minmax.range_list.dept_code)::text)
           ->  Sort
                 Output: ((partition_minmax.range_list.dept_code)::text)
                 Sort Key: ((partition_minmax.range_list.dept_code)::text)
                 ->  Partition Iterator
                       Output: ((partition_minmax.range_list.dept_code)::text)
                       Iterations: 2
                       ->  Limit
                             Output: ((partition_minmax.range_list.dept_code)::text)
                             ->  Partitioned Index Only Scan using idx_dept_code on partition_minmax.range_list
                                   Output: partition_minmax.range_list.dept_code
                                   Index Cond: (partition_minmax.range_list.dept_code IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select min(dept_code) from range_list;
 min 
-----
 1
(1 row)

explain(costs off, verbose on) select max(dept_code) from range_list;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: ((partition_minmax.range_list.dept_code)::text)
           ->  Sort
                 Output: ((partition_minmax.range_list.dept_code)::text)
                 Sort Key: ((partition_minmax.range_list.dept_code)::text) DESC
                 ->  Partition Iterator
                       Output: ((partition_minmax.range_list.dept_code)::text)
                       Iterations: 2
                       ->  Limit
                             Output: ((partition_minmax.range_list.dept_code)::text)
                             ->  Partitioned Index Only Scan Backward using idx_dept_code on partition_minmax.range_list
                                   Output: partition_minmax.range_list.dept_code
                                   Index Cond: (partition_minmax.range_list.dept_code IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select max(dept_code) from range_list;
 max 
-----
 3
(1 row)

explain(costs off, verbose on) select min(sales_amt) from range_list;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.range_list.sales_amt
           ->  Sort
                 Output: partition_minmax.range_list.sales_amt
                 Sort Key: partition_minmax.range_list.sales_amt
                 ->  Partition Iterator
                       Output: partition_minmax.range_list.sales_amt
                       Iterations: 2
                       ->  Limit
                             Output: partition_minmax.range_list.sales_amt
                             ->  Partitioned Index Only Scan using idx_sales_amt on partition_minmax.range_list
                                   Output: partition_minmax.range_list.sales_amt
                                   Index Cond: (partition_minmax.range_list.sales_amt IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select min(sales_amt) from range_list;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(sales_amt) from range_list;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.range_list.sales_amt
           ->  Sort
                 Output: partition_minmax.range_list.sales_amt
                 Sort Key: partition_minmax.range_list.sales_amt DESC
                 ->  Partition Iterator
                       Output: partition_minmax.range_list.sales_amt
                       Iterations: 2
                       ->  Limit
                             Output: partition_minmax.range_list.sales_amt
                             ->  Partitioned Index Only Scan Backward using idx_sales_amt on partition_minmax.range_list
                                   Output: partition_minmax.range_list.sales_amt
                                   Index Cond: (partition_minmax.range_list.sales_amt IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select max(sales_amt) from range_list;
 max 
-----
   6
(1 row)

--二级分区多列索引
drop index idx_month_code;
drop index idx_dept_code;
drop index idx_sales_amt;
create index idx_1_2 on range_list(month_code, dept_code) local;
explain(costs off, verbose on) select min(month_code) from range_list;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: ((partition_minmax.range_list.month_code)::text)
           ->  Sort
                 Output: ((partition_minmax.range_list.month_code)::text)
                 Sort Key: ((partition_minmax.range_list.month_code)::text)
                 ->  Partition Iterator
                       Output: ((partition_minmax.range_list.month_code)::text)
                       Iterations: 2
                       ->  Limit
                             Output: ((partition_minmax.range_list.month_code)::text)
                             ->  Partitioned Index Only Scan using idx_1_2 on partition_minmax.range_list
                                   Output: partition_minmax.range_list.month_code
                                   Index Cond: (partition_minmax.range_list.month_code IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select min(month_code) from range_list;
  min   
--------
 201901
(1 row)

explain(costs off, verbose on) select max(month_code) from range_list;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: ((partition_minmax.range_list.month_code)::text)
           ->  Sort
                 Output: ((partition_minmax.range_list.month_code)::text)
                 Sort Key: ((partition_minmax.range_list.month_code)::text) DESC
                 ->  Partition Iterator
                       Output: ((partition_minmax.range_list.month_code)::text)
                       Iterations: 2
                       ->  Limit
                             Output: ((partition_minmax.range_list.month_code)::text)
                             ->  Partitioned Index Only Scan Backward using idx_1_2 on partition_minmax.range_list
                                   Output: partition_minmax.range_list.month_code
                                   Index Cond: (partition_minmax.range_list.month_code IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select max(month_code) from range_list;
  max   
--------
 201905
(1 row)

--多列索引非第一列不优化
explain(costs off, verbose on) select min(dept_code) from range_list;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Aggregate
   Output: min((dept_code)::text)
   ->  Partition Iterator
         Output: month_code, dept_code, user_no, sales_amt
         Iterations: 2, Sub Iterations: 6
         ->  Partitioned Seq Scan on partition_minmax.range_list
               Output: month_code, dept_code, user_no, sales_amt
               Selected Partitions:  1..2
               Selected Subpartitions:  ALL
(9 rows)

select min(dept_code) from range_list;
 min 
-----
 1
(1 row)

explain(costs off, verbose on) select max(dept_code) from range_list;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Aggregate
   Output: max((dept_code)::text)
   ->  Partition Iterator
         Output: month_code, dept_code, user_no, sales_amt
         Iterations: 2, Sub Iterations: 6
         ->  Partitioned Seq Scan on partition_minmax.range_list
               Output: month_code, dept_code, user_no, sales_amt
               Selected Partitions:  1..2
               Selected Subpartitions:  ALL
(9 rows)

select max(dept_code) from range_list;
 max 
-----
 3
(1 row)

drop index idx_1_2;
create index idx_4_2 on range_list(sales_amt, dept_code) local;
explain(costs off, verbose on) select min(sales_amt) from range_list;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.range_list.sales_amt
           ->  Sort
                 Output: partition_minmax.range_list.sales_amt
                 Sort Key: partition_minmax.range_list.sales_amt
                 ->  Partition Iterator
                       Output: partition_minmax.range_list.sales_amt
                       Iterations: 2
                       ->  Limit
                             Output: partition_minmax.range_list.sales_amt
                             ->  Partitioned Index Only Scan using idx_4_2 on partition_minmax.range_list
                                   Output: partition_minmax.range_list.sales_amt
                                   Index Cond: (partition_minmax.range_list.sales_amt IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select min(sales_amt) from range_list;
 min 
-----
   1
(1 row)

explain(costs off, verbose on) select max(sales_amt) from range_list;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.range_list.sales_amt
           ->  Sort
                 Output: partition_minmax.range_list.sales_amt
                 Sort Key: partition_minmax.range_list.sales_amt DESC
                 ->  Partition Iterator
                       Output: partition_minmax.range_list.sales_amt
                       Iterations: 2
                       ->  Limit
                             Output: partition_minmax.range_list.sales_amt
                             ->  Partitioned Index Only Scan Backward using idx_4_2 on partition_minmax.range_list
                                   Output: partition_minmax.range_list.sales_amt
                                   Index Cond: (partition_minmax.range_list.sales_amt IS NOT NULL)
                                   Selected Partitions:  1..2
                                   Selected Subpartitions:  ALL
(18 rows)

select max(sales_amt) from range_list;
 max 
-----
   6
(1 row)

--多列索引非第一列不优化
explain(costs off, verbose on) select min(dept_code) from range_list;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Aggregate
   Output: min((dept_code)::text)
   ->  Partition Iterator
         Output: month_code, dept_code, user_no, sales_amt
         Iterations: 2, Sub Iterations: 6
         ->  Partitioned Seq Scan on partition_minmax.range_list
               Output: month_code, dept_code, user_no, sales_amt
               Selected Partitions:  1..2
               Selected Subpartitions:  ALL
(9 rows)

select min(dept_code) from range_list;
 min 
-----
 1
(1 row)

explain(costs off, verbose on) select max(dept_code) from range_list;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Aggregate
   Output: max((dept_code)::text)
   ->  Partition Iterator
         Output: month_code, dept_code, user_no, sales_amt
         Iterations: 2, Sub Iterations: 6
         ->  Partitioned Seq Scan on partition_minmax.range_list
               Output: month_code, dept_code, user_no, sales_amt
               Selected Partitions:  1..2
               Selected Subpartitions:  ALL
(9 rows)

select max(dept_code) from range_list;
 max 
-----
 3
(1 row)

--其它场景
drop table test_list_lt;
create table test_list_lt (a int, b int )
partition by list(a)
(
	partition p1 values (2000),
	partition p2 values (3000),
	partition p3 values (4000)
) ;
create index idx_list_a on test_list_lt(a) local;
create index idx_list_b on test_list_lt(b) local;
insert into test_list_lt values(3000, 2);
insert into test_list_lt values(2000, 30);
insert into test_list_lt values(4000, 20);
explain(costs off, verbose on) select min(t1.a) from test_list_lt t1 join test_list_lt t2 on t1.a = t2.a;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate
   Output: min(t1.a)
   ->  Hash Join
         Output: t1.a
         Hash Cond: (t1.a = t2.a)
         ->  Partition Iterator
               Output: t1.a, t1.b
               Iterations: 3
               ->  Partitioned Seq Scan on partition_minmax.test_list_lt t1
                     Output: t1.a, t1.b
                     Selected Partitions:  1..3
         ->  Hash
               Output: t2.a
               ->  Partition Iterator
                     Output: t2.a
                     Iterations: 3
                     ->  Partitioned Seq Scan on partition_minmax.test_list_lt t2
                           Output: t2.a
                           Selected Partitions:  1..3
(19 rows)

explain(costs off, verbose on) select min(t1.a) from test_list_lt t1 join test_list_lt t2 on t1.b = t2.b;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate
   Output: min(t1.a)
   ->  Hash Join
         Output: t1.a
         Hash Cond: (t1.b = t2.b)
         ->  Partition Iterator
               Output: t1.a, t1.b
               Iterations: 3
               ->  Partitioned Seq Scan on partition_minmax.test_list_lt t1
                     Output: t1.a, t1.b
                     Selected Partitions:  1..3
         ->  Hash
               Output: t2.b
               ->  Partition Iterator
                     Output: t2.b
                     Iterations: 3
                     ->  Partitioned Seq Scan on partition_minmax.test_list_lt t2
                           Output: t2.b
                           Selected Partitions:  1..3
(19 rows)

explain(costs off, verbose on) select min(t1.a) from test_list_lt t1 union all select min(t2.a) from test_list_lt t2;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: ($2)
   ->  Append
         ->  Result
               Output: $2
               InitPlan 1 (returns $2)
                 ->  Limit
                       Output: t1.a
                       ->  Sort
                             Output: t1.a
                             Sort Key: t1.a
                             ->  Partition Iterator
                                   Output: t1.a
                                   Iterations: 3
                                   ->  Limit
                                         Output: t1.a
                                         ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt t1
                                               Output: t1.a
                                               Index Cond: (t1.a IS NOT NULL)
                                               Selected Partitions:  1..3
         ->  Result
               Output: $5
               InitPlan 2 (returns $5)
                 ->  Limit
                       Output: t2.a
                       ->  Sort
                             Output: t2.a
                             Sort Key: t2.a
                             ->  Partition Iterator
                                   Output: t2.a
                                   Iterations: 3
                                   ->  Limit
                                         Output: t2.a
                                         ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt t2
                                               Output: t2.a
                                               Index Cond: (t2.a IS NOT NULL)
                                               Selected Partitions:  1..3
(37 rows)

select min(t1.a) from test_list_lt t1 union all select min(t2.a) from test_list_lt t2;
 min  
------
 2000
 2000
(2 rows)

explain(costs off, verbose on) select min(t1.a) from test_list_lt t1 union all select min(t2.b) from test_list_lt t2;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: ($2)
   ->  Append
         ->  Result
               Output: $2
               InitPlan 1 (returns $2)
                 ->  Limit
                       Output: t1.a
                       ->  Sort
                             Output: t1.a
                             Sort Key: t1.a
                             ->  Partition Iterator
                                   Output: t1.a
                                   Iterations: 3
                                   ->  Limit
                                         Output: t1.a
                                         ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt t1
                                               Output: t1.a
                                               Index Cond: (t1.a IS NOT NULL)
                                               Selected Partitions:  1..3
         ->  Result
               Output: $5
               InitPlan 2 (returns $5)
                 ->  Limit
                       Output: t2.b
                       ->  Sort
                             Output: t2.b
                             Sort Key: t2.b
                             ->  Partition Iterator
                                   Output: t2.b
                                   Iterations: 3
                                   ->  Limit
                                         Output: t2.b
                                         ->  Partitioned Index Only Scan using idx_list_b on partition_minmax.test_list_lt t2
                                               Output: t2.b
                                               Index Cond: (t2.b IS NOT NULL)
                                               Selected Partitions:  1..3
(37 rows)

select min(t1.a) from test_list_lt t1 union all select min(t2.b) from test_list_lt t2;
 min  
------
 2000
    2
(2 rows)

explain(costs off, verbose on) select * from test_list_lt t1 where a = (select min(t2.a) from test_list_lt t2);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Partition Iterator
   Output: t1.a, t1.b
   Iterations: 3
   InitPlan 2 (returns $3)
     ->  Result
           Output: $2
           InitPlan 1 (returns $2)
             ->  Limit
                   Output: t2.a
                   ->  Sort
                         Output: t2.a
                         Sort Key: t2.a
                         ->  Partition Iterator
                               Output: t2.a
                               Iterations: 3
                               ->  Limit
                                     Output: t2.a
                                     ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt t2
                                           Output: t2.a
                                           Index Cond: (t2.a IS NOT NULL)
                                           Selected Partitions:  1..3
   ->  Partitioned Bitmap Heap Scan on partition_minmax.test_list_lt t1
         Output: t1.a, t1.b
         Recheck Cond: (t1.a = $3)
         Selected Partitions:  1..3
         ->  Partitioned Bitmap Index Scan on idx_list_a
               Index Cond: (t1.a = $3)
               Selected Partitions:  1..3
(28 rows)

select * from test_list_lt t1 where a = (select min(t2.a) from test_list_lt t2);
  a   | b  
------+----
 2000 | 30
(1 row)

explain(costs off, verbose on) select * from test_list_lt s1 where (select min(s2.a) from test_list_lt s2) > 1 order by 1;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: s1.a, s1.b
   Sort Key: s1.a
   InitPlan 2 (returns $3)
     ->  Result
           Output: $2
           InitPlan 1 (returns $2)
             ->  Limit
                   Output: s2.a
                   ->  Sort
                         Output: s2.a
                         Sort Key: s2.a
                         ->  Partition Iterator
                               Output: s2.a
                               Iterations: 3
                               ->  Limit
                                     Output: s2.a
                                     ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt s2
                                           Output: s2.a
                                           Index Cond: (s2.a IS NOT NULL)
                                           Selected Partitions:  1..3
   ->  Result
         Output: s1.a, s1.b
         One-Time Filter: ($3 > 1)
         ->  Partition Iterator
               Output: s1.a, s1.b
               Iterations: 3
               ->  Partitioned Seq Scan on partition_minmax.test_list_lt s1
                     Output: s1.a, s1.b
                     Selected Partitions:  1..3
(30 rows)

select * from test_list_lt s1 where (select min(s2.a) from test_list_lt s2) > 1 order by 1;
  a   | b  
------+----
 2000 | 30
 3000 |  2
 4000 | 20
(3 rows)

explain(costs off, verbose on) select * from test_list_lt s1, (select min(s2.a) from test_list_lt s2) tmp(a) where tmp.a = s1.a;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: s1.a, s1.b, ($2)
   ->  Result
         Output: $2
         InitPlan 1 (returns $2)
           ->  Limit
                 Output: s2.a
                 ->  Sort
                       Output: s2.a
                       Sort Key: s2.a
                       ->  Partition Iterator
                             Output: s2.a
                             Iterations: 3
                             ->  Limit
                                   Output: s2.a
                                   ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt s2
                                         Output: s2.a
                                         Index Cond: (s2.a IS NOT NULL)
                                         Selected Partitions:  1..3
   ->  Partition Iterator
         Output: s1.a, s1.b
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on partition_minmax.test_list_lt s1
               Output: s1.a, s1.b
               Recheck Cond: (s1.a = ($2))
               Selected Partitions:  1..3
               ->  Partitioned Bitmap Index Scan on idx_list_a
                     Index Cond: (s1.a = ($2))
                     Selected Partitions:  1..3
(29 rows)

select * from test_list_lt s1, (select min(s2.a) from test_list_lt s2) tmp(a) where tmp.a = s1.a;
  a   | b  |  a   
------+----+------
 2000 | 30 | 2000
(1 row)

set enable_seqscan = off;
set enable_bitmapscan = off;
explain(costs off, verbose on) select min(a) from test_list_lt where a = 2000;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.a
           ->  Partitioned Index Only Scan using idx_list_a on partition_minmax.test_list_lt
                 Output: partition_minmax.test_list_lt.a
                 Index Cond: ((partition_minmax.test_list_lt.a IS NOT NULL) AND (partition_minmax.test_list_lt.a = 2000))
                 Selected Partitions:  1
(9 rows)

select min(a) from test_list_lt where a = 2000;
 min  
------
 2000
(1 row)

explain(costs off, verbose on) select min(b) from test_list_lt where b = 20;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_list_lt.b
           ->  Partition Iterator
                 Output: partition_minmax.test_list_lt.b
                 Iterations: 3
                 ->  Partitioned Index Only Scan using idx_list_b on partition_minmax.test_list_lt
                       Output: partition_minmax.test_list_lt.b
                       Index Cond: ((partition_minmax.test_list_lt.b IS NOT NULL) AND (partition_minmax.test_list_lt.b = 20))
                       Selected Partitions:  1..3
(12 rows)

select min(b) from test_list_lt where b = 20;
 min 
-----
  20
(1 row)

reset enable_seqscan;
reset enable_bitmapscan;
drop table  hash_hash_jade cascade;
ERROR:  table "hash_hash_jade" does not exist
create table  hash_hash_jade(hjid int,rjid int,jname varchar2)partition by hash (hjid) subpartition by hash(rjid)
(
  partition hhp1(
    subpartition hhp1_1,
    subpartition hhp1_2),
  partition hhp2(
    subpartition hhp2_1,
    subpartition hhp2_2),
  partition hhp3(
    subpartition hhp3_1,
    subpartition hhp3_2),
  partition hhp4(
    subpartition hhp4_1,
    subpartition hhp4_2)
);
insert into  hash_hash_jade(hjid,rjid,jname)values(generate_series(1,100),generate_series(200,300),'jade');
insert into  hash_hash_jade(hjid,rjid,jname)values(generate_series(400,500),generate_series(700,800),'twojade');
insert into hash_hash_jade values(1,1,null);
drop table  hash_hash_jade2 cascade;
ERROR:  table "hash_hash_jade2" does not exist
create table  hash_hash_jade2(hjid int,rjid int,jname varchar2)partition by hash (hjid) subpartition by hash(rjid)
(
  partition hhp1(
    subpartition hhp1_1,
    subpartition hhp1_2),
  partition hhp2(
    subpartition hhp2_1,
    subpartition hhp2_2),
  partition hhp3(
    subpartition hhp3_1,
    subpartition hhp3_2),
  partition hhp4(
    subpartition hhp4_1,
    subpartition hhp4_2)
);
insert into  hash_hash_jade2(hjid,rjid,jname)values(generate_series(50,400),generate_series(266,700),'jade');
insert into  hash_hash_jade2(hjid,rjid,jname)values(generate_series(351,852),generate_series(700,800),'twojade');
insert into hash_hash_jade2 values(1,1,null);
drop index hh1;
ERROR:  index "hh1" does not exist
drop index hh2;
ERROR:  index "hh2" does not exist
drop index hh3;
ERROR:  index "hh3" does not exist
drop index hh4;
ERROR:  index "hh4" does not exist
create index hh1 on hash_hash_jade(hjid) local;
create index hh2 on hash_hash_jade(rjid) local;
create index hh3 on hash_hash_jade2(hjid) local;
create index hh4 on hash_hash_jade2(rjid) local;
explain(costs off, verbose on)  select max(hjid),min(rjid) from hash_hash_jade where exists(select min(hjid) from hash_hash_jade2 group by rjid);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $5, $8
   InitPlan 1 (returns $2)
     ->  HashAggregate
           Output: min(hash_hash_jade2.hjid), hash_hash_jade2.rjid
           Group By Key: hash_hash_jade2.rjid
           ->  Partition Iterator
                 Output: hash_hash_jade2.rjid, hash_hash_jade2.hjid
                 Iterations: 4, Sub Iterations: 8
                 ->  Partitioned Seq Scan on partition_minmax.hash_hash_jade2
                       Output: hash_hash_jade2.rjid, hash_hash_jade2.hjid
                       Selected Partitions:  1..4
                       Selected Subpartitions:  ALL
   InitPlan 2 (returns $5)
     ->  Limit
           Output: partition_minmax.hash_hash_jade.hjid
           ->  Sort
                 Output: partition_minmax.hash_hash_jade.hjid
                 Sort Key: partition_minmax.hash_hash_jade.hjid DESC
                 ->  Result
                       Output: partition_minmax.hash_hash_jade.hjid
                       One-Time Filter: $2
                       ->  Partition Iterator
                             Output: partition_minmax.hash_hash_jade.hjid
                             Iterations: 4
                             ->  Limit
                                   Output: partition_minmax.hash_hash_jade.hjid
                                   ->  Partitioned Index Only Scan Backward using hh1 on partition_minmax.hash_hash_jade
                                         Output: partition_minmax.hash_hash_jade.hjid
                                         Index Cond: (partition_minmax.hash_hash_jade.hjid IS NOT NULL)
                                         Selected Partitions:  1..4
                                         Selected Subpartitions:  ALL
   InitPlan 3 (returns $8)
     ->  Limit
           Output: partition_minmax.hash_hash_jade.rjid
           ->  Sort
                 Output: partition_minmax.hash_hash_jade.rjid
                 Sort Key: partition_minmax.hash_hash_jade.rjid
                 ->  Result
                       Output: partition_minmax.hash_hash_jade.rjid
                       One-Time Filter: $2
                       ->  Partition Iterator
                             Output: partition_minmax.hash_hash_jade.rjid
                             Iterations: 4
                             ->  Limit
                                   Output: partition_minmax.hash_hash_jade.rjid
                                   ->  Partitioned Index Only Scan using hh2 on partition_minmax.hash_hash_jade
                                         Output: partition_minmax.hash_hash_jade.rjid
                                         Index Cond: (partition_minmax.hash_hash_jade.rjid IS NOT NULL)
                                         Selected Partitions:  1..4
                                         Selected Subpartitions:  ALL
(51 rows)

select max(hjid),min(rjid) from hash_hash_jade where exists(select min(hjid) from hash_hash_jade2 group by rjid);
 max | min 
-----+-----
 500 |   1
(1 row)

drop table hash_hash_jade cascade;
drop table  hash_hash_jade2 cascade;
drop table test_list_lt;
create table test_list_lt (a int, b int )
partition by list(a)
(
	partition p1 values (2000),
	partition p2 values (3000),
	partition p3 values (4000)
) ;
create index idx_list_a on test_list_lt(a) local;
create index idx_list_b on test_list_lt(b) local;
insert into test_list_lt values(3000,300),(2000,2000),(4000,4000);
alter index idx_list_b  MODIFY PARTITION p3_b_idx UNUSABLE;
explain(costs off, verbose on)   select max(b) from test_list_lt;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Aggregate
   Output: max(b)
   ->  Partition Iterator
         Output: a, b
         Iterations: 3
         ->  Partitioned Seq Scan on partition_minmax.test_list_lt
               Output: a, b
               Selected Partitions:  1..3
(8 rows)

select max(b) from test_list_lt;
 max  
------
 4000
(1 row)

drop table test_range_pt;
drop table test_range_pt1;
drop table test_list_lt;
drop table test_hash_ht;
drop table range_list;
drop table if exists partition_range_pbe_tbl_001;
NOTICE:  table "partition_range_pbe_tbl_001" does not exist, skipping
create table partition_range_pbe_tbl_001(
c_id int,c_d_id int,c_w_id int,c_first varchar2(20),c_middle char(2),c_last varchar2(30),
c_date date,c_timestamp timestamp,c_clob clob,c_blob blob,c_text text)
partition by range(c_id) subpartition by list (c_d_id)(
partition p1 values less than(10)
(
    SUBPARTITION p1_a values (1,2,3,4),
    SUBPARTITION p1_b values (5,6),
    SUBPARTITION p1_c values (7),
    SUBPARTITION p1_d values (8,9),
    SUBPARTITION p1_e values (10)
),
partition p2 values less than(20)
(
    SUBPARTITION p2_a values (1,2,3,4),
    SUBPARTITION p2_b values (5,6),
    SUBPARTITION p2_c values (7),
    SUBPARTITION p2_d values (8,9),
    SUBPARTITION p2_e values (10)
),
partition p3 values less than(30)
(
    SUBPARTITION p3_a values (1,2,3,4),
    SUBPARTITION p3_b values (5,6),
    SUBPARTITION p3_c values (7),
    SUBPARTITION p3_d values (8,9),
    SUBPARTITION p3_e values (10)
),
partition p4 values less than(40)
(
    SUBPARTITION p4_a values (1,2,3,4),
    SUBPARTITION p4_b values (5,6),
    SUBPARTITION p4_c values (7),
    SUBPARTITION p4_d values (8,9),
    SUBPARTITION p4_e values (10)
),
partition p5 values less than(maxvalue)
(
    SUBPARTITION p5_a values (1,2,3,4),
    SUBPARTITION p5_b values (5,6),
    SUBPARTITION p5_c values (7),
    SUBPARTITION p5_d values (8,9),
    SUBPARTITION p5_e values (10)
));
insert into partition_range_pbe_tbl_001 values(generate_series(1,100),generate_series(1,10));
create index partition_range_pbe_idx_001 on partition_range_pbe_tbl_001(c_id) local;
set enable_seqscan = off;
explain(costs off, verbose on) select max(c_id) from partition_range_pbe_tbl_001 where c_d_id = 1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.partition_range_pbe_tbl_001.c_id
           ->  Sort
                 Output: partition_minmax.partition_range_pbe_tbl_001.c_id
                 Sort Key: partition_minmax.partition_range_pbe_tbl_001.c_id DESC
                 ->  Partition Iterator
                       Output: partition_minmax.partition_range_pbe_tbl_001.c_id
                       Iterations: 5
                       ->  Limit
                             Output: partition_minmax.partition_range_pbe_tbl_001.c_id
                             ->  Partitioned Index Scan Backward using partition_range_pbe_idx_001 on partition_minmax.partition_range_pbe_tbl_001
                                   Output: partition_minmax.partition_range_pbe_tbl_001.c_id
                                   Index Cond: (partition_minmax.partition_range_pbe_tbl_001.c_id IS NOT NULL)
                                   Filter: (partition_minmax.partition_range_pbe_tbl_001.c_d_id = 1)
                                   Selected Partitions:  1..5
                                   Selected Subpartitions:  1:1, 2:1, 3:1, 4:1, 5:1
(19 rows)

select max(c_id) from partition_range_pbe_tbl_001 where c_d_id = 1;
 max 
-----
  91
(1 row)

create index partition_range_pbe_idx_002 on partition_range_pbe_tbl_001(c_d_id) local;
explain(costs off, verbose on) select max(c_id) from partition_range_pbe_tbl_001 where c_d_id = 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: max(c_id)
   ->  Partition Iterator
         Output: c_id, c_d_id, c_w_id, c_first, c_middle, c_last, c_date, c_timestamp, c_clob, c_blob, c_text
         Iterations: 5, Sub Iterations: 5
         ->  Partitioned Bitmap Heap Scan on partition_minmax.partition_range_pbe_tbl_001
               Output: c_id, c_d_id, c_w_id, c_first, c_middle, c_last, c_date, c_timestamp, c_clob, c_blob, c_text
               Recheck Cond: (partition_range_pbe_tbl_001.c_d_id = 1)
               Selected Partitions:  1..5
               Selected Subpartitions:  1:1, 2:1, 3:1, 4:1, 5:1
               ->  Partitioned Bitmap Index Scan on partition_range_pbe_idx_002
                     Index Cond: (partition_range_pbe_tbl_001.c_d_id = 1)
                     Selected Partitions:  1..5
                     Selected Subpartitions:  1:1, 2:1, 3:1, 4:1, 5:1
(14 rows)

select max(c_id) from partition_range_pbe_tbl_001 where c_d_id = 1;
 max 
-----
  91
(1 row)

reset enable_seqscan;
drop table partition_range_pbe_tbl_001;
drop table test_range_pt;
ERROR:  table "test_range_pt" does not exist
create table test_range_pt (a int, b int, c int)
partition by range(a)
(
	partition p1 values less than (20),
	partition p2 values less than (30),
	partition p3 values less than (40),
	partition p4 values less than (50),
	partition p5 values less than (maxvalue)
)ENABLE ROW MOVEMENT;
insert into test_range_pt values(generate_series(1,100),generate_series(1,100),generate_series(1,10));
create index idx_range_a on test_range_pt(a) local;
create index idx_range_b on test_range_pt(b) local;
explain(costs off, verbose on) select max(b) from test_range_pt where c = 1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Result
   Output: $2
   InitPlan 1 (returns $2)
     ->  Limit
           Output: partition_minmax.test_range_pt.b
           ->  Sort
                 Output: partition_minmax.test_range_pt.b
                 Sort Key: partition_minmax.test_range_pt.b DESC
                 ->  Partition Iterator
                       Output: partition_minmax.test_range_pt.b
                       Iterations: 5
                       ->  Limit
                             Output: partition_minmax.test_range_pt.b
                             ->  Partitioned Index Scan Backward using idx_range_b on partition_minmax.test_range_pt
                                   Output: partition_minmax.test_range_pt.b
                                   Index Cond: (partition_minmax.test_range_pt.b IS NOT NULL)
                                   Filter: (partition_minmax.test_range_pt.c = 1)
                                   Selected Partitions:  1..5
(18 rows)

select max(b) from test_range_pt where c = 1;
 max 
-----
  91
(1 row)

create index idx_range_c on test_range_pt(c) local;
explain(costs off, verbose on) select max(b) from test_range_pt where c = 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Aggregate
   Output: max(b)
   ->  Partition Iterator
         Output: a, b, c
         Iterations: 5
         ->  Partitioned Bitmap Heap Scan on partition_minmax.test_range_pt
               Output: a, b, c
               Recheck Cond: (test_range_pt.c = 1)
               Selected Partitions:  1..5
               ->  Partitioned Bitmap Index Scan on idx_range_c
                     Index Cond: (test_range_pt.c = 1)
                     Selected Partitions:  1..5
(12 rows)

select max(b) from test_range_pt where c = 1;
 max 
-----
  91
(1 row)

drop table test_range_pt;
DROP SCHEMA partition_minmax CASCADE;
